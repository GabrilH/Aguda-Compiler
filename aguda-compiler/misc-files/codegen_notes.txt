DUAS PASSAGENS PELA AST
    - 1ª colecionar tipos de funções
    - 2ª gerar codigo

- tradução de expressôes:
    - condGen :
    - expGen  : Exp (AST) -> (LLVMCode, Value)
    -> condGen e expGen mutuamente recursivas (tipo checkAgainst e typeof)


    - Value ::= Register | Literal (Int | Bool | Unit)
    - LLVMCode ::= Lista de instruções

        {exp}  {codigo, valor, tipo, label}
    ctx |- e -> (c,v,t,l)
        {in}    {out}

    Literals expGen:
    
        |- n -> ([],n)
        
        |- b -> ([],b)

        |- unit -> ([],1)

    Sequence:

        |- e1 -> (c1,r1)    |- e2 -> (c2,r2)
        -----------------------------------
        |- e1;e2 -> ([c1,c2], r2)

    BinOp aritméticas:
                                            r fresh
                                            --------
        |- e1 -> (c1,v1)    |- e2 -> (c2,v2)    |
        ------------------------------------------
        |- e1 + e2 -> (
            [c1;c2; r = add i32, v1,v2],
            r (resultado da op)
            )
        
        POWER: tem-se que chamar uma função que faz power
        as outras têm instrução propria
    
    Variables:

         ctx(x) = (rx, t)         r fresh
        -----------------------------------
        ctx |- x -> [r = load t, t*, rx , r]

        ctx: tabela símbolos de nomes de variables p/ pares (tipo,nome_llvm)
        t = tipo de x
        t* = type(t)*
        rx = 
        
        load - carregar valor
        em mem. p/ registo

    Let:

        ctx |- e1 -> (c1,v1)       insert x (t,r) ctx |- e2 -> (c2,v2)      r fresh
        -----------------------------------------------------------------------------
        ctx |- let x : t = e1 in e2 -> (
            [c1; r: alloca t; store t v; t*r; c2],
            v2
        )

    Function call:

        ctx |- e1 -> (c1,v1)...... ctx |- en -> (cn,vn)        r fresh
        ---------------------------------------------------------------
        ctx |- f(e1...en) -> (
            [c1;...cn; r = call u vf [t1 v1, tn vn]]
        )

        u = tipo de retorno
        vf = nome da funcao

    Conditional:



        |- if e1 then e2 else e3


    condGen:

        ctx,l,tt,ff |- e -> c,l

        Bool Literals:

            ctx l,ff,ll |- true: br label %tt
            ctx l,ff,ll |- false: br label %ff

        &&: (OR é parecido)

                                                        tt' fresh
        ctx,l,tt',ff |- e1,l1  ctx,tt',tt,ff |- e2 -> c2,l2    |
        --------------------------------------------------------
            ctx l,tt,ff |- e1 && e2 -> (
                [c1;tt',c2], l2
            )

        NOT:
            - simplesmente troca a ordem das etiquetas

        BinOp comparable:
                                                                    r fresh
            ctx,l |- e1 -> (c1,v2,l1)   ctx,l1 |- e2 -> (c2,v2,l2)      |
            --------------------------------------------------------------
            ctx,l,tt,ff |- e1 == e2 -> (
                [c1;c2; r= icmp eq tipo v1 v2
                    : br i1 r, %tt, %ff],
                l2a
            )

            TODOs:
                - call?
                - if?
                - neg?

            catch call - todos os outros casos

                ctx,l |- e -> (c,v,t,l')
                --------------------------
                ctx,l,tt,ff |- e -> (
                    [c,br i1 v, label %tt, label %ff],
                    l'
                )