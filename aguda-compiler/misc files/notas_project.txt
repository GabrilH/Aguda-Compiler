Lexer e Parser - usar Ply no python
Syntax - usar ABC (abstract base classes) no python, na main faz-se pattern matching tipo haskell

# trabalho 2
gerar arvore sintatica em memoria
imprimir a AST
fazer script de python para correr todos os tests
Regras para transformar na AST:
    -5 -> 0 - 5
    if x then x -> if x then x else unit

# trabalho 3
2 passagens pela AST -> 1º colecionar tipos dos ids sem verificar (com identificadores o stor não sabe, mas funções dá)
                        apenas meter as promessas das funções (even : Int -> Bool    odd : Int -> Bool)
                        2º verificar tipos
    (para reconhecer funções mutuamente recursivas)

- Algorithmic type checking:

    type ctx = Map String Type (basicamente a symbol table)

    typeof :: Ctx -> Exp -> Type
    typeof ctx (Var x) = ctx!x (get ao ctx o valor da key x)
    typeof _ (BoolLit _) = Bool
    typeof _ (NatLit _) = Nat
    typeof ctx (Succ e)
        | typeof ctx e == Nat = Nat
    typeof ctx (Eq e1 e2) =
        let t1 = typeof ctx e1
            t2 = typeof ctx e2
        in  if t1 == t2 && comparable t1 then Bool
            else error "== with ops of diff types"
    typeof ctx (Call f es)
        let (Fun ts u) = ctx!f
        if map(typeof ctx) es == t3
        then u else error "tipos dos argumentos"    
        
    TYPES = Nat | Unit | Bool | Fun...
    
    comparable : Type -> Bool
    comparable (Fun...) = False
    comparable _ = True

    Não é possivel meter print e length em sigma0 por terem varios
    tipos diferentes. Têm que se tratadas de forma especial

    Se declarar um variavel de "print"? Deve dar erro na altura da declaração
    Dizer que print/length são nomes reservados na "tabela de simbolos"

    Mínimo, ao primeiro erro rebenta:
    checkAgainst : Ctx -> Exp -> Type -> ()
    checkAgainst ctx e t | typeof ctx e == t = ()
                         | otherwise $ error "Expected ''++ stm t ++ "found" ++ typeof ctx e   

    Mensagens erro mais simpaticas, vai acumulando:
    checkAgainst ctx (cond e1 e2 e3) t2 =
        let _ = checkAgainst ctx e1 BoolType
        let _ = checkAgainst ctx e2 t2
        let _ = checkAgainst ctx e3 t3
        int2?

    Ter cuidado com wildcards, podem ser dois passados assim, mas caso fossem (x,x) não dá
    let f(_,_) : (Int, Bool) -> String = ...
    E os wildcards só podem ser usados nos parâmetros, não se pode tipo:
    let _ + 3

# trabalho 4 ?

    Registos de ativacao:

        utilização de registos:
            - plano A - tudo em registos (infelizmente muito poucos)
            - plano B - os que nao cabem, vao para memória (pilha)
            