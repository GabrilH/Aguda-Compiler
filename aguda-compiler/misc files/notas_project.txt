Lexer e Parser - usar Ply no python
Syntax - usar ABC (abstract base classes) no python, na main faz-se pattern matching tipo haskell

# trabalho 2
gerar arvore sintatica em memoria
imprimir a AST
fazer script de python para correr todos os tests
Regras para transformar na AST:
    -5 -> 0 - 5
    if x then x -> if x then x else unit

# trabalho 3
2 passagens pela AST -> 1º colecionar tipos dos ids sem verificar (com identificadores o stor não sabe, mas funções dá)
                        apenas meter as promessas das funções (even : Int -> Bool    odd : Int -> Bool)
                        2º verificar tipos
    (para reconhecer funções mutuamente recursivas)

- Algorithmic type checking:

    type ctx = Map String Type (basicamente a symbol table)

    typeof :: Ctx -> Exp -> Type
    typeof ctx (Var x) = ctx!x (get ao ctx o valor da key x)
    typeof _ (BoolLit _) = Bool
    typeof _ (NatLit _) = Nat
    typeof ctx (Succ e)
        | typeof ctx e == Nat = Nat
    typeof ctx (Eq e1 e2) =
        let t1 = typeof ctx e1
            t2 = typeof ctx e2
        in  if t1 == t2 && comparable t1 then Bool
            else error "== with ops of diff types"
    typeof ctx (Call f es)
        let (Fun ts u) = ctx!f
        if map(typeof ctx) es == t3
        then u else error "tipos dos argumentos"    
        
    TYPES = Nat | Unit | Bool | Fun...
    
    comparable : Type -> Bool
    comparable (Fun...) = False
    comparable _ = True

    Não é possivel meter print e length em sigma0 por terem varios
    tipos diferentes. Têm que se tratadas de forma especial

    Se declarar um variavel de "print"? Deve dar erro na altura da declaração
    Dizer que print/length são nomes reservados na "tabela de simbolos"

    Mínimo, ao primeiro erro rebenta:
    checkAgainst : Ctx -> Exp -> Type -> ()
    checkAgainst ctx e t | typeof ctx e == t = ()
                         | otherwise $ error "Expected ''++ stm t ++ "found" ++ typeof ctx e   

    Mensagens erro mais simpaticas, vai acumulando:
    checkAgainst ctx (cond e1 e2 e3) t2 =
        let _ = checkAgainst ctx e1 BoolType
        let _ = checkAgainst ctx e2 t2
        let _ = checkAgainst ctx e3 t3
        int2?

    Ter cuidado com wildcards, podem ser dois passados assim, mas caso fossem (x,x) não dá
    let f(_,_) : (Int, Bool) -> String = ...
    E os wildcards só podem ser usados nos parâmetros, não se pode tipo:
    let _ + 3

# trabalho 4 ?

    Registos de ativacao:

        utilização de registos:
            - plano A - tudo em registos (infelizmente muito poucos)
            - plano B - os que nao cabem, vao para memória (pilha)
            
        Variaveis que vivem no registo de ativação:
            - vars passadas por referencia
            - vars acedidas em funções chamadas por uma dada função

# codegen

- quando se chama função, tem-se que mandar o tipo dos parâmetros
    - R:

- expressões boolean, mal se saiba o resultado da exp, dar return (n continuar a ler) curto circuito
    - R: 

- a função main será um caso específico?
    - R:

- é suposto ir fazendo logs ou lançar logo exception?
    - R:

- qual é o tipo LLVM do Unit?
    - R: qualquer

------------

DUAS PASSAGENS PELA AST
    - 1ª colecionar tipos de funções
    - 2ª gerar codigo

- tradução de expressôes:
    - condGen :
    - expGen  : Exp (AST) -> (LLVMCode, Value)
    -> condGen e expGen mutuamente recursivas (tipo checkAgainst e typeof)


    - Value ::= Register | Literal (Int | Bool | Unit)
    - LLVMCode ::= Lista de instruções

        {exp}  {codigo, valor, tipo, label}
    ctx |- e -> (c,v,t,l)
        {in}    {out}

    Literals expGen:
    
        |- n -> ([],n)
        
        |- b -> ([],b)

        |- unit -> ([],1)

    Sequence:

        |- e1 -> (c1,r1)    |- e2 -> (c2,r2)
        -----------------------------------
        |- e1;e2 -> ([c1,c2], r2)

    BinOp aritméticas:
                                            r fresh
                                            --------
        |- e1 -> (c1,v1)    |- e2 -> (c2,v2)    |
        ------------------------------------------
        |- e1 + e2 -> (
            [c1;c2; r = add i32, v1,v2],
            r (resultado da op)
            )
        
        POWER: tem-se que chamar uma função que faz power
        as outras têm instrução propria
    
    Variables:

         ctx(x) = (rx, t)         r fresh
        -----------------------------------
        ctx |- x -> [r = load t, t*, rx , r]

        ctx: tabela símbolos de nomes de variables p/ pares (tipo,nome_llvm)
        t = tipo de x
        t* = type(t)*
        rx = 
        
        load - carregar valor
        em mem. p/ registo

    Let:

        ctx |- e1 -> (c1,v1)       insert x (t,r) ctx |- e2 -> (c2,v2)      r fresh
        -----------------------------------------------------------------------------
        ctx |- let x : t = e1 in e2 -> (
            [c1; r: alloca t; store t v; t*r; c2],
            v2
        )

    Function call:

        ctx |- e1 -> (c1,v1)...... ctx |- en -> (cn,vn)        r fresh
        ---------------------------------------------------------------
        ctx |- f(e1...en) -> (
            [c1;...cn; r = call u vf [t1 v1, tn vn]]
        )

        u = tipo de retorno
        vf = nome da funcao

    Conditional:



        |- if e1 then e2 else e3


    condGen:

        ctx,l,tt,ff |- e -> c,l

        Bool Literals:

            ctx l,ff,ll |- true: br label %tt
            ctx l,ff,ll |- false: br label %ff

        &&: (OR é parecido)

                                                        tt' fresh
        ctx,l,tt',ff |- e1,l1  ctx,tt',tt,ff |- e2 -> c2,l2    |
        --------------------------------------------------------
            ctx l,tt,ff |- e1 && e2 -> (
                [c1;tt',c2], l2
            )

        NOT:
            - simplesmente troca a ordem das etiquetas

        BinOp comparable:
                                                                    r fresh
            ctx,l |- e1 -> (c1,v2,l1)   ctx,l1 |- e2 -> (c2,v2,l2)      |
            --------------------------------------------------------------
            ctx,l,tt,ff |- e1 == e2 -> (
                [c1;c2; r= icmp eq tipo v1 v2
                    : br i1 r, %tt, %ff],
                l2a
            )

            TODOs:
                - call?
                - if?
                - neg?

            catch call - todos os outros casos

                ctx,l |- e -> (c,v,t,l')
                --------------------------
                ctx,l,tt,ff |- e -> (
                    [c,br i1 v, label %tt, label %ff],
                    l'
                )