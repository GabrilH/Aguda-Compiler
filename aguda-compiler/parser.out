Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> declarations
Rule 2     declarations -> declaration declarations_tail
Rule 3     declarations_tail -> declaration declarations_tail
Rule 4     declarations_tail -> empty
Rule 5     declaration -> variable_declaration
Rule 6     declaration -> function_declaration
Rule 7     function_declaration -> LET ID LPAREN parameters RPAREN COLON function_type ASSIGN exp
Rule 8     parameters -> variable parameters_tail
Rule 9     parameters_tail -> COMMA variable parameters_tail
Rule 10    parameters_tail -> empty
Rule 11    type -> base_type
Rule 12    type -> array_type
Rule 13    base_type -> INT_TYPE
Rule 14    base_type -> STRING_TYPE
Rule 15    base_type -> UNIT_TYPE
Rule 16    base_type -> BOOL_TYPE
Rule 17    array_type -> type LBRACKET RBRACKET
Rule 18    function_type -> type ARROW type
Rule 19    function_type -> LPAREN type function_type_tail RPAREN ARROW type
Rule 20    function_type_tail -> COMMA type function_type_tail
Rule 21    function_type_tail -> empty
Rule 22    exp -> variable
Rule 23    exp -> literal
Rule 24    exp -> binary_exp
Rule 25    exp -> unary_exp
Rule 26    exp -> function_call
Rule 27    exp -> assignment
Rule 28    exp -> variable_declaration
Rule 29    exp -> if_then_else
Rule 30    exp -> if_then
Rule 31    exp -> while_loop
Rule 32    exp -> array_creation
Rule 33    exp -> array_access
Rule 34    exp -> group
Rule 35    variable -> ID
Rule 36    variable -> UNDERSCORE
Rule 37    literal -> INT_LITERAL
Rule 38    literal -> TRUE
Rule 39    literal -> FALSE
Rule 40    literal -> NULL
Rule 41    literal -> UNIT
Rule 42    literal -> STRING_LITERAL
Rule 43    binary_exp -> exp PLUS exp
Rule 44    binary_exp -> exp MINUS exp
Rule 45    binary_exp -> exp TIMES exp
Rule 46    binary_exp -> exp DIVIDE exp
Rule 47    binary_exp -> exp MOD exp
Rule 48    binary_exp -> exp POWER exp
Rule 49    binary_exp -> exp EQUALS exp
Rule 50    binary_exp -> exp NOT_EQUALS exp
Rule 51    binary_exp -> exp LESS exp
Rule 52    binary_exp -> exp LESS_EQUAL exp
Rule 53    binary_exp -> exp GREATER exp
Rule 54    binary_exp -> exp GREATER_EQUAL exp
Rule 55    binary_exp -> exp AND exp
Rule 56    binary_exp -> exp OR exp
Rule 57    binary_exp -> exp SEMICOLON exp
Rule 58    unary_exp -> MINUS exp
Rule 59    unary_exp -> NOT exp
Rule 60    function_call -> variable LPAREN arguments RPAREN
Rule 61    arguments -> exp arguments_tail
Rule 62    arguments_tail -> COMMA exp arguments_tail
Rule 63    arguments_tail -> empty
Rule 64    assignment -> SET lhs ASSIGN exp
Rule 65    lhs -> variable
Rule 66    lhs -> array_access
Rule 67    array_access -> lhs LBRACKET exp RBRACKET
Rule 68    variable_declaration -> LET variable COLON type ASSIGN exp
Rule 69    if_then_else -> IF exp THEN exp ELSE exp
Rule 70    if_then -> IF exp THEN exp
Rule 71    while_loop -> WHILE exp DO exp
Rule 72    array_creation -> NEW type LBRACKET exp BAR exp RBRACKET
Rule 73    group -> LPAREN exp RPAREN
Rule 74    empty -> <empty>

Terminals, with rules where they appear

AND                  : 55
ARROW                : 18 19
ASSIGN               : 7 64 68
BAR                  : 72
BOOL_TYPE            : 16
COLON                : 7 68
COMMA                : 9 20 62
DIVIDE               : 46
DO                   : 71
ELSE                 : 69
EQUALS               : 49
FALSE                : 39
GREATER              : 53
GREATER_EQUAL        : 54
ID                   : 7 35
IF                   : 69 70
INT_LITERAL          : 37
INT_TYPE             : 13
LBRACKET             : 17 67 72
LESS                 : 51
LESS_EQUAL           : 52
LET                  : 7 68
LPAREN               : 7 19 60 73
MINUS                : 44 58
MOD                  : 47
NEW                  : 72
NOT                  : 59
NOT_EQUALS           : 50
NULL                 : 40
OR                   : 56
PLUS                 : 43
POWER                : 48
RBRACKET             : 17 67 72
RPAREN               : 7 19 60 73
SEMICOLON            : 57
SET                  : 64
STRING_LITERAL       : 42
STRING_TYPE          : 14
THEN                 : 69 70
TIMES                : 45
TRUE                 : 38
UNDERSCORE           : 36
UNIT                 : 41
UNIT_TYPE            : 15
WHILE                : 71
error                : 

Nonterminals, with rules where they appear

arguments            : 60
arguments_tail       : 61 62
array_access         : 33 66
array_creation       : 32
array_type           : 12
assignment           : 27
base_type            : 11
binary_exp           : 24
declaration          : 2 3
declarations         : 1
declarations_tail    : 2 3
empty                : 4 10 21 63
exp                  : 7 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 59 61 62 64 67 68 69 69 69 70 70 71 71 72 72 73
function_call        : 26
function_declaration : 6
function_type        : 7
function_type_tail   : 19 20
group                : 34
if_then              : 30
if_then_else         : 29
lhs                  : 64 67
literal              : 23
parameters           : 7
parameters_tail      : 8 9
program              : 0
type                 : 17 18 18 19 19 20 68 72
unary_exp            : 25
variable             : 8 9 22 60 65 68
variable_declaration : 5 28
while_loop           : 31

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declarations
    (2) declarations -> . declaration declarations_tail
    (5) declaration -> . variable_declaration
    (6) declaration -> . function_declaration
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (7) function_declaration -> . LET ID LPAREN parameters RPAREN COLON function_type ASSIGN exp

    LET             shift and go to state 6

    program                        shift and go to state 1
    declarations                   shift and go to state 2
    declaration                    shift and go to state 3
    variable_declaration           shift and go to state 4
    function_declaration           shift and go to state 5

state 1

    (0) S' -> program .



state 2

    (1) program -> declarations .

    $end            reduce using rule 1 (program -> declarations .)


state 3

    (2) declarations -> declaration . declarations_tail
    (3) declarations_tail -> . declaration declarations_tail
    (4) declarations_tail -> . empty
    (5) declaration -> . variable_declaration
    (6) declaration -> . function_declaration
    (74) empty -> .
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (7) function_declaration -> . LET ID LPAREN parameters RPAREN COLON function_type ASSIGN exp

    $end            reduce using rule 74 (empty -> .)
    LET             shift and go to state 6

    declaration                    shift and go to state 7
    declarations_tail              shift and go to state 8
    empty                          shift and go to state 9
    variable_declaration           shift and go to state 4
    function_declaration           shift and go to state 5

state 4

    (5) declaration -> variable_declaration .

    LET             reduce using rule 5 (declaration -> variable_declaration .)
    $end            reduce using rule 5 (declaration -> variable_declaration .)


state 5

    (6) declaration -> function_declaration .

    LET             reduce using rule 6 (declaration -> function_declaration .)
    $end            reduce using rule 6 (declaration -> function_declaration .)


state 6

    (68) variable_declaration -> LET . variable COLON type ASSIGN exp
    (7) function_declaration -> LET . ID LPAREN parameters RPAREN COLON function_type ASSIGN exp
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE

    ID              shift and go to state 11
    UNDERSCORE      shift and go to state 12

    variable                       shift and go to state 10

state 7

    (3) declarations_tail -> declaration . declarations_tail
    (3) declarations_tail -> . declaration declarations_tail
    (4) declarations_tail -> . empty
    (5) declaration -> . variable_declaration
    (6) declaration -> . function_declaration
    (74) empty -> .
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (7) function_declaration -> . LET ID LPAREN parameters RPAREN COLON function_type ASSIGN exp

    $end            reduce using rule 74 (empty -> .)
    LET             shift and go to state 6

    declaration                    shift and go to state 7
    declarations_tail              shift and go to state 13
    empty                          shift and go to state 9
    variable_declaration           shift and go to state 4
    function_declaration           shift and go to state 5

state 8

    (2) declarations -> declaration declarations_tail .

    $end            reduce using rule 2 (declarations -> declaration declarations_tail .)


state 9

    (4) declarations_tail -> empty .

    $end            reduce using rule 4 (declarations_tail -> empty .)


state 10

    (68) variable_declaration -> LET variable . COLON type ASSIGN exp

    COLON           shift and go to state 14


state 11

    (7) function_declaration -> LET ID . LPAREN parameters RPAREN COLON function_type ASSIGN exp
    (35) variable -> ID .

    LPAREN          shift and go to state 15
    COLON           reduce using rule 35 (variable -> ID .)


state 12

    (36) variable -> UNDERSCORE .

    COLON           reduce using rule 36 (variable -> UNDERSCORE .)
    COMMA           reduce using rule 36 (variable -> UNDERSCORE .)
    RPAREN          reduce using rule 36 (variable -> UNDERSCORE .)
    LPAREN          reduce using rule 36 (variable -> UNDERSCORE .)
    PLUS            reduce using rule 36 (variable -> UNDERSCORE .)
    MINUS           reduce using rule 36 (variable -> UNDERSCORE .)
    TIMES           reduce using rule 36 (variable -> UNDERSCORE .)
    DIVIDE          reduce using rule 36 (variable -> UNDERSCORE .)
    MOD             reduce using rule 36 (variable -> UNDERSCORE .)
    POWER           reduce using rule 36 (variable -> UNDERSCORE .)
    EQUALS          reduce using rule 36 (variable -> UNDERSCORE .)
    NOT_EQUALS      reduce using rule 36 (variable -> UNDERSCORE .)
    LESS            reduce using rule 36 (variable -> UNDERSCORE .)
    LESS_EQUAL      reduce using rule 36 (variable -> UNDERSCORE .)
    GREATER         reduce using rule 36 (variable -> UNDERSCORE .)
    GREATER_EQUAL   reduce using rule 36 (variable -> UNDERSCORE .)
    AND             reduce using rule 36 (variable -> UNDERSCORE .)
    OR              reduce using rule 36 (variable -> UNDERSCORE .)
    SEMICOLON       reduce using rule 36 (variable -> UNDERSCORE .)
    LET             reduce using rule 36 (variable -> UNDERSCORE .)
    $end            reduce using rule 36 (variable -> UNDERSCORE .)
    THEN            reduce using rule 36 (variable -> UNDERSCORE .)
    DO              reduce using rule 36 (variable -> UNDERSCORE .)
    RBRACKET        reduce using rule 36 (variable -> UNDERSCORE .)
    ELSE            reduce using rule 36 (variable -> UNDERSCORE .)
    BAR             reduce using rule 36 (variable -> UNDERSCORE .)
    LBRACKET        reduce using rule 36 (variable -> UNDERSCORE .)
    ASSIGN          reduce using rule 36 (variable -> UNDERSCORE .)


state 13

    (3) declarations_tail -> declaration declarations_tail .

    $end            reduce using rule 3 (declarations_tail -> declaration declarations_tail .)


state 14

    (68) variable_declaration -> LET variable COLON . type ASSIGN exp
    (11) type -> . base_type
    (12) type -> . array_type
    (13) base_type -> . INT_TYPE
    (14) base_type -> . STRING_TYPE
    (15) base_type -> . UNIT_TYPE
    (16) base_type -> . BOOL_TYPE
    (17) array_type -> . type LBRACKET RBRACKET

    INT_TYPE        shift and go to state 19
    STRING_TYPE     shift and go to state 20
    UNIT_TYPE       shift and go to state 21
    BOOL_TYPE       shift and go to state 22

    type                           shift and go to state 16
    base_type                      shift and go to state 17
    array_type                     shift and go to state 18

state 15

    (7) function_declaration -> LET ID LPAREN . parameters RPAREN COLON function_type ASSIGN exp
    (8) parameters -> . variable parameters_tail
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12

    parameters                     shift and go to state 24
    variable                       shift and go to state 25

state 16

    (68) variable_declaration -> LET variable COLON type . ASSIGN exp
    (17) array_type -> type . LBRACKET RBRACKET

    ASSIGN          shift and go to state 26
    LBRACKET        shift and go to state 27


state 17

    (11) type -> base_type .

    ASSIGN          reduce using rule 11 (type -> base_type .)
    LBRACKET        reduce using rule 11 (type -> base_type .)
    ARROW           reduce using rule 11 (type -> base_type .)
    COMMA           reduce using rule 11 (type -> base_type .)
    RPAREN          reduce using rule 11 (type -> base_type .)


state 18

    (12) type -> array_type .

    ASSIGN          reduce using rule 12 (type -> array_type .)
    LBRACKET        reduce using rule 12 (type -> array_type .)
    ARROW           reduce using rule 12 (type -> array_type .)
    COMMA           reduce using rule 12 (type -> array_type .)
    RPAREN          reduce using rule 12 (type -> array_type .)


state 19

    (13) base_type -> INT_TYPE .

    ASSIGN          reduce using rule 13 (base_type -> INT_TYPE .)
    LBRACKET        reduce using rule 13 (base_type -> INT_TYPE .)
    ARROW           reduce using rule 13 (base_type -> INT_TYPE .)
    COMMA           reduce using rule 13 (base_type -> INT_TYPE .)
    RPAREN          reduce using rule 13 (base_type -> INT_TYPE .)


state 20

    (14) base_type -> STRING_TYPE .

    ASSIGN          reduce using rule 14 (base_type -> STRING_TYPE .)
    LBRACKET        reduce using rule 14 (base_type -> STRING_TYPE .)
    ARROW           reduce using rule 14 (base_type -> STRING_TYPE .)
    COMMA           reduce using rule 14 (base_type -> STRING_TYPE .)
    RPAREN          reduce using rule 14 (base_type -> STRING_TYPE .)


state 21

    (15) base_type -> UNIT_TYPE .

    ASSIGN          reduce using rule 15 (base_type -> UNIT_TYPE .)
    LBRACKET        reduce using rule 15 (base_type -> UNIT_TYPE .)
    ARROW           reduce using rule 15 (base_type -> UNIT_TYPE .)
    COMMA           reduce using rule 15 (base_type -> UNIT_TYPE .)
    RPAREN          reduce using rule 15 (base_type -> UNIT_TYPE .)


state 22

    (16) base_type -> BOOL_TYPE .

    ASSIGN          reduce using rule 16 (base_type -> BOOL_TYPE .)
    LBRACKET        reduce using rule 16 (base_type -> BOOL_TYPE .)
    ARROW           reduce using rule 16 (base_type -> BOOL_TYPE .)
    COMMA           reduce using rule 16 (base_type -> BOOL_TYPE .)
    RPAREN          reduce using rule 16 (base_type -> BOOL_TYPE .)


state 23

    (35) variable -> ID .

    COMMA           reduce using rule 35 (variable -> ID .)
    RPAREN          reduce using rule 35 (variable -> ID .)
    LPAREN          reduce using rule 35 (variable -> ID .)
    PLUS            reduce using rule 35 (variable -> ID .)
    MINUS           reduce using rule 35 (variable -> ID .)
    TIMES           reduce using rule 35 (variable -> ID .)
    DIVIDE          reduce using rule 35 (variable -> ID .)
    MOD             reduce using rule 35 (variable -> ID .)
    POWER           reduce using rule 35 (variable -> ID .)
    EQUALS          reduce using rule 35 (variable -> ID .)
    NOT_EQUALS      reduce using rule 35 (variable -> ID .)
    LESS            reduce using rule 35 (variable -> ID .)
    LESS_EQUAL      reduce using rule 35 (variable -> ID .)
    GREATER         reduce using rule 35 (variable -> ID .)
    GREATER_EQUAL   reduce using rule 35 (variable -> ID .)
    AND             reduce using rule 35 (variable -> ID .)
    OR              reduce using rule 35 (variable -> ID .)
    SEMICOLON       reduce using rule 35 (variable -> ID .)
    LET             reduce using rule 35 (variable -> ID .)
    $end            reduce using rule 35 (variable -> ID .)
    THEN            reduce using rule 35 (variable -> ID .)
    DO              reduce using rule 35 (variable -> ID .)
    RBRACKET        reduce using rule 35 (variable -> ID .)
    ELSE            reduce using rule 35 (variable -> ID .)
    BAR             reduce using rule 35 (variable -> ID .)
    LBRACKET        reduce using rule 35 (variable -> ID .)
    COLON           reduce using rule 35 (variable -> ID .)
    ASSIGN          reduce using rule 35 (variable -> ID .)


state 24

    (7) function_declaration -> LET ID LPAREN parameters . RPAREN COLON function_type ASSIGN exp

    RPAREN          shift and go to state 28


state 25

    (8) parameters -> variable . parameters_tail
    (9) parameters_tail -> . COMMA variable parameters_tail
    (10) parameters_tail -> . empty
    (74) empty -> .

    COMMA           shift and go to state 30
    RPAREN          reduce using rule 74 (empty -> .)

    parameters_tail                shift and go to state 29
    empty                          shift and go to state 31

state 26

    (68) variable_declaration -> LET variable COLON type ASSIGN . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs ASSIGN exp
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 32
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    variable                       shift and go to state 33
    exp                            shift and go to state 34
    literal                        shift and go to state 35
    binary_exp                     shift and go to state 36
    unary_exp                      shift and go to state 37
    function_call                  shift and go to state 38
    assignment                     shift and go to state 39
    variable_declaration           shift and go to state 40
    if_then_else                   shift and go to state 41
    if_then                        shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 27

    (17) array_type -> type LBRACKET . RBRACKET

    RBRACKET        shift and go to state 61


state 28

    (7) function_declaration -> LET ID LPAREN parameters RPAREN . COLON function_type ASSIGN exp

    COLON           shift and go to state 62


state 29

    (8) parameters -> variable parameters_tail .

    RPAREN          reduce using rule 8 (parameters -> variable parameters_tail .)


state 30

    (9) parameters_tail -> COMMA . variable parameters_tail
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12

    variable                       shift and go to state 63

state 31

    (10) parameters_tail -> empty .

    RPAREN          reduce using rule 10 (parameters_tail -> empty .)


state 32

    (68) variable_declaration -> LET . variable COLON type ASSIGN exp
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12

    variable                       shift and go to state 10

state 33

    (22) exp -> variable .
    (60) function_call -> variable . LPAREN arguments RPAREN
    (65) lhs -> variable .

    PLUS            reduce using rule 22 (exp -> variable .)
    MINUS           reduce using rule 22 (exp -> variable .)
    TIMES           reduce using rule 22 (exp -> variable .)
    DIVIDE          reduce using rule 22 (exp -> variable .)
    MOD             reduce using rule 22 (exp -> variable .)
    POWER           reduce using rule 22 (exp -> variable .)
    EQUALS          reduce using rule 22 (exp -> variable .)
    NOT_EQUALS      reduce using rule 22 (exp -> variable .)
    LESS            reduce using rule 22 (exp -> variable .)
    LESS_EQUAL      reduce using rule 22 (exp -> variable .)
    GREATER         reduce using rule 22 (exp -> variable .)
    GREATER_EQUAL   reduce using rule 22 (exp -> variable .)
    AND             reduce using rule 22 (exp -> variable .)
    OR              reduce using rule 22 (exp -> variable .)
    SEMICOLON       reduce using rule 22 (exp -> variable .)
    LET             reduce using rule 22 (exp -> variable .)
    $end            reduce using rule 22 (exp -> variable .)
    RPAREN          reduce using rule 22 (exp -> variable .)
    THEN            reduce using rule 22 (exp -> variable .)
    DO              reduce using rule 22 (exp -> variable .)
    COMMA           reduce using rule 22 (exp -> variable .)
    RBRACKET        reduce using rule 22 (exp -> variable .)
    ELSE            reduce using rule 22 (exp -> variable .)
    BAR             reduce using rule 22 (exp -> variable .)
    LPAREN          shift and go to state 64
    LBRACKET        reduce using rule 65 (lhs -> variable .)


state 34

    (68) variable_declaration -> LET variable COLON type ASSIGN exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    LET             reduce using rule 68 (variable_declaration -> LET variable COLON type ASSIGN exp .)
    $end            reduce using rule 68 (variable_declaration -> LET variable COLON type ASSIGN exp .)
    SEMICOLON       reduce using rule 68 (variable_declaration -> LET variable COLON type ASSIGN exp .)
    RPAREN          reduce using rule 68 (variable_declaration -> LET variable COLON type ASSIGN exp .)
    THEN            reduce using rule 68 (variable_declaration -> LET variable COLON type ASSIGN exp .)
    DO              reduce using rule 68 (variable_declaration -> LET variable COLON type ASSIGN exp .)
    COMMA           reduce using rule 68 (variable_declaration -> LET variable COLON type ASSIGN exp .)
    RBRACKET        reduce using rule 68 (variable_declaration -> LET variable COLON type ASSIGN exp .)
    ELSE            reduce using rule 68 (variable_declaration -> LET variable COLON type ASSIGN exp .)
    BAR             reduce using rule 68 (variable_declaration -> LET variable COLON type ASSIGN exp .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POWER           shift and go to state 70
    EQUALS          shift and go to state 71
    NOT_EQUALS      shift and go to state 72
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78

  ! PLUS            [ reduce using rule 68 (variable_declaration -> LET variable COLON type ASSIGN exp .) ]
  ! MINUS           [ reduce using rule 68 (variable_declaration -> LET variable COLON type ASSIGN exp .) ]
  ! TIMES           [ reduce using rule 68 (variable_declaration -> LET variable COLON type ASSIGN exp .) ]
  ! DIVIDE          [ reduce using rule 68 (variable_declaration -> LET variable COLON type ASSIGN exp .) ]
  ! MOD             [ reduce using rule 68 (variable_declaration -> LET variable COLON type ASSIGN exp .) ]
  ! POWER           [ reduce using rule 68 (variable_declaration -> LET variable COLON type ASSIGN exp .) ]
  ! EQUALS          [ reduce using rule 68 (variable_declaration -> LET variable COLON type ASSIGN exp .) ]
  ! NOT_EQUALS      [ reduce using rule 68 (variable_declaration -> LET variable COLON type ASSIGN exp .) ]
  ! LESS            [ reduce using rule 68 (variable_declaration -> LET variable COLON type ASSIGN exp .) ]
  ! LESS_EQUAL      [ reduce using rule 68 (variable_declaration -> LET variable COLON type ASSIGN exp .) ]
  ! GREATER         [ reduce using rule 68 (variable_declaration -> LET variable COLON type ASSIGN exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 68 (variable_declaration -> LET variable COLON type ASSIGN exp .) ]
  ! AND             [ reduce using rule 68 (variable_declaration -> LET variable COLON type ASSIGN exp .) ]
  ! OR              [ reduce using rule 68 (variable_declaration -> LET variable COLON type ASSIGN exp .) ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 35

    (23) exp -> literal .

    PLUS            reduce using rule 23 (exp -> literal .)
    MINUS           reduce using rule 23 (exp -> literal .)
    TIMES           reduce using rule 23 (exp -> literal .)
    DIVIDE          reduce using rule 23 (exp -> literal .)
    MOD             reduce using rule 23 (exp -> literal .)
    POWER           reduce using rule 23 (exp -> literal .)
    EQUALS          reduce using rule 23 (exp -> literal .)
    NOT_EQUALS      reduce using rule 23 (exp -> literal .)
    LESS            reduce using rule 23 (exp -> literal .)
    LESS_EQUAL      reduce using rule 23 (exp -> literal .)
    GREATER         reduce using rule 23 (exp -> literal .)
    GREATER_EQUAL   reduce using rule 23 (exp -> literal .)
    AND             reduce using rule 23 (exp -> literal .)
    OR              reduce using rule 23 (exp -> literal .)
    SEMICOLON       reduce using rule 23 (exp -> literal .)
    LET             reduce using rule 23 (exp -> literal .)
    $end            reduce using rule 23 (exp -> literal .)
    RPAREN          reduce using rule 23 (exp -> literal .)
    THEN            reduce using rule 23 (exp -> literal .)
    DO              reduce using rule 23 (exp -> literal .)
    COMMA           reduce using rule 23 (exp -> literal .)
    RBRACKET        reduce using rule 23 (exp -> literal .)
    ELSE            reduce using rule 23 (exp -> literal .)
    BAR             reduce using rule 23 (exp -> literal .)


state 36

    (24) exp -> binary_exp .

    PLUS            reduce using rule 24 (exp -> binary_exp .)
    MINUS           reduce using rule 24 (exp -> binary_exp .)
    TIMES           reduce using rule 24 (exp -> binary_exp .)
    DIVIDE          reduce using rule 24 (exp -> binary_exp .)
    MOD             reduce using rule 24 (exp -> binary_exp .)
    POWER           reduce using rule 24 (exp -> binary_exp .)
    EQUALS          reduce using rule 24 (exp -> binary_exp .)
    NOT_EQUALS      reduce using rule 24 (exp -> binary_exp .)
    LESS            reduce using rule 24 (exp -> binary_exp .)
    LESS_EQUAL      reduce using rule 24 (exp -> binary_exp .)
    GREATER         reduce using rule 24 (exp -> binary_exp .)
    GREATER_EQUAL   reduce using rule 24 (exp -> binary_exp .)
    AND             reduce using rule 24 (exp -> binary_exp .)
    OR              reduce using rule 24 (exp -> binary_exp .)
    SEMICOLON       reduce using rule 24 (exp -> binary_exp .)
    LET             reduce using rule 24 (exp -> binary_exp .)
    $end            reduce using rule 24 (exp -> binary_exp .)
    RPAREN          reduce using rule 24 (exp -> binary_exp .)
    THEN            reduce using rule 24 (exp -> binary_exp .)
    DO              reduce using rule 24 (exp -> binary_exp .)
    COMMA           reduce using rule 24 (exp -> binary_exp .)
    RBRACKET        reduce using rule 24 (exp -> binary_exp .)
    ELSE            reduce using rule 24 (exp -> binary_exp .)
    BAR             reduce using rule 24 (exp -> binary_exp .)


state 37

    (25) exp -> unary_exp .

    PLUS            reduce using rule 25 (exp -> unary_exp .)
    MINUS           reduce using rule 25 (exp -> unary_exp .)
    TIMES           reduce using rule 25 (exp -> unary_exp .)
    DIVIDE          reduce using rule 25 (exp -> unary_exp .)
    MOD             reduce using rule 25 (exp -> unary_exp .)
    POWER           reduce using rule 25 (exp -> unary_exp .)
    EQUALS          reduce using rule 25 (exp -> unary_exp .)
    NOT_EQUALS      reduce using rule 25 (exp -> unary_exp .)
    LESS            reduce using rule 25 (exp -> unary_exp .)
    LESS_EQUAL      reduce using rule 25 (exp -> unary_exp .)
    GREATER         reduce using rule 25 (exp -> unary_exp .)
    GREATER_EQUAL   reduce using rule 25 (exp -> unary_exp .)
    AND             reduce using rule 25 (exp -> unary_exp .)
    OR              reduce using rule 25 (exp -> unary_exp .)
    SEMICOLON       reduce using rule 25 (exp -> unary_exp .)
    LET             reduce using rule 25 (exp -> unary_exp .)
    $end            reduce using rule 25 (exp -> unary_exp .)
    RPAREN          reduce using rule 25 (exp -> unary_exp .)
    THEN            reduce using rule 25 (exp -> unary_exp .)
    DO              reduce using rule 25 (exp -> unary_exp .)
    COMMA           reduce using rule 25 (exp -> unary_exp .)
    RBRACKET        reduce using rule 25 (exp -> unary_exp .)
    ELSE            reduce using rule 25 (exp -> unary_exp .)
    BAR             reduce using rule 25 (exp -> unary_exp .)


state 38

    (26) exp -> function_call .

    PLUS            reduce using rule 26 (exp -> function_call .)
    MINUS           reduce using rule 26 (exp -> function_call .)
    TIMES           reduce using rule 26 (exp -> function_call .)
    DIVIDE          reduce using rule 26 (exp -> function_call .)
    MOD             reduce using rule 26 (exp -> function_call .)
    POWER           reduce using rule 26 (exp -> function_call .)
    EQUALS          reduce using rule 26 (exp -> function_call .)
    NOT_EQUALS      reduce using rule 26 (exp -> function_call .)
    LESS            reduce using rule 26 (exp -> function_call .)
    LESS_EQUAL      reduce using rule 26 (exp -> function_call .)
    GREATER         reduce using rule 26 (exp -> function_call .)
    GREATER_EQUAL   reduce using rule 26 (exp -> function_call .)
    AND             reduce using rule 26 (exp -> function_call .)
    OR              reduce using rule 26 (exp -> function_call .)
    SEMICOLON       reduce using rule 26 (exp -> function_call .)
    LET             reduce using rule 26 (exp -> function_call .)
    $end            reduce using rule 26 (exp -> function_call .)
    RPAREN          reduce using rule 26 (exp -> function_call .)
    THEN            reduce using rule 26 (exp -> function_call .)
    DO              reduce using rule 26 (exp -> function_call .)
    COMMA           reduce using rule 26 (exp -> function_call .)
    RBRACKET        reduce using rule 26 (exp -> function_call .)
    ELSE            reduce using rule 26 (exp -> function_call .)
    BAR             reduce using rule 26 (exp -> function_call .)


state 39

    (27) exp -> assignment .

    PLUS            reduce using rule 27 (exp -> assignment .)
    MINUS           reduce using rule 27 (exp -> assignment .)
    TIMES           reduce using rule 27 (exp -> assignment .)
    DIVIDE          reduce using rule 27 (exp -> assignment .)
    MOD             reduce using rule 27 (exp -> assignment .)
    POWER           reduce using rule 27 (exp -> assignment .)
    EQUALS          reduce using rule 27 (exp -> assignment .)
    NOT_EQUALS      reduce using rule 27 (exp -> assignment .)
    LESS            reduce using rule 27 (exp -> assignment .)
    LESS_EQUAL      reduce using rule 27 (exp -> assignment .)
    GREATER         reduce using rule 27 (exp -> assignment .)
    GREATER_EQUAL   reduce using rule 27 (exp -> assignment .)
    AND             reduce using rule 27 (exp -> assignment .)
    OR              reduce using rule 27 (exp -> assignment .)
    SEMICOLON       reduce using rule 27 (exp -> assignment .)
    LET             reduce using rule 27 (exp -> assignment .)
    $end            reduce using rule 27 (exp -> assignment .)
    RPAREN          reduce using rule 27 (exp -> assignment .)
    THEN            reduce using rule 27 (exp -> assignment .)
    DO              reduce using rule 27 (exp -> assignment .)
    COMMA           reduce using rule 27 (exp -> assignment .)
    RBRACKET        reduce using rule 27 (exp -> assignment .)
    ELSE            reduce using rule 27 (exp -> assignment .)
    BAR             reduce using rule 27 (exp -> assignment .)


state 40

    (28) exp -> variable_declaration .

    PLUS            reduce using rule 28 (exp -> variable_declaration .)
    MINUS           reduce using rule 28 (exp -> variable_declaration .)
    TIMES           reduce using rule 28 (exp -> variable_declaration .)
    DIVIDE          reduce using rule 28 (exp -> variable_declaration .)
    MOD             reduce using rule 28 (exp -> variable_declaration .)
    POWER           reduce using rule 28 (exp -> variable_declaration .)
    EQUALS          reduce using rule 28 (exp -> variable_declaration .)
    NOT_EQUALS      reduce using rule 28 (exp -> variable_declaration .)
    LESS            reduce using rule 28 (exp -> variable_declaration .)
    LESS_EQUAL      reduce using rule 28 (exp -> variable_declaration .)
    GREATER         reduce using rule 28 (exp -> variable_declaration .)
    GREATER_EQUAL   reduce using rule 28 (exp -> variable_declaration .)
    AND             reduce using rule 28 (exp -> variable_declaration .)
    OR              reduce using rule 28 (exp -> variable_declaration .)
    SEMICOLON       reduce using rule 28 (exp -> variable_declaration .)
    LET             reduce using rule 28 (exp -> variable_declaration .)
    $end            reduce using rule 28 (exp -> variable_declaration .)
    RPAREN          reduce using rule 28 (exp -> variable_declaration .)
    THEN            reduce using rule 28 (exp -> variable_declaration .)
    DO              reduce using rule 28 (exp -> variable_declaration .)
    COMMA           reduce using rule 28 (exp -> variable_declaration .)
    RBRACKET        reduce using rule 28 (exp -> variable_declaration .)
    ELSE            reduce using rule 28 (exp -> variable_declaration .)
    BAR             reduce using rule 28 (exp -> variable_declaration .)


state 41

    (29) exp -> if_then_else .

    PLUS            reduce using rule 29 (exp -> if_then_else .)
    MINUS           reduce using rule 29 (exp -> if_then_else .)
    TIMES           reduce using rule 29 (exp -> if_then_else .)
    DIVIDE          reduce using rule 29 (exp -> if_then_else .)
    MOD             reduce using rule 29 (exp -> if_then_else .)
    POWER           reduce using rule 29 (exp -> if_then_else .)
    EQUALS          reduce using rule 29 (exp -> if_then_else .)
    NOT_EQUALS      reduce using rule 29 (exp -> if_then_else .)
    LESS            reduce using rule 29 (exp -> if_then_else .)
    LESS_EQUAL      reduce using rule 29 (exp -> if_then_else .)
    GREATER         reduce using rule 29 (exp -> if_then_else .)
    GREATER_EQUAL   reduce using rule 29 (exp -> if_then_else .)
    AND             reduce using rule 29 (exp -> if_then_else .)
    OR              reduce using rule 29 (exp -> if_then_else .)
    SEMICOLON       reduce using rule 29 (exp -> if_then_else .)
    LET             reduce using rule 29 (exp -> if_then_else .)
    $end            reduce using rule 29 (exp -> if_then_else .)
    RPAREN          reduce using rule 29 (exp -> if_then_else .)
    THEN            reduce using rule 29 (exp -> if_then_else .)
    DO              reduce using rule 29 (exp -> if_then_else .)
    COMMA           reduce using rule 29 (exp -> if_then_else .)
    RBRACKET        reduce using rule 29 (exp -> if_then_else .)
    ELSE            reduce using rule 29 (exp -> if_then_else .)
    BAR             reduce using rule 29 (exp -> if_then_else .)


state 42

    (30) exp -> if_then .

    PLUS            reduce using rule 30 (exp -> if_then .)
    MINUS           reduce using rule 30 (exp -> if_then .)
    TIMES           reduce using rule 30 (exp -> if_then .)
    DIVIDE          reduce using rule 30 (exp -> if_then .)
    MOD             reduce using rule 30 (exp -> if_then .)
    POWER           reduce using rule 30 (exp -> if_then .)
    EQUALS          reduce using rule 30 (exp -> if_then .)
    NOT_EQUALS      reduce using rule 30 (exp -> if_then .)
    LESS            reduce using rule 30 (exp -> if_then .)
    LESS_EQUAL      reduce using rule 30 (exp -> if_then .)
    GREATER         reduce using rule 30 (exp -> if_then .)
    GREATER_EQUAL   reduce using rule 30 (exp -> if_then .)
    AND             reduce using rule 30 (exp -> if_then .)
    OR              reduce using rule 30 (exp -> if_then .)
    SEMICOLON       reduce using rule 30 (exp -> if_then .)
    LET             reduce using rule 30 (exp -> if_then .)
    $end            reduce using rule 30 (exp -> if_then .)
    RPAREN          reduce using rule 30 (exp -> if_then .)
    THEN            reduce using rule 30 (exp -> if_then .)
    DO              reduce using rule 30 (exp -> if_then .)
    COMMA           reduce using rule 30 (exp -> if_then .)
    RBRACKET        reduce using rule 30 (exp -> if_then .)
    ELSE            reduce using rule 30 (exp -> if_then .)
    BAR             reduce using rule 30 (exp -> if_then .)


state 43

    (31) exp -> while_loop .

    PLUS            reduce using rule 31 (exp -> while_loop .)
    MINUS           reduce using rule 31 (exp -> while_loop .)
    TIMES           reduce using rule 31 (exp -> while_loop .)
    DIVIDE          reduce using rule 31 (exp -> while_loop .)
    MOD             reduce using rule 31 (exp -> while_loop .)
    POWER           reduce using rule 31 (exp -> while_loop .)
    EQUALS          reduce using rule 31 (exp -> while_loop .)
    NOT_EQUALS      reduce using rule 31 (exp -> while_loop .)
    LESS            reduce using rule 31 (exp -> while_loop .)
    LESS_EQUAL      reduce using rule 31 (exp -> while_loop .)
    GREATER         reduce using rule 31 (exp -> while_loop .)
    GREATER_EQUAL   reduce using rule 31 (exp -> while_loop .)
    AND             reduce using rule 31 (exp -> while_loop .)
    OR              reduce using rule 31 (exp -> while_loop .)
    SEMICOLON       reduce using rule 31 (exp -> while_loop .)
    LET             reduce using rule 31 (exp -> while_loop .)
    $end            reduce using rule 31 (exp -> while_loop .)
    RPAREN          reduce using rule 31 (exp -> while_loop .)
    THEN            reduce using rule 31 (exp -> while_loop .)
    DO              reduce using rule 31 (exp -> while_loop .)
    COMMA           reduce using rule 31 (exp -> while_loop .)
    RBRACKET        reduce using rule 31 (exp -> while_loop .)
    ELSE            reduce using rule 31 (exp -> while_loop .)
    BAR             reduce using rule 31 (exp -> while_loop .)


state 44

    (32) exp -> array_creation .

    PLUS            reduce using rule 32 (exp -> array_creation .)
    MINUS           reduce using rule 32 (exp -> array_creation .)
    TIMES           reduce using rule 32 (exp -> array_creation .)
    DIVIDE          reduce using rule 32 (exp -> array_creation .)
    MOD             reduce using rule 32 (exp -> array_creation .)
    POWER           reduce using rule 32 (exp -> array_creation .)
    EQUALS          reduce using rule 32 (exp -> array_creation .)
    NOT_EQUALS      reduce using rule 32 (exp -> array_creation .)
    LESS            reduce using rule 32 (exp -> array_creation .)
    LESS_EQUAL      reduce using rule 32 (exp -> array_creation .)
    GREATER         reduce using rule 32 (exp -> array_creation .)
    GREATER_EQUAL   reduce using rule 32 (exp -> array_creation .)
    AND             reduce using rule 32 (exp -> array_creation .)
    OR              reduce using rule 32 (exp -> array_creation .)
    SEMICOLON       reduce using rule 32 (exp -> array_creation .)
    LET             reduce using rule 32 (exp -> array_creation .)
    $end            reduce using rule 32 (exp -> array_creation .)
    RPAREN          reduce using rule 32 (exp -> array_creation .)
    THEN            reduce using rule 32 (exp -> array_creation .)
    DO              reduce using rule 32 (exp -> array_creation .)
    COMMA           reduce using rule 32 (exp -> array_creation .)
    RBRACKET        reduce using rule 32 (exp -> array_creation .)
    ELSE            reduce using rule 32 (exp -> array_creation .)
    BAR             reduce using rule 32 (exp -> array_creation .)


state 45

    (33) exp -> array_access .
    (66) lhs -> array_access .

    PLUS            reduce using rule 33 (exp -> array_access .)
    MINUS           reduce using rule 33 (exp -> array_access .)
    TIMES           reduce using rule 33 (exp -> array_access .)
    DIVIDE          reduce using rule 33 (exp -> array_access .)
    MOD             reduce using rule 33 (exp -> array_access .)
    POWER           reduce using rule 33 (exp -> array_access .)
    EQUALS          reduce using rule 33 (exp -> array_access .)
    NOT_EQUALS      reduce using rule 33 (exp -> array_access .)
    LESS            reduce using rule 33 (exp -> array_access .)
    LESS_EQUAL      reduce using rule 33 (exp -> array_access .)
    GREATER         reduce using rule 33 (exp -> array_access .)
    GREATER_EQUAL   reduce using rule 33 (exp -> array_access .)
    AND             reduce using rule 33 (exp -> array_access .)
    OR              reduce using rule 33 (exp -> array_access .)
    SEMICOLON       reduce using rule 33 (exp -> array_access .)
    LET             reduce using rule 33 (exp -> array_access .)
    $end            reduce using rule 33 (exp -> array_access .)
    RPAREN          reduce using rule 33 (exp -> array_access .)
    THEN            reduce using rule 33 (exp -> array_access .)
    DO              reduce using rule 33 (exp -> array_access .)
    COMMA           reduce using rule 33 (exp -> array_access .)
    RBRACKET        reduce using rule 33 (exp -> array_access .)
    ELSE            reduce using rule 33 (exp -> array_access .)
    BAR             reduce using rule 33 (exp -> array_access .)
    LBRACKET        reduce using rule 66 (lhs -> array_access .)


state 46

    (34) exp -> group .

    PLUS            reduce using rule 34 (exp -> group .)
    MINUS           reduce using rule 34 (exp -> group .)
    TIMES           reduce using rule 34 (exp -> group .)
    DIVIDE          reduce using rule 34 (exp -> group .)
    MOD             reduce using rule 34 (exp -> group .)
    POWER           reduce using rule 34 (exp -> group .)
    EQUALS          reduce using rule 34 (exp -> group .)
    NOT_EQUALS      reduce using rule 34 (exp -> group .)
    LESS            reduce using rule 34 (exp -> group .)
    LESS_EQUAL      reduce using rule 34 (exp -> group .)
    GREATER         reduce using rule 34 (exp -> group .)
    GREATER_EQUAL   reduce using rule 34 (exp -> group .)
    AND             reduce using rule 34 (exp -> group .)
    OR              reduce using rule 34 (exp -> group .)
    SEMICOLON       reduce using rule 34 (exp -> group .)
    LET             reduce using rule 34 (exp -> group .)
    $end            reduce using rule 34 (exp -> group .)
    RPAREN          reduce using rule 34 (exp -> group .)
    THEN            reduce using rule 34 (exp -> group .)
    DO              reduce using rule 34 (exp -> group .)
    COMMA           reduce using rule 34 (exp -> group .)
    RBRACKET        reduce using rule 34 (exp -> group .)
    ELSE            reduce using rule 34 (exp -> group .)
    BAR             reduce using rule 34 (exp -> group .)


state 47

    (37) literal -> INT_LITERAL .

    PLUS            reduce using rule 37 (literal -> INT_LITERAL .)
    MINUS           reduce using rule 37 (literal -> INT_LITERAL .)
    TIMES           reduce using rule 37 (literal -> INT_LITERAL .)
    DIVIDE          reduce using rule 37 (literal -> INT_LITERAL .)
    MOD             reduce using rule 37 (literal -> INT_LITERAL .)
    POWER           reduce using rule 37 (literal -> INT_LITERAL .)
    EQUALS          reduce using rule 37 (literal -> INT_LITERAL .)
    NOT_EQUALS      reduce using rule 37 (literal -> INT_LITERAL .)
    LESS            reduce using rule 37 (literal -> INT_LITERAL .)
    LESS_EQUAL      reduce using rule 37 (literal -> INT_LITERAL .)
    GREATER         reduce using rule 37 (literal -> INT_LITERAL .)
    GREATER_EQUAL   reduce using rule 37 (literal -> INT_LITERAL .)
    AND             reduce using rule 37 (literal -> INT_LITERAL .)
    OR              reduce using rule 37 (literal -> INT_LITERAL .)
    SEMICOLON       reduce using rule 37 (literal -> INT_LITERAL .)
    LET             reduce using rule 37 (literal -> INT_LITERAL .)
    $end            reduce using rule 37 (literal -> INT_LITERAL .)
    RPAREN          reduce using rule 37 (literal -> INT_LITERAL .)
    THEN            reduce using rule 37 (literal -> INT_LITERAL .)
    DO              reduce using rule 37 (literal -> INT_LITERAL .)
    COMMA           reduce using rule 37 (literal -> INT_LITERAL .)
    RBRACKET        reduce using rule 37 (literal -> INT_LITERAL .)
    ELSE            reduce using rule 37 (literal -> INT_LITERAL .)
    BAR             reduce using rule 37 (literal -> INT_LITERAL .)


state 48

    (38) literal -> TRUE .

    PLUS            reduce using rule 38 (literal -> TRUE .)
    MINUS           reduce using rule 38 (literal -> TRUE .)
    TIMES           reduce using rule 38 (literal -> TRUE .)
    DIVIDE          reduce using rule 38 (literal -> TRUE .)
    MOD             reduce using rule 38 (literal -> TRUE .)
    POWER           reduce using rule 38 (literal -> TRUE .)
    EQUALS          reduce using rule 38 (literal -> TRUE .)
    NOT_EQUALS      reduce using rule 38 (literal -> TRUE .)
    LESS            reduce using rule 38 (literal -> TRUE .)
    LESS_EQUAL      reduce using rule 38 (literal -> TRUE .)
    GREATER         reduce using rule 38 (literal -> TRUE .)
    GREATER_EQUAL   reduce using rule 38 (literal -> TRUE .)
    AND             reduce using rule 38 (literal -> TRUE .)
    OR              reduce using rule 38 (literal -> TRUE .)
    SEMICOLON       reduce using rule 38 (literal -> TRUE .)
    LET             reduce using rule 38 (literal -> TRUE .)
    $end            reduce using rule 38 (literal -> TRUE .)
    RPAREN          reduce using rule 38 (literal -> TRUE .)
    THEN            reduce using rule 38 (literal -> TRUE .)
    DO              reduce using rule 38 (literal -> TRUE .)
    COMMA           reduce using rule 38 (literal -> TRUE .)
    RBRACKET        reduce using rule 38 (literal -> TRUE .)
    ELSE            reduce using rule 38 (literal -> TRUE .)
    BAR             reduce using rule 38 (literal -> TRUE .)


state 49

    (39) literal -> FALSE .

    PLUS            reduce using rule 39 (literal -> FALSE .)
    MINUS           reduce using rule 39 (literal -> FALSE .)
    TIMES           reduce using rule 39 (literal -> FALSE .)
    DIVIDE          reduce using rule 39 (literal -> FALSE .)
    MOD             reduce using rule 39 (literal -> FALSE .)
    POWER           reduce using rule 39 (literal -> FALSE .)
    EQUALS          reduce using rule 39 (literal -> FALSE .)
    NOT_EQUALS      reduce using rule 39 (literal -> FALSE .)
    LESS            reduce using rule 39 (literal -> FALSE .)
    LESS_EQUAL      reduce using rule 39 (literal -> FALSE .)
    GREATER         reduce using rule 39 (literal -> FALSE .)
    GREATER_EQUAL   reduce using rule 39 (literal -> FALSE .)
    AND             reduce using rule 39 (literal -> FALSE .)
    OR              reduce using rule 39 (literal -> FALSE .)
    SEMICOLON       reduce using rule 39 (literal -> FALSE .)
    LET             reduce using rule 39 (literal -> FALSE .)
    $end            reduce using rule 39 (literal -> FALSE .)
    RPAREN          reduce using rule 39 (literal -> FALSE .)
    THEN            reduce using rule 39 (literal -> FALSE .)
    DO              reduce using rule 39 (literal -> FALSE .)
    COMMA           reduce using rule 39 (literal -> FALSE .)
    RBRACKET        reduce using rule 39 (literal -> FALSE .)
    ELSE            reduce using rule 39 (literal -> FALSE .)
    BAR             reduce using rule 39 (literal -> FALSE .)


state 50

    (40) literal -> NULL .

    PLUS            reduce using rule 40 (literal -> NULL .)
    MINUS           reduce using rule 40 (literal -> NULL .)
    TIMES           reduce using rule 40 (literal -> NULL .)
    DIVIDE          reduce using rule 40 (literal -> NULL .)
    MOD             reduce using rule 40 (literal -> NULL .)
    POWER           reduce using rule 40 (literal -> NULL .)
    EQUALS          reduce using rule 40 (literal -> NULL .)
    NOT_EQUALS      reduce using rule 40 (literal -> NULL .)
    LESS            reduce using rule 40 (literal -> NULL .)
    LESS_EQUAL      reduce using rule 40 (literal -> NULL .)
    GREATER         reduce using rule 40 (literal -> NULL .)
    GREATER_EQUAL   reduce using rule 40 (literal -> NULL .)
    AND             reduce using rule 40 (literal -> NULL .)
    OR              reduce using rule 40 (literal -> NULL .)
    SEMICOLON       reduce using rule 40 (literal -> NULL .)
    LET             reduce using rule 40 (literal -> NULL .)
    $end            reduce using rule 40 (literal -> NULL .)
    RPAREN          reduce using rule 40 (literal -> NULL .)
    THEN            reduce using rule 40 (literal -> NULL .)
    DO              reduce using rule 40 (literal -> NULL .)
    COMMA           reduce using rule 40 (literal -> NULL .)
    RBRACKET        reduce using rule 40 (literal -> NULL .)
    ELSE            reduce using rule 40 (literal -> NULL .)
    BAR             reduce using rule 40 (literal -> NULL .)


state 51

    (41) literal -> UNIT .

    PLUS            reduce using rule 41 (literal -> UNIT .)
    MINUS           reduce using rule 41 (literal -> UNIT .)
    TIMES           reduce using rule 41 (literal -> UNIT .)
    DIVIDE          reduce using rule 41 (literal -> UNIT .)
    MOD             reduce using rule 41 (literal -> UNIT .)
    POWER           reduce using rule 41 (literal -> UNIT .)
    EQUALS          reduce using rule 41 (literal -> UNIT .)
    NOT_EQUALS      reduce using rule 41 (literal -> UNIT .)
    LESS            reduce using rule 41 (literal -> UNIT .)
    LESS_EQUAL      reduce using rule 41 (literal -> UNIT .)
    GREATER         reduce using rule 41 (literal -> UNIT .)
    GREATER_EQUAL   reduce using rule 41 (literal -> UNIT .)
    AND             reduce using rule 41 (literal -> UNIT .)
    OR              reduce using rule 41 (literal -> UNIT .)
    SEMICOLON       reduce using rule 41 (literal -> UNIT .)
    LET             reduce using rule 41 (literal -> UNIT .)
    $end            reduce using rule 41 (literal -> UNIT .)
    RPAREN          reduce using rule 41 (literal -> UNIT .)
    THEN            reduce using rule 41 (literal -> UNIT .)
    DO              reduce using rule 41 (literal -> UNIT .)
    COMMA           reduce using rule 41 (literal -> UNIT .)
    RBRACKET        reduce using rule 41 (literal -> UNIT .)
    ELSE            reduce using rule 41 (literal -> UNIT .)
    BAR             reduce using rule 41 (literal -> UNIT .)


state 52

    (42) literal -> STRING_LITERAL .

    PLUS            reduce using rule 42 (literal -> STRING_LITERAL .)
    MINUS           reduce using rule 42 (literal -> STRING_LITERAL .)
    TIMES           reduce using rule 42 (literal -> STRING_LITERAL .)
    DIVIDE          reduce using rule 42 (literal -> STRING_LITERAL .)
    MOD             reduce using rule 42 (literal -> STRING_LITERAL .)
    POWER           reduce using rule 42 (literal -> STRING_LITERAL .)
    EQUALS          reduce using rule 42 (literal -> STRING_LITERAL .)
    NOT_EQUALS      reduce using rule 42 (literal -> STRING_LITERAL .)
    LESS            reduce using rule 42 (literal -> STRING_LITERAL .)
    LESS_EQUAL      reduce using rule 42 (literal -> STRING_LITERAL .)
    GREATER         reduce using rule 42 (literal -> STRING_LITERAL .)
    GREATER_EQUAL   reduce using rule 42 (literal -> STRING_LITERAL .)
    AND             reduce using rule 42 (literal -> STRING_LITERAL .)
    OR              reduce using rule 42 (literal -> STRING_LITERAL .)
    SEMICOLON       reduce using rule 42 (literal -> STRING_LITERAL .)
    LET             reduce using rule 42 (literal -> STRING_LITERAL .)
    $end            reduce using rule 42 (literal -> STRING_LITERAL .)
    RPAREN          reduce using rule 42 (literal -> STRING_LITERAL .)
    THEN            reduce using rule 42 (literal -> STRING_LITERAL .)
    DO              reduce using rule 42 (literal -> STRING_LITERAL .)
    COMMA           reduce using rule 42 (literal -> STRING_LITERAL .)
    RBRACKET        reduce using rule 42 (literal -> STRING_LITERAL .)
    ELSE            reduce using rule 42 (literal -> STRING_LITERAL .)
    BAR             reduce using rule 42 (literal -> STRING_LITERAL .)


state 53

    (58) unary_exp -> MINUS . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs ASSIGN exp
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 32
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 80
    variable                       shift and go to state 33
    literal                        shift and go to state 35
    binary_exp                     shift and go to state 36
    unary_exp                      shift and go to state 37
    function_call                  shift and go to state 38
    assignment                     shift and go to state 39
    variable_declaration           shift and go to state 40
    if_then_else                   shift and go to state 41
    if_then                        shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 54

    (59) unary_exp -> NOT . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs ASSIGN exp
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 32
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 81
    variable                       shift and go to state 33
    literal                        shift and go to state 35
    binary_exp                     shift and go to state 36
    unary_exp                      shift and go to state 37
    function_call                  shift and go to state 38
    assignment                     shift and go to state 39
    variable_declaration           shift and go to state 40
    if_then_else                   shift and go to state 41
    if_then                        shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 55

    (73) group -> LPAREN . exp RPAREN
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs ASSIGN exp
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 32
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 82
    variable                       shift and go to state 33
    literal                        shift and go to state 35
    binary_exp                     shift and go to state 36
    unary_exp                      shift and go to state 37
    function_call                  shift and go to state 38
    assignment                     shift and go to state 39
    variable_declaration           shift and go to state 40
    if_then_else                   shift and go to state 41
    if_then                        shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 56

    (64) assignment -> SET . lhs ASSIGN exp
    (65) lhs -> . variable
    (66) lhs -> . array_access
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (67) array_access -> . lhs LBRACKET exp RBRACKET

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12

    lhs                            shift and go to state 83
    variable                       shift and go to state 84
    array_access                   shift and go to state 85

state 57

    (67) array_access -> lhs . LBRACKET exp RBRACKET

    LBRACKET        shift and go to state 86


state 58

    (69) if_then_else -> IF . exp THEN exp ELSE exp
    (70) if_then -> IF . exp THEN exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs ASSIGN exp
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 32
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 87
    variable                       shift and go to state 33
    literal                        shift and go to state 35
    binary_exp                     shift and go to state 36
    unary_exp                      shift and go to state 37
    function_call                  shift and go to state 38
    assignment                     shift and go to state 39
    variable_declaration           shift and go to state 40
    if_then_else                   shift and go to state 41
    if_then                        shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 59

    (71) while_loop -> WHILE . exp DO exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs ASSIGN exp
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 32
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 88
    variable                       shift and go to state 33
    literal                        shift and go to state 35
    binary_exp                     shift and go to state 36
    unary_exp                      shift and go to state 37
    function_call                  shift and go to state 38
    assignment                     shift and go to state 39
    variable_declaration           shift and go to state 40
    if_then_else                   shift and go to state 41
    if_then                        shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 60

    (72) array_creation -> NEW . type LBRACKET exp BAR exp RBRACKET
    (11) type -> . base_type
    (12) type -> . array_type
    (13) base_type -> . INT_TYPE
    (14) base_type -> . STRING_TYPE
    (15) base_type -> . UNIT_TYPE
    (16) base_type -> . BOOL_TYPE
    (17) array_type -> . type LBRACKET RBRACKET

    INT_TYPE        shift and go to state 19
    STRING_TYPE     shift and go to state 20
    UNIT_TYPE       shift and go to state 21
    BOOL_TYPE       shift and go to state 22

    type                           shift and go to state 89
    base_type                      shift and go to state 17
    array_type                     shift and go to state 18

state 61

    (17) array_type -> type LBRACKET RBRACKET .

    ASSIGN          reduce using rule 17 (array_type -> type LBRACKET RBRACKET .)
    LBRACKET        reduce using rule 17 (array_type -> type LBRACKET RBRACKET .)
    ARROW           reduce using rule 17 (array_type -> type LBRACKET RBRACKET .)
    COMMA           reduce using rule 17 (array_type -> type LBRACKET RBRACKET .)
    RPAREN          reduce using rule 17 (array_type -> type LBRACKET RBRACKET .)


state 62

    (7) function_declaration -> LET ID LPAREN parameters RPAREN COLON . function_type ASSIGN exp
    (18) function_type -> . type ARROW type
    (19) function_type -> . LPAREN type function_type_tail RPAREN ARROW type
    (11) type -> . base_type
    (12) type -> . array_type
    (13) base_type -> . INT_TYPE
    (14) base_type -> . STRING_TYPE
    (15) base_type -> . UNIT_TYPE
    (16) base_type -> . BOOL_TYPE
    (17) array_type -> . type LBRACKET RBRACKET

    LPAREN          shift and go to state 90
    INT_TYPE        shift and go to state 19
    STRING_TYPE     shift and go to state 20
    UNIT_TYPE       shift and go to state 21
    BOOL_TYPE       shift and go to state 22

    function_type                  shift and go to state 91
    type                           shift and go to state 92
    base_type                      shift and go to state 17
    array_type                     shift and go to state 18

state 63

    (9) parameters_tail -> COMMA variable . parameters_tail
    (9) parameters_tail -> . COMMA variable parameters_tail
    (10) parameters_tail -> . empty
    (74) empty -> .

    COMMA           shift and go to state 30
    RPAREN          reduce using rule 74 (empty -> .)

    parameters_tail                shift and go to state 93
    empty                          shift and go to state 31

state 64

    (60) function_call -> variable LPAREN . arguments RPAREN
    (61) arguments -> . exp arguments_tail
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs ASSIGN exp
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 32
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    variable                       shift and go to state 33
    arguments                      shift and go to state 94
    exp                            shift and go to state 95
    literal                        shift and go to state 35
    binary_exp                     shift and go to state 36
    unary_exp                      shift and go to state 37
    function_call                  shift and go to state 38
    assignment                     shift and go to state 39
    variable_declaration           shift and go to state 40
    if_then_else                   shift and go to state 41
    if_then                        shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 65

    (43) binary_exp -> exp PLUS . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs ASSIGN exp
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 32
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 96
    variable                       shift and go to state 33
    literal                        shift and go to state 35
    binary_exp                     shift and go to state 36
    unary_exp                      shift and go to state 37
    function_call                  shift and go to state 38
    assignment                     shift and go to state 39
    variable_declaration           shift and go to state 40
    if_then_else                   shift and go to state 41
    if_then                        shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 66

    (44) binary_exp -> exp MINUS . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs ASSIGN exp
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 32
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 97
    variable                       shift and go to state 33
    literal                        shift and go to state 35
    binary_exp                     shift and go to state 36
    unary_exp                      shift and go to state 37
    function_call                  shift and go to state 38
    assignment                     shift and go to state 39
    variable_declaration           shift and go to state 40
    if_then_else                   shift and go to state 41
    if_then                        shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 67

    (45) binary_exp -> exp TIMES . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs ASSIGN exp
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 32
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 98
    variable                       shift and go to state 33
    literal                        shift and go to state 35
    binary_exp                     shift and go to state 36
    unary_exp                      shift and go to state 37
    function_call                  shift and go to state 38
    assignment                     shift and go to state 39
    variable_declaration           shift and go to state 40
    if_then_else                   shift and go to state 41
    if_then                        shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 68

    (46) binary_exp -> exp DIVIDE . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs ASSIGN exp
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 32
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 99
    variable                       shift and go to state 33
    literal                        shift and go to state 35
    binary_exp                     shift and go to state 36
    unary_exp                      shift and go to state 37
    function_call                  shift and go to state 38
    assignment                     shift and go to state 39
    variable_declaration           shift and go to state 40
    if_then_else                   shift and go to state 41
    if_then                        shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 69

    (47) binary_exp -> exp MOD . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs ASSIGN exp
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 32
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 100
    variable                       shift and go to state 33
    literal                        shift and go to state 35
    binary_exp                     shift and go to state 36
    unary_exp                      shift and go to state 37
    function_call                  shift and go to state 38
    assignment                     shift and go to state 39
    variable_declaration           shift and go to state 40
    if_then_else                   shift and go to state 41
    if_then                        shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 70

    (48) binary_exp -> exp POWER . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs ASSIGN exp
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 32
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 101
    variable                       shift and go to state 33
    literal                        shift and go to state 35
    binary_exp                     shift and go to state 36
    unary_exp                      shift and go to state 37
    function_call                  shift and go to state 38
    assignment                     shift and go to state 39
    variable_declaration           shift and go to state 40
    if_then_else                   shift and go to state 41
    if_then                        shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 71

    (49) binary_exp -> exp EQUALS . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs ASSIGN exp
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 32
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 102
    variable                       shift and go to state 33
    literal                        shift and go to state 35
    binary_exp                     shift and go to state 36
    unary_exp                      shift and go to state 37
    function_call                  shift and go to state 38
    assignment                     shift and go to state 39
    variable_declaration           shift and go to state 40
    if_then_else                   shift and go to state 41
    if_then                        shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 72

    (50) binary_exp -> exp NOT_EQUALS . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs ASSIGN exp
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 32
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 103
    variable                       shift and go to state 33
    literal                        shift and go to state 35
    binary_exp                     shift and go to state 36
    unary_exp                      shift and go to state 37
    function_call                  shift and go to state 38
    assignment                     shift and go to state 39
    variable_declaration           shift and go to state 40
    if_then_else                   shift and go to state 41
    if_then                        shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 73

    (51) binary_exp -> exp LESS . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs ASSIGN exp
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 32
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 104
    variable                       shift and go to state 33
    literal                        shift and go to state 35
    binary_exp                     shift and go to state 36
    unary_exp                      shift and go to state 37
    function_call                  shift and go to state 38
    assignment                     shift and go to state 39
    variable_declaration           shift and go to state 40
    if_then_else                   shift and go to state 41
    if_then                        shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 74

    (52) binary_exp -> exp LESS_EQUAL . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs ASSIGN exp
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 32
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 105
    variable                       shift and go to state 33
    literal                        shift and go to state 35
    binary_exp                     shift and go to state 36
    unary_exp                      shift and go to state 37
    function_call                  shift and go to state 38
    assignment                     shift and go to state 39
    variable_declaration           shift and go to state 40
    if_then_else                   shift and go to state 41
    if_then                        shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 75

    (53) binary_exp -> exp GREATER . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs ASSIGN exp
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 32
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 106
    variable                       shift and go to state 33
    literal                        shift and go to state 35
    binary_exp                     shift and go to state 36
    unary_exp                      shift and go to state 37
    function_call                  shift and go to state 38
    assignment                     shift and go to state 39
    variable_declaration           shift and go to state 40
    if_then_else                   shift and go to state 41
    if_then                        shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 76

    (54) binary_exp -> exp GREATER_EQUAL . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs ASSIGN exp
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 32
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 107
    variable                       shift and go to state 33
    literal                        shift and go to state 35
    binary_exp                     shift and go to state 36
    unary_exp                      shift and go to state 37
    function_call                  shift and go to state 38
    assignment                     shift and go to state 39
    variable_declaration           shift and go to state 40
    if_then_else                   shift and go to state 41
    if_then                        shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 77

    (55) binary_exp -> exp AND . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs ASSIGN exp
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 32
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 108
    variable                       shift and go to state 33
    literal                        shift and go to state 35
    binary_exp                     shift and go to state 36
    unary_exp                      shift and go to state 37
    function_call                  shift and go to state 38
    assignment                     shift and go to state 39
    variable_declaration           shift and go to state 40
    if_then_else                   shift and go to state 41
    if_then                        shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 78

    (56) binary_exp -> exp OR . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs ASSIGN exp
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 32
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 109
    variable                       shift and go to state 33
    literal                        shift and go to state 35
    binary_exp                     shift and go to state 36
    unary_exp                      shift and go to state 37
    function_call                  shift and go to state 38
    assignment                     shift and go to state 39
    variable_declaration           shift and go to state 40
    if_then_else                   shift and go to state 41
    if_then                        shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 79

    (57) binary_exp -> exp SEMICOLON . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs ASSIGN exp
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 32
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 110
    variable                       shift and go to state 33
    literal                        shift and go to state 35
    binary_exp                     shift and go to state 36
    unary_exp                      shift and go to state 37
    function_call                  shift and go to state 38
    assignment                     shift and go to state 39
    variable_declaration           shift and go to state 40
    if_then_else                   shift and go to state 41
    if_then                        shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 80

    (58) unary_exp -> MINUS exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    PLUS            reduce using rule 58 (unary_exp -> MINUS exp .)
    MINUS           reduce using rule 58 (unary_exp -> MINUS exp .)
    TIMES           reduce using rule 58 (unary_exp -> MINUS exp .)
    DIVIDE          reduce using rule 58 (unary_exp -> MINUS exp .)
    MOD             reduce using rule 58 (unary_exp -> MINUS exp .)
    POWER           reduce using rule 58 (unary_exp -> MINUS exp .)
    EQUALS          reduce using rule 58 (unary_exp -> MINUS exp .)
    NOT_EQUALS      reduce using rule 58 (unary_exp -> MINUS exp .)
    LESS            reduce using rule 58 (unary_exp -> MINUS exp .)
    LESS_EQUAL      reduce using rule 58 (unary_exp -> MINUS exp .)
    GREATER         reduce using rule 58 (unary_exp -> MINUS exp .)
    GREATER_EQUAL   reduce using rule 58 (unary_exp -> MINUS exp .)
    AND             reduce using rule 58 (unary_exp -> MINUS exp .)
    OR              reduce using rule 58 (unary_exp -> MINUS exp .)
    SEMICOLON       reduce using rule 58 (unary_exp -> MINUS exp .)
    LET             reduce using rule 58 (unary_exp -> MINUS exp .)
    $end            reduce using rule 58 (unary_exp -> MINUS exp .)
    RPAREN          reduce using rule 58 (unary_exp -> MINUS exp .)
    THEN            reduce using rule 58 (unary_exp -> MINUS exp .)
    DO              reduce using rule 58 (unary_exp -> MINUS exp .)
    COMMA           reduce using rule 58 (unary_exp -> MINUS exp .)
    RBRACKET        reduce using rule 58 (unary_exp -> MINUS exp .)
    ELSE            reduce using rule 58 (unary_exp -> MINUS exp .)
    BAR             reduce using rule 58 (unary_exp -> MINUS exp .)

  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 66 ]
  ! TIMES           [ shift and go to state 67 ]
  ! DIVIDE          [ shift and go to state 68 ]
  ! MOD             [ shift and go to state 69 ]
  ! POWER           [ shift and go to state 70 ]
  ! EQUALS          [ shift and go to state 71 ]
  ! NOT_EQUALS      [ shift and go to state 72 ]
  ! LESS            [ shift and go to state 73 ]
  ! LESS_EQUAL      [ shift and go to state 74 ]
  ! GREATER         [ shift and go to state 75 ]
  ! GREATER_EQUAL   [ shift and go to state 76 ]
  ! AND             [ shift and go to state 77 ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 81

    (59) unary_exp -> NOT exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    PLUS            reduce using rule 59 (unary_exp -> NOT exp .)
    MINUS           reduce using rule 59 (unary_exp -> NOT exp .)
    TIMES           reduce using rule 59 (unary_exp -> NOT exp .)
    DIVIDE          reduce using rule 59 (unary_exp -> NOT exp .)
    MOD             reduce using rule 59 (unary_exp -> NOT exp .)
    POWER           reduce using rule 59 (unary_exp -> NOT exp .)
    EQUALS          reduce using rule 59 (unary_exp -> NOT exp .)
    NOT_EQUALS      reduce using rule 59 (unary_exp -> NOT exp .)
    LESS            reduce using rule 59 (unary_exp -> NOT exp .)
    LESS_EQUAL      reduce using rule 59 (unary_exp -> NOT exp .)
    GREATER         reduce using rule 59 (unary_exp -> NOT exp .)
    GREATER_EQUAL   reduce using rule 59 (unary_exp -> NOT exp .)
    AND             reduce using rule 59 (unary_exp -> NOT exp .)
    OR              reduce using rule 59 (unary_exp -> NOT exp .)
    SEMICOLON       reduce using rule 59 (unary_exp -> NOT exp .)
    LET             reduce using rule 59 (unary_exp -> NOT exp .)
    $end            reduce using rule 59 (unary_exp -> NOT exp .)
    RPAREN          reduce using rule 59 (unary_exp -> NOT exp .)
    THEN            reduce using rule 59 (unary_exp -> NOT exp .)
    DO              reduce using rule 59 (unary_exp -> NOT exp .)
    COMMA           reduce using rule 59 (unary_exp -> NOT exp .)
    RBRACKET        reduce using rule 59 (unary_exp -> NOT exp .)
    ELSE            reduce using rule 59 (unary_exp -> NOT exp .)
    BAR             reduce using rule 59 (unary_exp -> NOT exp .)

  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 66 ]
  ! TIMES           [ shift and go to state 67 ]
  ! DIVIDE          [ shift and go to state 68 ]
  ! MOD             [ shift and go to state 69 ]
  ! POWER           [ shift and go to state 70 ]
  ! EQUALS          [ shift and go to state 71 ]
  ! NOT_EQUALS      [ shift and go to state 72 ]
  ! LESS            [ shift and go to state 73 ]
  ! LESS_EQUAL      [ shift and go to state 74 ]
  ! GREATER         [ shift and go to state 75 ]
  ! GREATER_EQUAL   [ shift and go to state 76 ]
  ! AND             [ shift and go to state 77 ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 82

    (73) group -> LPAREN exp . RPAREN
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    RPAREN          shift and go to state 111
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POWER           shift and go to state 70
    EQUALS          shift and go to state 71
    NOT_EQUALS      shift and go to state 72
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    SEMICOLON       shift and go to state 79


state 83

    (64) assignment -> SET lhs . ASSIGN exp
    (67) array_access -> lhs . LBRACKET exp RBRACKET

    ASSIGN          shift and go to state 112
    LBRACKET        shift and go to state 86


state 84

    (65) lhs -> variable .

    ASSIGN          reduce using rule 65 (lhs -> variable .)
    LBRACKET        reduce using rule 65 (lhs -> variable .)


state 85

    (66) lhs -> array_access .

    ASSIGN          reduce using rule 66 (lhs -> array_access .)
    LBRACKET        reduce using rule 66 (lhs -> array_access .)


state 86

    (67) array_access -> lhs LBRACKET . exp RBRACKET
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs ASSIGN exp
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 32
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    lhs                            shift and go to state 57
    exp                            shift and go to state 113
    variable                       shift and go to state 33
    literal                        shift and go to state 35
    binary_exp                     shift and go to state 36
    unary_exp                      shift and go to state 37
    function_call                  shift and go to state 38
    assignment                     shift and go to state 39
    variable_declaration           shift and go to state 40
    if_then_else                   shift and go to state 41
    if_then                        shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46

state 87

    (69) if_then_else -> IF exp . THEN exp ELSE exp
    (70) if_then -> IF exp . THEN exp
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    THEN            shift and go to state 114
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POWER           shift and go to state 70
    EQUALS          shift and go to state 71
    NOT_EQUALS      shift and go to state 72
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    SEMICOLON       shift and go to state 79


state 88

    (71) while_loop -> WHILE exp . DO exp
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    DO              shift and go to state 115
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POWER           shift and go to state 70
    EQUALS          shift and go to state 71
    NOT_EQUALS      shift and go to state 72
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    SEMICOLON       shift and go to state 79


state 89

    (72) array_creation -> NEW type . LBRACKET exp BAR exp RBRACKET
    (17) array_type -> type . LBRACKET RBRACKET

    LBRACKET        shift and go to state 116


state 90

    (19) function_type -> LPAREN . type function_type_tail RPAREN ARROW type
    (11) type -> . base_type
    (12) type -> . array_type
    (13) base_type -> . INT_TYPE
    (14) base_type -> . STRING_TYPE
    (15) base_type -> . UNIT_TYPE
    (16) base_type -> . BOOL_TYPE
    (17) array_type -> . type LBRACKET RBRACKET

    INT_TYPE        shift and go to state 19
    STRING_TYPE     shift and go to state 20
    UNIT_TYPE       shift and go to state 21
    BOOL_TYPE       shift and go to state 22

    type                           shift and go to state 117
    base_type                      shift and go to state 17
    array_type                     shift and go to state 18

state 91

    (7) function_declaration -> LET ID LPAREN parameters RPAREN COLON function_type . ASSIGN exp

    ASSIGN          shift and go to state 118


state 92

    (18) function_type -> type . ARROW type
    (17) array_type -> type . LBRACKET RBRACKET

    ARROW           shift and go to state 119
    LBRACKET        shift and go to state 27


state 93

    (9) parameters_tail -> COMMA variable parameters_tail .

    RPAREN          reduce using rule 9 (parameters_tail -> COMMA variable parameters_tail .)


state 94

    (60) function_call -> variable LPAREN arguments . RPAREN

    RPAREN          shift and go to state 120


state 95

    (61) arguments -> exp . arguments_tail
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp
    (62) arguments_tail -> . COMMA exp arguments_tail
    (63) arguments_tail -> . empty
    (74) empty -> .

    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POWER           shift and go to state 70
    EQUALS          shift and go to state 71
    NOT_EQUALS      shift and go to state 72
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    SEMICOLON       shift and go to state 79
    COMMA           shift and go to state 122
    RPAREN          reduce using rule 74 (empty -> .)

    arguments_tail                 shift and go to state 121
    empty                          shift and go to state 123

state 96

    (43) binary_exp -> exp PLUS exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    PLUS            reduce using rule 43 (binary_exp -> exp PLUS exp .)
    MINUS           reduce using rule 43 (binary_exp -> exp PLUS exp .)
    EQUALS          reduce using rule 43 (binary_exp -> exp PLUS exp .)
    NOT_EQUALS      reduce using rule 43 (binary_exp -> exp PLUS exp .)
    LESS            reduce using rule 43 (binary_exp -> exp PLUS exp .)
    LESS_EQUAL      reduce using rule 43 (binary_exp -> exp PLUS exp .)
    GREATER         reduce using rule 43 (binary_exp -> exp PLUS exp .)
    GREATER_EQUAL   reduce using rule 43 (binary_exp -> exp PLUS exp .)
    AND             reduce using rule 43 (binary_exp -> exp PLUS exp .)
    OR              reduce using rule 43 (binary_exp -> exp PLUS exp .)
    SEMICOLON       reduce using rule 43 (binary_exp -> exp PLUS exp .)
    LET             reduce using rule 43 (binary_exp -> exp PLUS exp .)
    $end            reduce using rule 43 (binary_exp -> exp PLUS exp .)
    RPAREN          reduce using rule 43 (binary_exp -> exp PLUS exp .)
    THEN            reduce using rule 43 (binary_exp -> exp PLUS exp .)
    DO              reduce using rule 43 (binary_exp -> exp PLUS exp .)
    COMMA           reduce using rule 43 (binary_exp -> exp PLUS exp .)
    RBRACKET        reduce using rule 43 (binary_exp -> exp PLUS exp .)
    ELSE            reduce using rule 43 (binary_exp -> exp PLUS exp .)
    BAR             reduce using rule 43 (binary_exp -> exp PLUS exp .)
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POWER           shift and go to state 70

  ! TIMES           [ reduce using rule 43 (binary_exp -> exp PLUS exp .) ]
  ! DIVIDE          [ reduce using rule 43 (binary_exp -> exp PLUS exp .) ]
  ! MOD             [ reduce using rule 43 (binary_exp -> exp PLUS exp .) ]
  ! POWER           [ reduce using rule 43 (binary_exp -> exp PLUS exp .) ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 66 ]
  ! EQUALS          [ shift and go to state 71 ]
  ! NOT_EQUALS      [ shift and go to state 72 ]
  ! LESS            [ shift and go to state 73 ]
  ! LESS_EQUAL      [ shift and go to state 74 ]
  ! GREATER         [ shift and go to state 75 ]
  ! GREATER_EQUAL   [ shift and go to state 76 ]
  ! AND             [ shift and go to state 77 ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 97

    (44) binary_exp -> exp MINUS exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    PLUS            reduce using rule 44 (binary_exp -> exp MINUS exp .)
    MINUS           reduce using rule 44 (binary_exp -> exp MINUS exp .)
    EQUALS          reduce using rule 44 (binary_exp -> exp MINUS exp .)
    NOT_EQUALS      reduce using rule 44 (binary_exp -> exp MINUS exp .)
    LESS            reduce using rule 44 (binary_exp -> exp MINUS exp .)
    LESS_EQUAL      reduce using rule 44 (binary_exp -> exp MINUS exp .)
    GREATER         reduce using rule 44 (binary_exp -> exp MINUS exp .)
    GREATER_EQUAL   reduce using rule 44 (binary_exp -> exp MINUS exp .)
    AND             reduce using rule 44 (binary_exp -> exp MINUS exp .)
    OR              reduce using rule 44 (binary_exp -> exp MINUS exp .)
    SEMICOLON       reduce using rule 44 (binary_exp -> exp MINUS exp .)
    LET             reduce using rule 44 (binary_exp -> exp MINUS exp .)
    $end            reduce using rule 44 (binary_exp -> exp MINUS exp .)
    RPAREN          reduce using rule 44 (binary_exp -> exp MINUS exp .)
    THEN            reduce using rule 44 (binary_exp -> exp MINUS exp .)
    DO              reduce using rule 44 (binary_exp -> exp MINUS exp .)
    COMMA           reduce using rule 44 (binary_exp -> exp MINUS exp .)
    RBRACKET        reduce using rule 44 (binary_exp -> exp MINUS exp .)
    ELSE            reduce using rule 44 (binary_exp -> exp MINUS exp .)
    BAR             reduce using rule 44 (binary_exp -> exp MINUS exp .)
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POWER           shift and go to state 70

  ! TIMES           [ reduce using rule 44 (binary_exp -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 44 (binary_exp -> exp MINUS exp .) ]
  ! MOD             [ reduce using rule 44 (binary_exp -> exp MINUS exp .) ]
  ! POWER           [ reduce using rule 44 (binary_exp -> exp MINUS exp .) ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 66 ]
  ! EQUALS          [ shift and go to state 71 ]
  ! NOT_EQUALS      [ shift and go to state 72 ]
  ! LESS            [ shift and go to state 73 ]
  ! LESS_EQUAL      [ shift and go to state 74 ]
  ! GREATER         [ shift and go to state 75 ]
  ! GREATER_EQUAL   [ shift and go to state 76 ]
  ! AND             [ shift and go to state 77 ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 98

    (45) binary_exp -> exp TIMES exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    PLUS            reduce using rule 45 (binary_exp -> exp TIMES exp .)
    MINUS           reduce using rule 45 (binary_exp -> exp TIMES exp .)
    TIMES           reduce using rule 45 (binary_exp -> exp TIMES exp .)
    DIVIDE          reduce using rule 45 (binary_exp -> exp TIMES exp .)
    MOD             reduce using rule 45 (binary_exp -> exp TIMES exp .)
    EQUALS          reduce using rule 45 (binary_exp -> exp TIMES exp .)
    NOT_EQUALS      reduce using rule 45 (binary_exp -> exp TIMES exp .)
    LESS            reduce using rule 45 (binary_exp -> exp TIMES exp .)
    LESS_EQUAL      reduce using rule 45 (binary_exp -> exp TIMES exp .)
    GREATER         reduce using rule 45 (binary_exp -> exp TIMES exp .)
    GREATER_EQUAL   reduce using rule 45 (binary_exp -> exp TIMES exp .)
    AND             reduce using rule 45 (binary_exp -> exp TIMES exp .)
    OR              reduce using rule 45 (binary_exp -> exp TIMES exp .)
    SEMICOLON       reduce using rule 45 (binary_exp -> exp TIMES exp .)
    LET             reduce using rule 45 (binary_exp -> exp TIMES exp .)
    $end            reduce using rule 45 (binary_exp -> exp TIMES exp .)
    RPAREN          reduce using rule 45 (binary_exp -> exp TIMES exp .)
    THEN            reduce using rule 45 (binary_exp -> exp TIMES exp .)
    DO              reduce using rule 45 (binary_exp -> exp TIMES exp .)
    COMMA           reduce using rule 45 (binary_exp -> exp TIMES exp .)
    RBRACKET        reduce using rule 45 (binary_exp -> exp TIMES exp .)
    ELSE            reduce using rule 45 (binary_exp -> exp TIMES exp .)
    BAR             reduce using rule 45 (binary_exp -> exp TIMES exp .)
    POWER           shift and go to state 70

  ! POWER           [ reduce using rule 45 (binary_exp -> exp TIMES exp .) ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 66 ]
  ! TIMES           [ shift and go to state 67 ]
  ! DIVIDE          [ shift and go to state 68 ]
  ! MOD             [ shift and go to state 69 ]
  ! EQUALS          [ shift and go to state 71 ]
  ! NOT_EQUALS      [ shift and go to state 72 ]
  ! LESS            [ shift and go to state 73 ]
  ! LESS_EQUAL      [ shift and go to state 74 ]
  ! GREATER         [ shift and go to state 75 ]
  ! GREATER_EQUAL   [ shift and go to state 76 ]
  ! AND             [ shift and go to state 77 ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 99

    (46) binary_exp -> exp DIVIDE exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    PLUS            reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    MINUS           reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    TIMES           reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    DIVIDE          reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    MOD             reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    EQUALS          reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    NOT_EQUALS      reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    LESS            reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    LESS_EQUAL      reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    GREATER         reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    GREATER_EQUAL   reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    AND             reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    OR              reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    SEMICOLON       reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    LET             reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    $end            reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    RPAREN          reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    THEN            reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    DO              reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    COMMA           reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    RBRACKET        reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    ELSE            reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    BAR             reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    POWER           shift and go to state 70

  ! POWER           [ reduce using rule 46 (binary_exp -> exp DIVIDE exp .) ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 66 ]
  ! TIMES           [ shift and go to state 67 ]
  ! DIVIDE          [ shift and go to state 68 ]
  ! MOD             [ shift and go to state 69 ]
  ! EQUALS          [ shift and go to state 71 ]
  ! NOT_EQUALS      [ shift and go to state 72 ]
  ! LESS            [ shift and go to state 73 ]
  ! LESS_EQUAL      [ shift and go to state 74 ]
  ! GREATER         [ shift and go to state 75 ]
  ! GREATER_EQUAL   [ shift and go to state 76 ]
  ! AND             [ shift and go to state 77 ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 100

    (47) binary_exp -> exp MOD exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    PLUS            reduce using rule 47 (binary_exp -> exp MOD exp .)
    MINUS           reduce using rule 47 (binary_exp -> exp MOD exp .)
    TIMES           reduce using rule 47 (binary_exp -> exp MOD exp .)
    DIVIDE          reduce using rule 47 (binary_exp -> exp MOD exp .)
    MOD             reduce using rule 47 (binary_exp -> exp MOD exp .)
    EQUALS          reduce using rule 47 (binary_exp -> exp MOD exp .)
    NOT_EQUALS      reduce using rule 47 (binary_exp -> exp MOD exp .)
    LESS            reduce using rule 47 (binary_exp -> exp MOD exp .)
    LESS_EQUAL      reduce using rule 47 (binary_exp -> exp MOD exp .)
    GREATER         reduce using rule 47 (binary_exp -> exp MOD exp .)
    GREATER_EQUAL   reduce using rule 47 (binary_exp -> exp MOD exp .)
    AND             reduce using rule 47 (binary_exp -> exp MOD exp .)
    OR              reduce using rule 47 (binary_exp -> exp MOD exp .)
    SEMICOLON       reduce using rule 47 (binary_exp -> exp MOD exp .)
    LET             reduce using rule 47 (binary_exp -> exp MOD exp .)
    $end            reduce using rule 47 (binary_exp -> exp MOD exp .)
    RPAREN          reduce using rule 47 (binary_exp -> exp MOD exp .)
    THEN            reduce using rule 47 (binary_exp -> exp MOD exp .)
    DO              reduce using rule 47 (binary_exp -> exp MOD exp .)
    COMMA           reduce using rule 47 (binary_exp -> exp MOD exp .)
    RBRACKET        reduce using rule 47 (binary_exp -> exp MOD exp .)
    ELSE            reduce using rule 47 (binary_exp -> exp MOD exp .)
    BAR             reduce using rule 47 (binary_exp -> exp MOD exp .)
    POWER           shift and go to state 70

  ! POWER           [ reduce using rule 47 (binary_exp -> exp MOD exp .) ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 66 ]
  ! TIMES           [ shift and go to state 67 ]
  ! DIVIDE          [ shift and go to state 68 ]
  ! MOD             [ shift and go to state 69 ]
  ! EQUALS          [ shift and go to state 71 ]
  ! NOT_EQUALS      [ shift and go to state 72 ]
  ! LESS            [ shift and go to state 73 ]
  ! LESS_EQUAL      [ shift and go to state 74 ]
  ! GREATER         [ shift and go to state 75 ]
  ! GREATER_EQUAL   [ shift and go to state 76 ]
  ! AND             [ shift and go to state 77 ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 101

    (48) binary_exp -> exp POWER exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    PLUS            reduce using rule 48 (binary_exp -> exp POWER exp .)
    MINUS           reduce using rule 48 (binary_exp -> exp POWER exp .)
    TIMES           reduce using rule 48 (binary_exp -> exp POWER exp .)
    DIVIDE          reduce using rule 48 (binary_exp -> exp POWER exp .)
    MOD             reduce using rule 48 (binary_exp -> exp POWER exp .)
    EQUALS          reduce using rule 48 (binary_exp -> exp POWER exp .)
    NOT_EQUALS      reduce using rule 48 (binary_exp -> exp POWER exp .)
    LESS            reduce using rule 48 (binary_exp -> exp POWER exp .)
    LESS_EQUAL      reduce using rule 48 (binary_exp -> exp POWER exp .)
    GREATER         reduce using rule 48 (binary_exp -> exp POWER exp .)
    GREATER_EQUAL   reduce using rule 48 (binary_exp -> exp POWER exp .)
    AND             reduce using rule 48 (binary_exp -> exp POWER exp .)
    OR              reduce using rule 48 (binary_exp -> exp POWER exp .)
    SEMICOLON       reduce using rule 48 (binary_exp -> exp POWER exp .)
    LET             reduce using rule 48 (binary_exp -> exp POWER exp .)
    $end            reduce using rule 48 (binary_exp -> exp POWER exp .)
    RPAREN          reduce using rule 48 (binary_exp -> exp POWER exp .)
    THEN            reduce using rule 48 (binary_exp -> exp POWER exp .)
    DO              reduce using rule 48 (binary_exp -> exp POWER exp .)
    COMMA           reduce using rule 48 (binary_exp -> exp POWER exp .)
    RBRACKET        reduce using rule 48 (binary_exp -> exp POWER exp .)
    ELSE            reduce using rule 48 (binary_exp -> exp POWER exp .)
    BAR             reduce using rule 48 (binary_exp -> exp POWER exp .)
    POWER           shift and go to state 70

  ! POWER           [ reduce using rule 48 (binary_exp -> exp POWER exp .) ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 66 ]
  ! TIMES           [ shift and go to state 67 ]
  ! DIVIDE          [ shift and go to state 68 ]
  ! MOD             [ shift and go to state 69 ]
  ! EQUALS          [ shift and go to state 71 ]
  ! NOT_EQUALS      [ shift and go to state 72 ]
  ! LESS            [ shift and go to state 73 ]
  ! LESS_EQUAL      [ shift and go to state 74 ]
  ! GREATER         [ shift and go to state 75 ]
  ! GREATER_EQUAL   [ shift and go to state 76 ]
  ! AND             [ shift and go to state 77 ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 102

    (49) binary_exp -> exp EQUALS exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    EQUALS          reduce using rule 49 (binary_exp -> exp EQUALS exp .)
    NOT_EQUALS      reduce using rule 49 (binary_exp -> exp EQUALS exp .)
    AND             reduce using rule 49 (binary_exp -> exp EQUALS exp .)
    OR              reduce using rule 49 (binary_exp -> exp EQUALS exp .)
    SEMICOLON       reduce using rule 49 (binary_exp -> exp EQUALS exp .)
    LET             reduce using rule 49 (binary_exp -> exp EQUALS exp .)
    $end            reduce using rule 49 (binary_exp -> exp EQUALS exp .)
    RPAREN          reduce using rule 49 (binary_exp -> exp EQUALS exp .)
    THEN            reduce using rule 49 (binary_exp -> exp EQUALS exp .)
    DO              reduce using rule 49 (binary_exp -> exp EQUALS exp .)
    COMMA           reduce using rule 49 (binary_exp -> exp EQUALS exp .)
    RBRACKET        reduce using rule 49 (binary_exp -> exp EQUALS exp .)
    ELSE            reduce using rule 49 (binary_exp -> exp EQUALS exp .)
    BAR             reduce using rule 49 (binary_exp -> exp EQUALS exp .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POWER           shift and go to state 70
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76

  ! PLUS            [ reduce using rule 49 (binary_exp -> exp EQUALS exp .) ]
  ! MINUS           [ reduce using rule 49 (binary_exp -> exp EQUALS exp .) ]
  ! TIMES           [ reduce using rule 49 (binary_exp -> exp EQUALS exp .) ]
  ! DIVIDE          [ reduce using rule 49 (binary_exp -> exp EQUALS exp .) ]
  ! MOD             [ reduce using rule 49 (binary_exp -> exp EQUALS exp .) ]
  ! POWER           [ reduce using rule 49 (binary_exp -> exp EQUALS exp .) ]
  ! LESS            [ reduce using rule 49 (binary_exp -> exp EQUALS exp .) ]
  ! LESS_EQUAL      [ reduce using rule 49 (binary_exp -> exp EQUALS exp .) ]
  ! GREATER         [ reduce using rule 49 (binary_exp -> exp EQUALS exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 49 (binary_exp -> exp EQUALS exp .) ]
  ! EQUALS          [ shift and go to state 71 ]
  ! NOT_EQUALS      [ shift and go to state 72 ]
  ! AND             [ shift and go to state 77 ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 103

    (50) binary_exp -> exp NOT_EQUALS exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    EQUALS          reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .)
    NOT_EQUALS      reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .)
    AND             reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .)
    OR              reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .)
    SEMICOLON       reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .)
    LET             reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .)
    $end            reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .)
    RPAREN          reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .)
    THEN            reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .)
    DO              reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .)
    COMMA           reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .)
    RBRACKET        reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .)
    ELSE            reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .)
    BAR             reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POWER           shift and go to state 70
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76

  ! PLUS            [ reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! MINUS           [ reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! TIMES           [ reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! DIVIDE          [ reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! MOD             [ reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! POWER           [ reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! LESS            [ reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! LESS_EQUAL      [ reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! GREATER         [ reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! EQUALS          [ shift and go to state 71 ]
  ! NOT_EQUALS      [ shift and go to state 72 ]
  ! AND             [ shift and go to state 77 ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 104

    (51) binary_exp -> exp LESS exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    EQUALS          reduce using rule 51 (binary_exp -> exp LESS exp .)
    NOT_EQUALS      reduce using rule 51 (binary_exp -> exp LESS exp .)
    LESS            reduce using rule 51 (binary_exp -> exp LESS exp .)
    LESS_EQUAL      reduce using rule 51 (binary_exp -> exp LESS exp .)
    GREATER         reduce using rule 51 (binary_exp -> exp LESS exp .)
    GREATER_EQUAL   reduce using rule 51 (binary_exp -> exp LESS exp .)
    AND             reduce using rule 51 (binary_exp -> exp LESS exp .)
    OR              reduce using rule 51 (binary_exp -> exp LESS exp .)
    SEMICOLON       reduce using rule 51 (binary_exp -> exp LESS exp .)
    LET             reduce using rule 51 (binary_exp -> exp LESS exp .)
    $end            reduce using rule 51 (binary_exp -> exp LESS exp .)
    RPAREN          reduce using rule 51 (binary_exp -> exp LESS exp .)
    THEN            reduce using rule 51 (binary_exp -> exp LESS exp .)
    DO              reduce using rule 51 (binary_exp -> exp LESS exp .)
    COMMA           reduce using rule 51 (binary_exp -> exp LESS exp .)
    RBRACKET        reduce using rule 51 (binary_exp -> exp LESS exp .)
    ELSE            reduce using rule 51 (binary_exp -> exp LESS exp .)
    BAR             reduce using rule 51 (binary_exp -> exp LESS exp .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POWER           shift and go to state 70

  ! PLUS            [ reduce using rule 51 (binary_exp -> exp LESS exp .) ]
  ! MINUS           [ reduce using rule 51 (binary_exp -> exp LESS exp .) ]
  ! TIMES           [ reduce using rule 51 (binary_exp -> exp LESS exp .) ]
  ! DIVIDE          [ reduce using rule 51 (binary_exp -> exp LESS exp .) ]
  ! MOD             [ reduce using rule 51 (binary_exp -> exp LESS exp .) ]
  ! POWER           [ reduce using rule 51 (binary_exp -> exp LESS exp .) ]
  ! EQUALS          [ shift and go to state 71 ]
  ! NOT_EQUALS      [ shift and go to state 72 ]
  ! LESS            [ shift and go to state 73 ]
  ! LESS_EQUAL      [ shift and go to state 74 ]
  ! GREATER         [ shift and go to state 75 ]
  ! GREATER_EQUAL   [ shift and go to state 76 ]
  ! AND             [ shift and go to state 77 ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 105

    (52) binary_exp -> exp LESS_EQUAL exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    EQUALS          reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    NOT_EQUALS      reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    LESS            reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    LESS_EQUAL      reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    GREATER         reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    GREATER_EQUAL   reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    AND             reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    OR              reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    SEMICOLON       reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    LET             reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    $end            reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    RPAREN          reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    THEN            reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    DO              reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    COMMA           reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    RBRACKET        reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    ELSE            reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    BAR             reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POWER           shift and go to state 70

  ! PLUS            [ reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .) ]
  ! MINUS           [ reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .) ]
  ! TIMES           [ reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .) ]
  ! DIVIDE          [ reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .) ]
  ! MOD             [ reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .) ]
  ! POWER           [ reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .) ]
  ! EQUALS          [ shift and go to state 71 ]
  ! NOT_EQUALS      [ shift and go to state 72 ]
  ! LESS            [ shift and go to state 73 ]
  ! LESS_EQUAL      [ shift and go to state 74 ]
  ! GREATER         [ shift and go to state 75 ]
  ! GREATER_EQUAL   [ shift and go to state 76 ]
  ! AND             [ shift and go to state 77 ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 106

    (53) binary_exp -> exp GREATER exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    EQUALS          reduce using rule 53 (binary_exp -> exp GREATER exp .)
    NOT_EQUALS      reduce using rule 53 (binary_exp -> exp GREATER exp .)
    LESS            reduce using rule 53 (binary_exp -> exp GREATER exp .)
    LESS_EQUAL      reduce using rule 53 (binary_exp -> exp GREATER exp .)
    GREATER         reduce using rule 53 (binary_exp -> exp GREATER exp .)
    GREATER_EQUAL   reduce using rule 53 (binary_exp -> exp GREATER exp .)
    AND             reduce using rule 53 (binary_exp -> exp GREATER exp .)
    OR              reduce using rule 53 (binary_exp -> exp GREATER exp .)
    SEMICOLON       reduce using rule 53 (binary_exp -> exp GREATER exp .)
    LET             reduce using rule 53 (binary_exp -> exp GREATER exp .)
    $end            reduce using rule 53 (binary_exp -> exp GREATER exp .)
    RPAREN          reduce using rule 53 (binary_exp -> exp GREATER exp .)
    THEN            reduce using rule 53 (binary_exp -> exp GREATER exp .)
    DO              reduce using rule 53 (binary_exp -> exp GREATER exp .)
    COMMA           reduce using rule 53 (binary_exp -> exp GREATER exp .)
    RBRACKET        reduce using rule 53 (binary_exp -> exp GREATER exp .)
    ELSE            reduce using rule 53 (binary_exp -> exp GREATER exp .)
    BAR             reduce using rule 53 (binary_exp -> exp GREATER exp .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POWER           shift and go to state 70

  ! PLUS            [ reduce using rule 53 (binary_exp -> exp GREATER exp .) ]
  ! MINUS           [ reduce using rule 53 (binary_exp -> exp GREATER exp .) ]
  ! TIMES           [ reduce using rule 53 (binary_exp -> exp GREATER exp .) ]
  ! DIVIDE          [ reduce using rule 53 (binary_exp -> exp GREATER exp .) ]
  ! MOD             [ reduce using rule 53 (binary_exp -> exp GREATER exp .) ]
  ! POWER           [ reduce using rule 53 (binary_exp -> exp GREATER exp .) ]
  ! EQUALS          [ shift and go to state 71 ]
  ! NOT_EQUALS      [ shift and go to state 72 ]
  ! LESS            [ shift and go to state 73 ]
  ! LESS_EQUAL      [ shift and go to state 74 ]
  ! GREATER         [ shift and go to state 75 ]
  ! GREATER_EQUAL   [ shift and go to state 76 ]
  ! AND             [ shift and go to state 77 ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 107

    (54) binary_exp -> exp GREATER_EQUAL exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    EQUALS          reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    NOT_EQUALS      reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    LESS            reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    LESS_EQUAL      reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    GREATER         reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    GREATER_EQUAL   reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    AND             reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    OR              reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    SEMICOLON       reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    LET             reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    $end            reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    RPAREN          reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    THEN            reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    DO              reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    COMMA           reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    RBRACKET        reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    ELSE            reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    BAR             reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POWER           shift and go to state 70

  ! PLUS            [ reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .) ]
  ! MINUS           [ reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .) ]
  ! TIMES           [ reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .) ]
  ! DIVIDE          [ reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .) ]
  ! MOD             [ reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .) ]
  ! POWER           [ reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .) ]
  ! EQUALS          [ shift and go to state 71 ]
  ! NOT_EQUALS      [ shift and go to state 72 ]
  ! LESS            [ shift and go to state 73 ]
  ! LESS_EQUAL      [ shift and go to state 74 ]
  ! GREATER         [ shift and go to state 75 ]
  ! GREATER_EQUAL   [ shift and go to state 76 ]
  ! AND             [ shift and go to state 77 ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 108

    (55) binary_exp -> exp AND exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    AND             reduce using rule 55 (binary_exp -> exp AND exp .)
    OR              reduce using rule 55 (binary_exp -> exp AND exp .)
    SEMICOLON       reduce using rule 55 (binary_exp -> exp AND exp .)
    LET             reduce using rule 55 (binary_exp -> exp AND exp .)
    $end            reduce using rule 55 (binary_exp -> exp AND exp .)
    RPAREN          reduce using rule 55 (binary_exp -> exp AND exp .)
    THEN            reduce using rule 55 (binary_exp -> exp AND exp .)
    DO              reduce using rule 55 (binary_exp -> exp AND exp .)
    COMMA           reduce using rule 55 (binary_exp -> exp AND exp .)
    RBRACKET        reduce using rule 55 (binary_exp -> exp AND exp .)
    ELSE            reduce using rule 55 (binary_exp -> exp AND exp .)
    BAR             reduce using rule 55 (binary_exp -> exp AND exp .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POWER           shift and go to state 70
    EQUALS          shift and go to state 71
    NOT_EQUALS      shift and go to state 72
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76

  ! PLUS            [ reduce using rule 55 (binary_exp -> exp AND exp .) ]
  ! MINUS           [ reduce using rule 55 (binary_exp -> exp AND exp .) ]
  ! TIMES           [ reduce using rule 55 (binary_exp -> exp AND exp .) ]
  ! DIVIDE          [ reduce using rule 55 (binary_exp -> exp AND exp .) ]
  ! MOD             [ reduce using rule 55 (binary_exp -> exp AND exp .) ]
  ! POWER           [ reduce using rule 55 (binary_exp -> exp AND exp .) ]
  ! EQUALS          [ reduce using rule 55 (binary_exp -> exp AND exp .) ]
  ! NOT_EQUALS      [ reduce using rule 55 (binary_exp -> exp AND exp .) ]
  ! LESS            [ reduce using rule 55 (binary_exp -> exp AND exp .) ]
  ! LESS_EQUAL      [ reduce using rule 55 (binary_exp -> exp AND exp .) ]
  ! GREATER         [ reduce using rule 55 (binary_exp -> exp AND exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 55 (binary_exp -> exp AND exp .) ]
  ! AND             [ shift and go to state 77 ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 109

    (56) binary_exp -> exp OR exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    OR              reduce using rule 56 (binary_exp -> exp OR exp .)
    SEMICOLON       reduce using rule 56 (binary_exp -> exp OR exp .)
    LET             reduce using rule 56 (binary_exp -> exp OR exp .)
    $end            reduce using rule 56 (binary_exp -> exp OR exp .)
    RPAREN          reduce using rule 56 (binary_exp -> exp OR exp .)
    THEN            reduce using rule 56 (binary_exp -> exp OR exp .)
    DO              reduce using rule 56 (binary_exp -> exp OR exp .)
    COMMA           reduce using rule 56 (binary_exp -> exp OR exp .)
    RBRACKET        reduce using rule 56 (binary_exp -> exp OR exp .)
    ELSE            reduce using rule 56 (binary_exp -> exp OR exp .)
    BAR             reduce using rule 56 (binary_exp -> exp OR exp .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POWER           shift and go to state 70
    EQUALS          shift and go to state 71
    NOT_EQUALS      shift and go to state 72
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76
    AND             shift and go to state 77

  ! PLUS            [ reduce using rule 56 (binary_exp -> exp OR exp .) ]
  ! MINUS           [ reduce using rule 56 (binary_exp -> exp OR exp .) ]
  ! TIMES           [ reduce using rule 56 (binary_exp -> exp OR exp .) ]
  ! DIVIDE          [ reduce using rule 56 (binary_exp -> exp OR exp .) ]
  ! MOD             [ reduce using rule 56 (binary_exp -> exp OR exp .) ]
  ! POWER           [ reduce using rule 56 (binary_exp -> exp OR exp .) ]
  ! EQUALS          [ reduce using rule 56 (binary_exp -> exp OR exp .) ]
  ! NOT_EQUALS      [ reduce using rule 56 (binary_exp -> exp OR exp .) ]
  ! LESS            [ reduce using rule 56 (binary_exp -> exp OR exp .) ]
  ! LESS_EQUAL      [ reduce using rule 56 (binary_exp -> exp OR exp .) ]
  ! GREATER         [ reduce using rule 56 (binary_exp -> exp OR exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 56 (binary_exp -> exp OR exp .) ]
  ! AND             [ reduce using rule 56 (binary_exp -> exp OR exp .) ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 110

    (57) binary_exp -> exp SEMICOLON exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    LET             reduce using rule 57 (binary_exp -> exp SEMICOLON exp .)
    $end            reduce using rule 57 (binary_exp -> exp SEMICOLON exp .)
    RPAREN          reduce using rule 57 (binary_exp -> exp SEMICOLON exp .)
    THEN            reduce using rule 57 (binary_exp -> exp SEMICOLON exp .)
    DO              reduce using rule 57 (binary_exp -> exp SEMICOLON exp .)
    COMMA           reduce using rule 57 (binary_exp -> exp SEMICOLON exp .)
    RBRACKET        reduce using rule 57 (binary_exp -> exp SEMICOLON exp .)
    ELSE            reduce using rule 57 (binary_exp -> exp SEMICOLON exp .)
    BAR             reduce using rule 57 (binary_exp -> exp SEMICOLON exp .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POWER           shift and go to state 70
    EQUALS          shift and go to state 71
    NOT_EQUALS      shift and go to state 72
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    SEMICOLON       shift and go to state 79

  ! PLUS            [ reduce using rule 57 (binary_exp -> exp SEMICOLON exp .) ]
  ! MINUS           [ reduce using rule 57 (binary_exp -> exp SEMICOLON exp .) ]
  ! TIMES           [ reduce using rule 57 (binary_exp -> exp SEMICOLON exp .) ]
  ! DIVIDE          [ reduce using rule 57 (binary_exp -> exp SEMICOLON exp .) ]
  ! MOD             [ reduce using rule 57 (binary_exp -> exp SEMICOLON exp .) ]
  ! POWER           [ reduce using rule 57 (binary_exp -> exp SEMICOLON exp .) ]
  ! EQUALS          [ reduce using rule 57 (binary_exp -> exp SEMICOLON exp .) ]
  ! NOT_EQUALS      [ reduce using rule 57 (binary_exp -> exp SEMICOLON exp .) ]
  ! LESS            [ reduce using rule 57 (binary_exp -> exp SEMICOLON exp .) ]
  ! LESS_EQUAL      [ reduce using rule 57 (binary_exp -> exp SEMICOLON exp .) ]
  ! GREATER         [ reduce using rule 57 (binary_exp -> exp SEMICOLON exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 57 (binary_exp -> exp SEMICOLON exp .) ]
  ! AND             [ reduce using rule 57 (binary_exp -> exp SEMICOLON exp .) ]
  ! OR              [ reduce using rule 57 (binary_exp -> exp SEMICOLON exp .) ]
  ! SEMICOLON       [ reduce using rule 57 (binary_exp -> exp SEMICOLON exp .) ]


state 111

    (73) group -> LPAREN exp RPAREN .

    PLUS            reduce using rule 73 (group -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 73 (group -> LPAREN exp RPAREN .)
    TIMES           reduce using rule 73 (group -> LPAREN exp RPAREN .)
    DIVIDE          reduce using rule 73 (group -> LPAREN exp RPAREN .)
    MOD             reduce using rule 73 (group -> LPAREN exp RPAREN .)
    POWER           reduce using rule 73 (group -> LPAREN exp RPAREN .)
    EQUALS          reduce using rule 73 (group -> LPAREN exp RPAREN .)
    NOT_EQUALS      reduce using rule 73 (group -> LPAREN exp RPAREN .)
    LESS            reduce using rule 73 (group -> LPAREN exp RPAREN .)
    LESS_EQUAL      reduce using rule 73 (group -> LPAREN exp RPAREN .)
    GREATER         reduce using rule 73 (group -> LPAREN exp RPAREN .)
    GREATER_EQUAL   reduce using rule 73 (group -> LPAREN exp RPAREN .)
    AND             reduce using rule 73 (group -> LPAREN exp RPAREN .)
    OR              reduce using rule 73 (group -> LPAREN exp RPAREN .)
    SEMICOLON       reduce using rule 73 (group -> LPAREN exp RPAREN .)
    LET             reduce using rule 73 (group -> LPAREN exp RPAREN .)
    $end            reduce using rule 73 (group -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 73 (group -> LPAREN exp RPAREN .)
    THEN            reduce using rule 73 (group -> LPAREN exp RPAREN .)
    DO              reduce using rule 73 (group -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 73 (group -> LPAREN exp RPAREN .)
    RBRACKET        reduce using rule 73 (group -> LPAREN exp RPAREN .)
    ELSE            reduce using rule 73 (group -> LPAREN exp RPAREN .)
    BAR             reduce using rule 73 (group -> LPAREN exp RPAREN .)


state 112

    (64) assignment -> SET lhs ASSIGN . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs ASSIGN exp
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 32
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    lhs                            shift and go to state 57
    exp                            shift and go to state 124
    variable                       shift and go to state 33
    literal                        shift and go to state 35
    binary_exp                     shift and go to state 36
    unary_exp                      shift and go to state 37
    function_call                  shift and go to state 38
    assignment                     shift and go to state 39
    variable_declaration           shift and go to state 40
    if_then_else                   shift and go to state 41
    if_then                        shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46

state 113

    (67) array_access -> lhs LBRACKET exp . RBRACKET
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    RBRACKET        shift and go to state 125
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POWER           shift and go to state 70
    EQUALS          shift and go to state 71
    NOT_EQUALS      shift and go to state 72
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    SEMICOLON       shift and go to state 79


state 114

    (69) if_then_else -> IF exp THEN . exp ELSE exp
    (70) if_then -> IF exp THEN . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs ASSIGN exp
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 32
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 126
    variable                       shift and go to state 33
    literal                        shift and go to state 35
    binary_exp                     shift and go to state 36
    unary_exp                      shift and go to state 37
    function_call                  shift and go to state 38
    assignment                     shift and go to state 39
    variable_declaration           shift and go to state 40
    if_then_else                   shift and go to state 41
    if_then                        shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 115

    (71) while_loop -> WHILE exp DO . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs ASSIGN exp
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 32
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 127
    variable                       shift and go to state 33
    literal                        shift and go to state 35
    binary_exp                     shift and go to state 36
    unary_exp                      shift and go to state 37
    function_call                  shift and go to state 38
    assignment                     shift and go to state 39
    variable_declaration           shift and go to state 40
    if_then_else                   shift and go to state 41
    if_then                        shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 116

    (72) array_creation -> NEW type LBRACKET . exp BAR exp RBRACKET
    (17) array_type -> type LBRACKET . RBRACKET
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs ASSIGN exp
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    RBRACKET        shift and go to state 61
    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 32
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 128
    variable                       shift and go to state 33
    literal                        shift and go to state 35
    binary_exp                     shift and go to state 36
    unary_exp                      shift and go to state 37
    function_call                  shift and go to state 38
    assignment                     shift and go to state 39
    variable_declaration           shift and go to state 40
    if_then_else                   shift and go to state 41
    if_then                        shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 117

    (19) function_type -> LPAREN type . function_type_tail RPAREN ARROW type
    (17) array_type -> type . LBRACKET RBRACKET
    (20) function_type_tail -> . COMMA type function_type_tail
    (21) function_type_tail -> . empty
    (74) empty -> .

    LBRACKET        shift and go to state 27
    COMMA           shift and go to state 130
    RPAREN          reduce using rule 74 (empty -> .)

    function_type_tail             shift and go to state 129
    empty                          shift and go to state 131

state 118

    (7) function_declaration -> LET ID LPAREN parameters RPAREN COLON function_type ASSIGN . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs ASSIGN exp
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 32
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 132
    variable                       shift and go to state 33
    literal                        shift and go to state 35
    binary_exp                     shift and go to state 36
    unary_exp                      shift and go to state 37
    function_call                  shift and go to state 38
    assignment                     shift and go to state 39
    variable_declaration           shift and go to state 40
    if_then_else                   shift and go to state 41
    if_then                        shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 119

    (18) function_type -> type ARROW . type
    (11) type -> . base_type
    (12) type -> . array_type
    (13) base_type -> . INT_TYPE
    (14) base_type -> . STRING_TYPE
    (15) base_type -> . UNIT_TYPE
    (16) base_type -> . BOOL_TYPE
    (17) array_type -> . type LBRACKET RBRACKET

    INT_TYPE        shift and go to state 19
    STRING_TYPE     shift and go to state 20
    UNIT_TYPE       shift and go to state 21
    BOOL_TYPE       shift and go to state 22

    type                           shift and go to state 133
    base_type                      shift and go to state 17
    array_type                     shift and go to state 18

state 120

    (60) function_call -> variable LPAREN arguments RPAREN .

    PLUS            reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    MINUS           reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    TIMES           reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    DIVIDE          reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    MOD             reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    POWER           reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    EQUALS          reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    NOT_EQUALS      reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    LESS            reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    LESS_EQUAL      reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    GREATER         reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    GREATER_EQUAL   reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    AND             reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    OR              reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    SEMICOLON       reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    LET             reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    $end            reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    THEN            reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    DO              reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    COMMA           reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    RBRACKET        reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    ELSE            reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    BAR             reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)


state 121

    (61) arguments -> exp arguments_tail .

    RPAREN          reduce using rule 61 (arguments -> exp arguments_tail .)


state 122

    (62) arguments_tail -> COMMA . exp arguments_tail
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs ASSIGN exp
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 32
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 134
    variable                       shift and go to state 33
    literal                        shift and go to state 35
    binary_exp                     shift and go to state 36
    unary_exp                      shift and go to state 37
    function_call                  shift and go to state 38
    assignment                     shift and go to state 39
    variable_declaration           shift and go to state 40
    if_then_else                   shift and go to state 41
    if_then                        shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 123

    (63) arguments_tail -> empty .

    RPAREN          reduce using rule 63 (arguments_tail -> empty .)


state 124

    (64) assignment -> SET lhs ASSIGN exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    SEMICOLON       reduce using rule 64 (assignment -> SET lhs ASSIGN exp .)
    LET             reduce using rule 64 (assignment -> SET lhs ASSIGN exp .)
    $end            reduce using rule 64 (assignment -> SET lhs ASSIGN exp .)
    RPAREN          reduce using rule 64 (assignment -> SET lhs ASSIGN exp .)
    THEN            reduce using rule 64 (assignment -> SET lhs ASSIGN exp .)
    DO              reduce using rule 64 (assignment -> SET lhs ASSIGN exp .)
    COMMA           reduce using rule 64 (assignment -> SET lhs ASSIGN exp .)
    RBRACKET        reduce using rule 64 (assignment -> SET lhs ASSIGN exp .)
    ELSE            reduce using rule 64 (assignment -> SET lhs ASSIGN exp .)
    BAR             reduce using rule 64 (assignment -> SET lhs ASSIGN exp .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POWER           shift and go to state 70
    EQUALS          shift and go to state 71
    NOT_EQUALS      shift and go to state 72
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78

  ! PLUS            [ reduce using rule 64 (assignment -> SET lhs ASSIGN exp .) ]
  ! MINUS           [ reduce using rule 64 (assignment -> SET lhs ASSIGN exp .) ]
  ! TIMES           [ reduce using rule 64 (assignment -> SET lhs ASSIGN exp .) ]
  ! DIVIDE          [ reduce using rule 64 (assignment -> SET lhs ASSIGN exp .) ]
  ! MOD             [ reduce using rule 64 (assignment -> SET lhs ASSIGN exp .) ]
  ! POWER           [ reduce using rule 64 (assignment -> SET lhs ASSIGN exp .) ]
  ! EQUALS          [ reduce using rule 64 (assignment -> SET lhs ASSIGN exp .) ]
  ! NOT_EQUALS      [ reduce using rule 64 (assignment -> SET lhs ASSIGN exp .) ]
  ! LESS            [ reduce using rule 64 (assignment -> SET lhs ASSIGN exp .) ]
  ! LESS_EQUAL      [ reduce using rule 64 (assignment -> SET lhs ASSIGN exp .) ]
  ! GREATER         [ reduce using rule 64 (assignment -> SET lhs ASSIGN exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 64 (assignment -> SET lhs ASSIGN exp .) ]
  ! AND             [ reduce using rule 64 (assignment -> SET lhs ASSIGN exp .) ]
  ! OR              [ reduce using rule 64 (assignment -> SET lhs ASSIGN exp .) ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 125

    (67) array_access -> lhs LBRACKET exp RBRACKET .

    PLUS            reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    MINUS           reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    TIMES           reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    DIVIDE          reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    MOD             reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    POWER           reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    EQUALS          reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    NOT_EQUALS      reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    LESS            reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    LESS_EQUAL      reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    GREATER         reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    GREATER_EQUAL   reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    AND             reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    OR              reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    SEMICOLON       reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    LET             reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    $end            reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    THEN            reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    DO              reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    COMMA           reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    RBRACKET        reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    ELSE            reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    BAR             reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    LBRACKET        reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    ASSIGN          reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)


state 126

    (69) if_then_else -> IF exp THEN exp . ELSE exp
    (70) if_then -> IF exp THEN exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    ELSE            shift and go to state 135
    SEMICOLON       reduce using rule 70 (if_then -> IF exp THEN exp .)
    LET             reduce using rule 70 (if_then -> IF exp THEN exp .)
    $end            reduce using rule 70 (if_then -> IF exp THEN exp .)
    RPAREN          reduce using rule 70 (if_then -> IF exp THEN exp .)
    THEN            reduce using rule 70 (if_then -> IF exp THEN exp .)
    DO              reduce using rule 70 (if_then -> IF exp THEN exp .)
    COMMA           reduce using rule 70 (if_then -> IF exp THEN exp .)
    RBRACKET        reduce using rule 70 (if_then -> IF exp THEN exp .)
    BAR             reduce using rule 70 (if_then -> IF exp THEN exp .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POWER           shift and go to state 70
    EQUALS          shift and go to state 71
    NOT_EQUALS      shift and go to state 72
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78

  ! PLUS            [ reduce using rule 70 (if_then -> IF exp THEN exp .) ]
  ! MINUS           [ reduce using rule 70 (if_then -> IF exp THEN exp .) ]
  ! TIMES           [ reduce using rule 70 (if_then -> IF exp THEN exp .) ]
  ! DIVIDE          [ reduce using rule 70 (if_then -> IF exp THEN exp .) ]
  ! MOD             [ reduce using rule 70 (if_then -> IF exp THEN exp .) ]
  ! POWER           [ reduce using rule 70 (if_then -> IF exp THEN exp .) ]
  ! EQUALS          [ reduce using rule 70 (if_then -> IF exp THEN exp .) ]
  ! NOT_EQUALS      [ reduce using rule 70 (if_then -> IF exp THEN exp .) ]
  ! LESS            [ reduce using rule 70 (if_then -> IF exp THEN exp .) ]
  ! LESS_EQUAL      [ reduce using rule 70 (if_then -> IF exp THEN exp .) ]
  ! GREATER         [ reduce using rule 70 (if_then -> IF exp THEN exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 70 (if_then -> IF exp THEN exp .) ]
  ! AND             [ reduce using rule 70 (if_then -> IF exp THEN exp .) ]
  ! OR              [ reduce using rule 70 (if_then -> IF exp THEN exp .) ]
  ! ELSE            [ reduce using rule 70 (if_then -> IF exp THEN exp .) ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 127

    (71) while_loop -> WHILE exp DO exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    SEMICOLON       reduce using rule 71 (while_loop -> WHILE exp DO exp .)
    LET             reduce using rule 71 (while_loop -> WHILE exp DO exp .)
    $end            reduce using rule 71 (while_loop -> WHILE exp DO exp .)
    RPAREN          reduce using rule 71 (while_loop -> WHILE exp DO exp .)
    THEN            reduce using rule 71 (while_loop -> WHILE exp DO exp .)
    DO              reduce using rule 71 (while_loop -> WHILE exp DO exp .)
    COMMA           reduce using rule 71 (while_loop -> WHILE exp DO exp .)
    RBRACKET        reduce using rule 71 (while_loop -> WHILE exp DO exp .)
    ELSE            reduce using rule 71 (while_loop -> WHILE exp DO exp .)
    BAR             reduce using rule 71 (while_loop -> WHILE exp DO exp .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POWER           shift and go to state 70
    EQUALS          shift and go to state 71
    NOT_EQUALS      shift and go to state 72
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78

  ! PLUS            [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! MINUS           [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! TIMES           [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! DIVIDE          [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! MOD             [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! POWER           [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! EQUALS          [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! NOT_EQUALS      [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! LESS            [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! LESS_EQUAL      [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! GREATER         [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! AND             [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! OR              [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 128

    (72) array_creation -> NEW type LBRACKET exp . BAR exp RBRACKET
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    BAR             shift and go to state 136
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POWER           shift and go to state 70
    EQUALS          shift and go to state 71
    NOT_EQUALS      shift and go to state 72
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    SEMICOLON       shift and go to state 79


state 129

    (19) function_type -> LPAREN type function_type_tail . RPAREN ARROW type

    RPAREN          shift and go to state 137


state 130

    (20) function_type_tail -> COMMA . type function_type_tail
    (11) type -> . base_type
    (12) type -> . array_type
    (13) base_type -> . INT_TYPE
    (14) base_type -> . STRING_TYPE
    (15) base_type -> . UNIT_TYPE
    (16) base_type -> . BOOL_TYPE
    (17) array_type -> . type LBRACKET RBRACKET

    INT_TYPE        shift and go to state 19
    STRING_TYPE     shift and go to state 20
    UNIT_TYPE       shift and go to state 21
    BOOL_TYPE       shift and go to state 22

    type                           shift and go to state 138
    base_type                      shift and go to state 17
    array_type                     shift and go to state 18

state 131

    (21) function_type_tail -> empty .

    RPAREN          reduce using rule 21 (function_type_tail -> empty .)


state 132

    (7) function_declaration -> LET ID LPAREN parameters RPAREN COLON function_type ASSIGN exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    LET             reduce using rule 7 (function_declaration -> LET ID LPAREN parameters RPAREN COLON function_type ASSIGN exp .)
    $end            reduce using rule 7 (function_declaration -> LET ID LPAREN parameters RPAREN COLON function_type ASSIGN exp .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POWER           shift and go to state 70
    EQUALS          shift and go to state 71
    NOT_EQUALS      shift and go to state 72
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    SEMICOLON       shift and go to state 79


state 133

    (18) function_type -> type ARROW type .
    (17) array_type -> type . LBRACKET RBRACKET

    ASSIGN          reduce using rule 18 (function_type -> type ARROW type .)
    LBRACKET        shift and go to state 27


state 134

    (62) arguments_tail -> COMMA exp . arguments_tail
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp
    (62) arguments_tail -> . COMMA exp arguments_tail
    (63) arguments_tail -> . empty
    (74) empty -> .

    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POWER           shift and go to state 70
    EQUALS          shift and go to state 71
    NOT_EQUALS      shift and go to state 72
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    SEMICOLON       shift and go to state 79
    COMMA           shift and go to state 122
    RPAREN          reduce using rule 74 (empty -> .)

    arguments_tail                 shift and go to state 139
    empty                          shift and go to state 123

state 135

    (69) if_then_else -> IF exp THEN exp ELSE . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs ASSIGN exp
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 32
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 140
    variable                       shift and go to state 33
    literal                        shift and go to state 35
    binary_exp                     shift and go to state 36
    unary_exp                      shift and go to state 37
    function_call                  shift and go to state 38
    assignment                     shift and go to state 39
    variable_declaration           shift and go to state 40
    if_then_else                   shift and go to state 41
    if_then                        shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 136

    (72) array_creation -> NEW type LBRACKET exp BAR . exp RBRACKET
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs ASSIGN exp
    (68) variable_declaration -> . LET variable COLON type ASSIGN exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 23
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 32
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 141
    variable                       shift and go to state 33
    literal                        shift and go to state 35
    binary_exp                     shift and go to state 36
    unary_exp                      shift and go to state 37
    function_call                  shift and go to state 38
    assignment                     shift and go to state 39
    variable_declaration           shift and go to state 40
    if_then_else                   shift and go to state 41
    if_then                        shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 137

    (19) function_type -> LPAREN type function_type_tail RPAREN . ARROW type

    ARROW           shift and go to state 142


state 138

    (20) function_type_tail -> COMMA type . function_type_tail
    (17) array_type -> type . LBRACKET RBRACKET
    (20) function_type_tail -> . COMMA type function_type_tail
    (21) function_type_tail -> . empty
    (74) empty -> .

    LBRACKET        shift and go to state 27
    COMMA           shift and go to state 130
    RPAREN          reduce using rule 74 (empty -> .)

    function_type_tail             shift and go to state 143
    empty                          shift and go to state 131

state 139

    (62) arguments_tail -> COMMA exp arguments_tail .

    RPAREN          reduce using rule 62 (arguments_tail -> COMMA exp arguments_tail .)


state 140

    (69) if_then_else -> IF exp THEN exp ELSE exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    SEMICOLON       reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .)
    LET             reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .)
    $end            reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .)
    RPAREN          reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .)
    THEN            reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .)
    DO              reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .)
    COMMA           reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .)
    RBRACKET        reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .)
    ELSE            reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .)
    BAR             reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POWER           shift and go to state 70
    EQUALS          shift and go to state 71
    NOT_EQUALS      shift and go to state 72
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78

  ! PLUS            [ reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! MINUS           [ reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! TIMES           [ reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! DIVIDE          [ reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! MOD             [ reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! POWER           [ reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! EQUALS          [ reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! NOT_EQUALS      [ reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! LESS            [ reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! LESS_EQUAL      [ reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! GREATER         [ reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! AND             [ reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! OR              [ reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 141

    (72) array_creation -> NEW type LBRACKET exp BAR exp . RBRACKET
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    RBRACKET        shift and go to state 144
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MOD             shift and go to state 69
    POWER           shift and go to state 70
    EQUALS          shift and go to state 71
    NOT_EQUALS      shift and go to state 72
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    SEMICOLON       shift and go to state 79


state 142

    (19) function_type -> LPAREN type function_type_tail RPAREN ARROW . type
    (11) type -> . base_type
    (12) type -> . array_type
    (13) base_type -> . INT_TYPE
    (14) base_type -> . STRING_TYPE
    (15) base_type -> . UNIT_TYPE
    (16) base_type -> . BOOL_TYPE
    (17) array_type -> . type LBRACKET RBRACKET

    INT_TYPE        shift and go to state 19
    STRING_TYPE     shift and go to state 20
    UNIT_TYPE       shift and go to state 21
    BOOL_TYPE       shift and go to state 22

    type                           shift and go to state 145
    base_type                      shift and go to state 17
    array_type                     shift and go to state 18

state 143

    (20) function_type_tail -> COMMA type function_type_tail .

    RPAREN          reduce using rule 20 (function_type_tail -> COMMA type function_type_tail .)


state 144

    (72) array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .

    PLUS            reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    MINUS           reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    TIMES           reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    DIVIDE          reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    MOD             reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    POWER           reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    EQUALS          reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    NOT_EQUALS      reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    LESS            reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    LESS_EQUAL      reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    GREATER         reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    GREATER_EQUAL   reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    AND             reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    OR              reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    SEMICOLON       reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    LET             reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    $end            reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    RPAREN          reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    THEN            reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    DO              reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    COMMA           reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    RBRACKET        reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    ELSE            reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    BAR             reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)


state 145

    (19) function_type -> LPAREN type function_type_tail RPAREN ARROW type .
    (17) array_type -> type . LBRACKET RBRACKET

    ASSIGN          reduce using rule 19 (function_type -> LPAREN type function_type_tail RPAREN ARROW type .)
    LBRACKET        shift and go to state 27

