Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> declarations
Rule 2     declarations -> declaration declarations_tail
Rule 3     declarations_tail -> declaration declarations_tail
Rule 4     declarations_tail -> empty
Rule 5     declaration -> variable_declaration
Rule 6     declaration -> function_declaration
Rule 7     function_declaration -> LET ID LPAREN parameters RPAREN COLON function_type EQUALS exp
Rule 8     parameters -> variable parameters_tail
Rule 9     parameters_tail -> COMMA variable parameters_tail
Rule 10    parameters_tail -> empty
Rule 11    type -> base_type array_suffix
Rule 12    base_type -> INT_TYPE
Rule 13    base_type -> BOOL_TYPE
Rule 14    base_type -> UNIT_TYPE
Rule 15    base_type -> STRING_TYPE
Rule 16    array_suffix -> LBRACKET RBRACKET array_suffix
Rule 17    array_suffix -> empty
Rule 18    function_type -> type ARROW type
Rule 19    function_type -> LPAREN type function_type_tail RPAREN ARROW type
Rule 20    function_type_tail -> COMMA type function_type_tail
Rule 21    function_type_tail -> empty
Rule 22    exp -> variable
Rule 23    exp -> literal
Rule 24    exp -> binary_exp
Rule 25    exp -> unary_exp
Rule 26    exp -> function_call
Rule 27    exp -> assignment
Rule 28    exp -> variable_declaration
Rule 29    exp -> if_then_else
Rule 30    exp -> if_then
Rule 31    exp -> while_loop
Rule 32    exp -> array_creation
Rule 33    exp -> array_access
Rule 34    exp -> group
Rule 35    variable -> ID
Rule 36    variable -> UNDERSCORE
Rule 37    literal -> INT_LITERAL
Rule 38    literal -> TRUE
Rule 39    literal -> FALSE
Rule 40    literal -> NULL
Rule 41    literal -> UNIT
Rule 42    literal -> STRING_LITERAL
Rule 43    binary_exp -> exp PLUS exp
Rule 44    binary_exp -> exp MINUS exp
Rule 45    binary_exp -> exp TIMES exp
Rule 46    binary_exp -> exp DIVIDE exp
Rule 47    binary_exp -> exp MOD exp
Rule 48    binary_exp -> exp POWER exp
Rule 49    binary_exp -> exp EQUALS exp
Rule 50    binary_exp -> exp NOT_EQUALS exp
Rule 51    binary_exp -> exp LESS exp
Rule 52    binary_exp -> exp LESS_EQUAL exp
Rule 53    binary_exp -> exp GREATER exp
Rule 54    binary_exp -> exp GREATER_EQUAL exp
Rule 55    binary_exp -> exp AND exp
Rule 56    binary_exp -> exp OR exp
Rule 57    binary_exp -> exp SEMICOLON exp
Rule 58    unary_exp -> MINUS exp
Rule 59    unary_exp -> NOT exp
Rule 60    function_call -> variable LPAREN arguments RPAREN
Rule 61    arguments -> exp arguments_tail
Rule 62    arguments_tail -> COMMA exp arguments_tail
Rule 63    arguments_tail -> empty
Rule 64    assignment -> SET lhs EQUALS exp
Rule 65    lhs -> variable
Rule 66    lhs -> array_access
Rule 67    array_access -> lhs LBRACKET exp RBRACKET
Rule 68    variable_declaration -> LET variable COLON type EQUALS exp
Rule 69    if_then_else -> IF exp THEN exp ELSE exp
Rule 70    if_then -> IF exp THEN exp
Rule 71    while_loop -> WHILE exp DO exp
Rule 72    array_creation -> NEW type LBRACKET exp BAR exp RBRACKET
Rule 73    group -> LPAREN exp RPAREN
Rule 74    empty -> <empty>

Terminals, with rules where they appear

AND                  : 55
ARROW                : 18 19
BAR                  : 72
BOOL_TYPE            : 13
COLON                : 7 68
COMMA                : 9 20 62
DIVIDE               : 46
DO                   : 71
ELSE                 : 69
EQUALS               : 7 49 64 68
FALSE                : 39
GREATER              : 53
GREATER_EQUAL        : 54
ID                   : 7 35
IF                   : 69 70
INT_LITERAL          : 37
INT_TYPE             : 12
LBRACKET             : 16 67 72
LESS                 : 51
LESS_EQUAL           : 52
LET                  : 7 68
LPAREN               : 7 19 60 73
MINUS                : 44 58
MOD                  : 47
NEW                  : 72
NOT                  : 59
NOT_EQUALS           : 50
NULL                 : 40
OR                   : 56
PLUS                 : 43
POWER                : 48
RBRACKET             : 16 67 72
RPAREN               : 7 19 60 73
SEMICOLON            : 57
SET                  : 64
STRING_LITERAL       : 42
STRING_TYPE          : 15
THEN                 : 69 70
TIMES                : 45
TRUE                 : 38
UNDERSCORE           : 36
UNIT                 : 41
UNIT_TYPE            : 14
WHILE                : 71
error                : 

Nonterminals, with rules where they appear

arguments            : 60
arguments_tail       : 61 62
array_access         : 33 66
array_creation       : 32
array_suffix         : 11 16
assignment           : 27
base_type            : 11
binary_exp           : 24
declaration          : 2 3
declarations         : 1
declarations_tail    : 2 3
empty                : 4 10 17 21 63
exp                  : 7 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 59 61 62 64 67 68 69 69 69 70 70 71 71 72 72 73
function_call        : 26
function_declaration : 6
function_type        : 7
function_type_tail   : 19 20
group                : 34
if_then              : 30
if_then_else         : 29
lhs                  : 64 67
literal              : 23
parameters           : 7
parameters_tail      : 8 9
program              : 0
type                 : 18 18 19 19 20 68 72
unary_exp            : 25
variable             : 8 9 22 60 65 68
variable_declaration : 5 28
while_loop           : 31

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declarations
    (2) declarations -> . declaration declarations_tail
    (5) declaration -> . variable_declaration
    (6) declaration -> . function_declaration
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (7) function_declaration -> . LET ID LPAREN parameters RPAREN COLON function_type EQUALS exp

    LET             shift and go to state 6

    program                        shift and go to state 1
    declarations                   shift and go to state 2
    declaration                    shift and go to state 3
    variable_declaration           shift and go to state 4
    function_declaration           shift and go to state 5

state 1

    (0) S' -> program .



state 2

    (1) program -> declarations .

    $end            reduce using rule 1 (program -> declarations .)


state 3

    (2) declarations -> declaration . declarations_tail
    (3) declarations_tail -> . declaration declarations_tail
    (4) declarations_tail -> . empty
    (5) declaration -> . variable_declaration
    (6) declaration -> . function_declaration
    (74) empty -> .
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (7) function_declaration -> . LET ID LPAREN parameters RPAREN COLON function_type EQUALS exp

    $end            reduce using rule 74 (empty -> .)
    LET             shift and go to state 6

    declaration                    shift and go to state 7
    declarations_tail              shift and go to state 8
    empty                          shift and go to state 9
    variable_declaration           shift and go to state 4
    function_declaration           shift and go to state 5

state 4

    (5) declaration -> variable_declaration .

    LET             reduce using rule 5 (declaration -> variable_declaration .)
    $end            reduce using rule 5 (declaration -> variable_declaration .)


state 5

    (6) declaration -> function_declaration .

    LET             reduce using rule 6 (declaration -> function_declaration .)
    $end            reduce using rule 6 (declaration -> function_declaration .)


state 6

    (68) variable_declaration -> LET . variable COLON type EQUALS exp
    (7) function_declaration -> LET . ID LPAREN parameters RPAREN COLON function_type EQUALS exp
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE

    ID              shift and go to state 11
    UNDERSCORE      shift and go to state 12

    variable                       shift and go to state 10

state 7

    (3) declarations_tail -> declaration . declarations_tail
    (3) declarations_tail -> . declaration declarations_tail
    (4) declarations_tail -> . empty
    (5) declaration -> . variable_declaration
    (6) declaration -> . function_declaration
    (74) empty -> .
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (7) function_declaration -> . LET ID LPAREN parameters RPAREN COLON function_type EQUALS exp

    $end            reduce using rule 74 (empty -> .)
    LET             shift and go to state 6

    declaration                    shift and go to state 7
    declarations_tail              shift and go to state 13
    empty                          shift and go to state 9
    variable_declaration           shift and go to state 4
    function_declaration           shift and go to state 5

state 8

    (2) declarations -> declaration declarations_tail .

    $end            reduce using rule 2 (declarations -> declaration declarations_tail .)


state 9

    (4) declarations_tail -> empty .

    $end            reduce using rule 4 (declarations_tail -> empty .)


state 10

    (68) variable_declaration -> LET variable . COLON type EQUALS exp

    COLON           shift and go to state 14


state 11

    (7) function_declaration -> LET ID . LPAREN parameters RPAREN COLON function_type EQUALS exp
    (35) variable -> ID .

    LPAREN          shift and go to state 15
    COLON           reduce using rule 35 (variable -> ID .)


state 12

    (36) variable -> UNDERSCORE .

    COLON           reduce using rule 36 (variable -> UNDERSCORE .)
    COMMA           reduce using rule 36 (variable -> UNDERSCORE .)
    RPAREN          reduce using rule 36 (variable -> UNDERSCORE .)
    LPAREN          reduce using rule 36 (variable -> UNDERSCORE .)
    PLUS            reduce using rule 36 (variable -> UNDERSCORE .)
    MINUS           reduce using rule 36 (variable -> UNDERSCORE .)
    TIMES           reduce using rule 36 (variable -> UNDERSCORE .)
    DIVIDE          reduce using rule 36 (variable -> UNDERSCORE .)
    MOD             reduce using rule 36 (variable -> UNDERSCORE .)
    POWER           reduce using rule 36 (variable -> UNDERSCORE .)
    EQUALS          reduce using rule 36 (variable -> UNDERSCORE .)
    NOT_EQUALS      reduce using rule 36 (variable -> UNDERSCORE .)
    LESS            reduce using rule 36 (variable -> UNDERSCORE .)
    LESS_EQUAL      reduce using rule 36 (variable -> UNDERSCORE .)
    GREATER         reduce using rule 36 (variable -> UNDERSCORE .)
    GREATER_EQUAL   reduce using rule 36 (variable -> UNDERSCORE .)
    AND             reduce using rule 36 (variable -> UNDERSCORE .)
    OR              reduce using rule 36 (variable -> UNDERSCORE .)
    SEMICOLON       reduce using rule 36 (variable -> UNDERSCORE .)
    LET             reduce using rule 36 (variable -> UNDERSCORE .)
    $end            reduce using rule 36 (variable -> UNDERSCORE .)
    THEN            reduce using rule 36 (variable -> UNDERSCORE .)
    DO              reduce using rule 36 (variable -> UNDERSCORE .)
    RBRACKET        reduce using rule 36 (variable -> UNDERSCORE .)
    ELSE            reduce using rule 36 (variable -> UNDERSCORE .)
    BAR             reduce using rule 36 (variable -> UNDERSCORE .)
    LBRACKET        reduce using rule 36 (variable -> UNDERSCORE .)


state 13

    (3) declarations_tail -> declaration declarations_tail .

    $end            reduce using rule 3 (declarations_tail -> declaration declarations_tail .)


state 14

    (68) variable_declaration -> LET variable COLON . type EQUALS exp
    (11) type -> . base_type array_suffix
    (12) base_type -> . INT_TYPE
    (13) base_type -> . BOOL_TYPE
    (14) base_type -> . UNIT_TYPE
    (15) base_type -> . STRING_TYPE

    INT_TYPE        shift and go to state 18
    BOOL_TYPE       shift and go to state 19
    UNIT_TYPE       shift and go to state 20
    STRING_TYPE     shift and go to state 21

    type                           shift and go to state 16
    base_type                      shift and go to state 17

state 15

    (7) function_declaration -> LET ID LPAREN . parameters RPAREN COLON function_type EQUALS exp
    (8) parameters -> . variable parameters_tail
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12

    parameters                     shift and go to state 23
    variable                       shift and go to state 24

state 16

    (68) variable_declaration -> LET variable COLON type . EQUALS exp

    EQUALS          shift and go to state 25


state 17

    (11) type -> base_type . array_suffix
    (16) array_suffix -> . LBRACKET RBRACKET array_suffix
    (17) array_suffix -> . empty
    (74) empty -> .

  ! shift/reduce conflict for LBRACKET resolved as shift
    LBRACKET        shift and go to state 27
    EQUALS          reduce using rule 74 (empty -> .)
    ARROW           reduce using rule 74 (empty -> .)
    COMMA           reduce using rule 74 (empty -> .)
    RPAREN          reduce using rule 74 (empty -> .)

  ! LBRACKET        [ reduce using rule 74 (empty -> .) ]

    array_suffix                   shift and go to state 26
    empty                          shift and go to state 28

state 18

    (12) base_type -> INT_TYPE .

    LBRACKET        reduce using rule 12 (base_type -> INT_TYPE .)
    EQUALS          reduce using rule 12 (base_type -> INT_TYPE .)
    ARROW           reduce using rule 12 (base_type -> INT_TYPE .)
    COMMA           reduce using rule 12 (base_type -> INT_TYPE .)
    RPAREN          reduce using rule 12 (base_type -> INT_TYPE .)


state 19

    (13) base_type -> BOOL_TYPE .

    LBRACKET        reduce using rule 13 (base_type -> BOOL_TYPE .)
    EQUALS          reduce using rule 13 (base_type -> BOOL_TYPE .)
    ARROW           reduce using rule 13 (base_type -> BOOL_TYPE .)
    COMMA           reduce using rule 13 (base_type -> BOOL_TYPE .)
    RPAREN          reduce using rule 13 (base_type -> BOOL_TYPE .)


state 20

    (14) base_type -> UNIT_TYPE .

    LBRACKET        reduce using rule 14 (base_type -> UNIT_TYPE .)
    EQUALS          reduce using rule 14 (base_type -> UNIT_TYPE .)
    ARROW           reduce using rule 14 (base_type -> UNIT_TYPE .)
    COMMA           reduce using rule 14 (base_type -> UNIT_TYPE .)
    RPAREN          reduce using rule 14 (base_type -> UNIT_TYPE .)


state 21

    (15) base_type -> STRING_TYPE .

    LBRACKET        reduce using rule 15 (base_type -> STRING_TYPE .)
    EQUALS          reduce using rule 15 (base_type -> STRING_TYPE .)
    ARROW           reduce using rule 15 (base_type -> STRING_TYPE .)
    COMMA           reduce using rule 15 (base_type -> STRING_TYPE .)
    RPAREN          reduce using rule 15 (base_type -> STRING_TYPE .)


state 22

    (35) variable -> ID .

    COMMA           reduce using rule 35 (variable -> ID .)
    RPAREN          reduce using rule 35 (variable -> ID .)
    LPAREN          reduce using rule 35 (variable -> ID .)
    PLUS            reduce using rule 35 (variable -> ID .)
    MINUS           reduce using rule 35 (variable -> ID .)
    TIMES           reduce using rule 35 (variable -> ID .)
    DIVIDE          reduce using rule 35 (variable -> ID .)
    MOD             reduce using rule 35 (variable -> ID .)
    POWER           reduce using rule 35 (variable -> ID .)
    EQUALS          reduce using rule 35 (variable -> ID .)
    NOT_EQUALS      reduce using rule 35 (variable -> ID .)
    LESS            reduce using rule 35 (variable -> ID .)
    LESS_EQUAL      reduce using rule 35 (variable -> ID .)
    GREATER         reduce using rule 35 (variable -> ID .)
    GREATER_EQUAL   reduce using rule 35 (variable -> ID .)
    AND             reduce using rule 35 (variable -> ID .)
    OR              reduce using rule 35 (variable -> ID .)
    SEMICOLON       reduce using rule 35 (variable -> ID .)
    LET             reduce using rule 35 (variable -> ID .)
    $end            reduce using rule 35 (variable -> ID .)
    THEN            reduce using rule 35 (variable -> ID .)
    DO              reduce using rule 35 (variable -> ID .)
    RBRACKET        reduce using rule 35 (variable -> ID .)
    ELSE            reduce using rule 35 (variable -> ID .)
    BAR             reduce using rule 35 (variable -> ID .)
    LBRACKET        reduce using rule 35 (variable -> ID .)
    COLON           reduce using rule 35 (variable -> ID .)


state 23

    (7) function_declaration -> LET ID LPAREN parameters . RPAREN COLON function_type EQUALS exp

    RPAREN          shift and go to state 29


state 24

    (8) parameters -> variable . parameters_tail
    (9) parameters_tail -> . COMMA variable parameters_tail
    (10) parameters_tail -> . empty
    (74) empty -> .

    COMMA           shift and go to state 31
    RPAREN          reduce using rule 74 (empty -> .)

    parameters_tail                shift and go to state 30
    empty                          shift and go to state 32

state 25

    (68) variable_declaration -> LET variable COLON type EQUALS . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs EQUALS exp
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    NULL            shift and go to state 51
    UNIT            shift and go to state 52
    STRING_LITERAL  shift and go to state 53
    MINUS           shift and go to state 54
    NOT             shift and go to state 55
    SET             shift and go to state 57
    LET             shift and go to state 33
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    NEW             shift and go to state 61
    LPAREN          shift and go to state 56

    variable                       shift and go to state 34
    exp                            shift and go to state 35
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    if_then_else                   shift and go to state 42
    if_then                        shift and go to state 43
    while_loop                     shift and go to state 44
    array_creation                 shift and go to state 45
    array_access                   shift and go to state 46
    group                          shift and go to state 47
    lhs                            shift and go to state 58

state 26

    (11) type -> base_type array_suffix .

    EQUALS          reduce using rule 11 (type -> base_type array_suffix .)
    LBRACKET        reduce using rule 11 (type -> base_type array_suffix .)
    ARROW           reduce using rule 11 (type -> base_type array_suffix .)
    COMMA           reduce using rule 11 (type -> base_type array_suffix .)
    RPAREN          reduce using rule 11 (type -> base_type array_suffix .)


state 27

    (16) array_suffix -> LBRACKET . RBRACKET array_suffix

    RBRACKET        shift and go to state 62


state 28

    (17) array_suffix -> empty .

    EQUALS          reduce using rule 17 (array_suffix -> empty .)
    LBRACKET        reduce using rule 17 (array_suffix -> empty .)
    ARROW           reduce using rule 17 (array_suffix -> empty .)
    COMMA           reduce using rule 17 (array_suffix -> empty .)
    RPAREN          reduce using rule 17 (array_suffix -> empty .)


state 29

    (7) function_declaration -> LET ID LPAREN parameters RPAREN . COLON function_type EQUALS exp

    COLON           shift and go to state 63


state 30

    (8) parameters -> variable parameters_tail .

    RPAREN          reduce using rule 8 (parameters -> variable parameters_tail .)


state 31

    (9) parameters_tail -> COMMA . variable parameters_tail
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12

    variable                       shift and go to state 64

state 32

    (10) parameters_tail -> empty .

    RPAREN          reduce using rule 10 (parameters_tail -> empty .)


state 33

    (68) variable_declaration -> LET . variable COLON type EQUALS exp
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12

    variable                       shift and go to state 10

state 34

    (22) exp -> variable .
    (60) function_call -> variable . LPAREN arguments RPAREN
    (65) lhs -> variable .

    PLUS            reduce using rule 22 (exp -> variable .)
    MINUS           reduce using rule 22 (exp -> variable .)
    TIMES           reduce using rule 22 (exp -> variable .)
    DIVIDE          reduce using rule 22 (exp -> variable .)
    MOD             reduce using rule 22 (exp -> variable .)
    POWER           reduce using rule 22 (exp -> variable .)
    EQUALS          reduce using rule 22 (exp -> variable .)
    NOT_EQUALS      reduce using rule 22 (exp -> variable .)
    LESS            reduce using rule 22 (exp -> variable .)
    LESS_EQUAL      reduce using rule 22 (exp -> variable .)
    GREATER         reduce using rule 22 (exp -> variable .)
    GREATER_EQUAL   reduce using rule 22 (exp -> variable .)
    AND             reduce using rule 22 (exp -> variable .)
    OR              reduce using rule 22 (exp -> variable .)
    SEMICOLON       reduce using rule 22 (exp -> variable .)
    LET             reduce using rule 22 (exp -> variable .)
    $end            reduce using rule 22 (exp -> variable .)
    RPAREN          reduce using rule 22 (exp -> variable .)
    THEN            reduce using rule 22 (exp -> variable .)
    DO              reduce using rule 22 (exp -> variable .)
    COMMA           reduce using rule 22 (exp -> variable .)
    RBRACKET        reduce using rule 22 (exp -> variable .)
    ELSE            reduce using rule 22 (exp -> variable .)
    BAR             reduce using rule 22 (exp -> variable .)
    LPAREN          shift and go to state 65
    LBRACKET        reduce using rule 65 (lhs -> variable .)


state 35

    (68) variable_declaration -> LET variable COLON type EQUALS exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    LET             reduce using rule 68 (variable_declaration -> LET variable COLON type EQUALS exp .)
    $end            reduce using rule 68 (variable_declaration -> LET variable COLON type EQUALS exp .)
    EQUALS          reduce using rule 68 (variable_declaration -> LET variable COLON type EQUALS exp .)
    NOT_EQUALS      reduce using rule 68 (variable_declaration -> LET variable COLON type EQUALS exp .)
    AND             reduce using rule 68 (variable_declaration -> LET variable COLON type EQUALS exp .)
    OR              reduce using rule 68 (variable_declaration -> LET variable COLON type EQUALS exp .)
    SEMICOLON       reduce using rule 68 (variable_declaration -> LET variable COLON type EQUALS exp .)
    RPAREN          reduce using rule 68 (variable_declaration -> LET variable COLON type EQUALS exp .)
    THEN            reduce using rule 68 (variable_declaration -> LET variable COLON type EQUALS exp .)
    DO              reduce using rule 68 (variable_declaration -> LET variable COLON type EQUALS exp .)
    COMMA           reduce using rule 68 (variable_declaration -> LET variable COLON type EQUALS exp .)
    RBRACKET        reduce using rule 68 (variable_declaration -> LET variable COLON type EQUALS exp .)
    ELSE            reduce using rule 68 (variable_declaration -> LET variable COLON type EQUALS exp .)
    BAR             reduce using rule 68 (variable_declaration -> LET variable COLON type EQUALS exp .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    MOD             shift and go to state 71
    POWER           shift and go to state 72
    LESS            shift and go to state 74
    LESS_EQUAL      shift and go to state 75
    GREATER         shift and go to state 76
    GREATER_EQUAL   shift and go to state 77

  ! PLUS            [ reduce using rule 68 (variable_declaration -> LET variable COLON type EQUALS exp .) ]
  ! MINUS           [ reduce using rule 68 (variable_declaration -> LET variable COLON type EQUALS exp .) ]
  ! TIMES           [ reduce using rule 68 (variable_declaration -> LET variable COLON type EQUALS exp .) ]
  ! DIVIDE          [ reduce using rule 68 (variable_declaration -> LET variable COLON type EQUALS exp .) ]
  ! MOD             [ reduce using rule 68 (variable_declaration -> LET variable COLON type EQUALS exp .) ]
  ! POWER           [ reduce using rule 68 (variable_declaration -> LET variable COLON type EQUALS exp .) ]
  ! LESS            [ reduce using rule 68 (variable_declaration -> LET variable COLON type EQUALS exp .) ]
  ! LESS_EQUAL      [ reduce using rule 68 (variable_declaration -> LET variable COLON type EQUALS exp .) ]
  ! GREATER         [ reduce using rule 68 (variable_declaration -> LET variable COLON type EQUALS exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 68 (variable_declaration -> LET variable COLON type EQUALS exp .) ]
  ! EQUALS          [ shift and go to state 66 ]
  ! NOT_EQUALS      [ shift and go to state 73 ]
  ! AND             [ shift and go to state 78 ]
  ! OR              [ shift and go to state 79 ]
  ! SEMICOLON       [ shift and go to state 80 ]


state 36

    (23) exp -> literal .

    PLUS            reduce using rule 23 (exp -> literal .)
    MINUS           reduce using rule 23 (exp -> literal .)
    TIMES           reduce using rule 23 (exp -> literal .)
    DIVIDE          reduce using rule 23 (exp -> literal .)
    MOD             reduce using rule 23 (exp -> literal .)
    POWER           reduce using rule 23 (exp -> literal .)
    EQUALS          reduce using rule 23 (exp -> literal .)
    NOT_EQUALS      reduce using rule 23 (exp -> literal .)
    LESS            reduce using rule 23 (exp -> literal .)
    LESS_EQUAL      reduce using rule 23 (exp -> literal .)
    GREATER         reduce using rule 23 (exp -> literal .)
    GREATER_EQUAL   reduce using rule 23 (exp -> literal .)
    AND             reduce using rule 23 (exp -> literal .)
    OR              reduce using rule 23 (exp -> literal .)
    SEMICOLON       reduce using rule 23 (exp -> literal .)
    LET             reduce using rule 23 (exp -> literal .)
    $end            reduce using rule 23 (exp -> literal .)
    RPAREN          reduce using rule 23 (exp -> literal .)
    THEN            reduce using rule 23 (exp -> literal .)
    DO              reduce using rule 23 (exp -> literal .)
    COMMA           reduce using rule 23 (exp -> literal .)
    RBRACKET        reduce using rule 23 (exp -> literal .)
    ELSE            reduce using rule 23 (exp -> literal .)
    BAR             reduce using rule 23 (exp -> literal .)


state 37

    (24) exp -> binary_exp .

    PLUS            reduce using rule 24 (exp -> binary_exp .)
    MINUS           reduce using rule 24 (exp -> binary_exp .)
    TIMES           reduce using rule 24 (exp -> binary_exp .)
    DIVIDE          reduce using rule 24 (exp -> binary_exp .)
    MOD             reduce using rule 24 (exp -> binary_exp .)
    POWER           reduce using rule 24 (exp -> binary_exp .)
    EQUALS          reduce using rule 24 (exp -> binary_exp .)
    NOT_EQUALS      reduce using rule 24 (exp -> binary_exp .)
    LESS            reduce using rule 24 (exp -> binary_exp .)
    LESS_EQUAL      reduce using rule 24 (exp -> binary_exp .)
    GREATER         reduce using rule 24 (exp -> binary_exp .)
    GREATER_EQUAL   reduce using rule 24 (exp -> binary_exp .)
    AND             reduce using rule 24 (exp -> binary_exp .)
    OR              reduce using rule 24 (exp -> binary_exp .)
    SEMICOLON       reduce using rule 24 (exp -> binary_exp .)
    LET             reduce using rule 24 (exp -> binary_exp .)
    $end            reduce using rule 24 (exp -> binary_exp .)
    RPAREN          reduce using rule 24 (exp -> binary_exp .)
    THEN            reduce using rule 24 (exp -> binary_exp .)
    DO              reduce using rule 24 (exp -> binary_exp .)
    COMMA           reduce using rule 24 (exp -> binary_exp .)
    RBRACKET        reduce using rule 24 (exp -> binary_exp .)
    ELSE            reduce using rule 24 (exp -> binary_exp .)
    BAR             reduce using rule 24 (exp -> binary_exp .)


state 38

    (25) exp -> unary_exp .

    PLUS            reduce using rule 25 (exp -> unary_exp .)
    MINUS           reduce using rule 25 (exp -> unary_exp .)
    TIMES           reduce using rule 25 (exp -> unary_exp .)
    DIVIDE          reduce using rule 25 (exp -> unary_exp .)
    MOD             reduce using rule 25 (exp -> unary_exp .)
    POWER           reduce using rule 25 (exp -> unary_exp .)
    EQUALS          reduce using rule 25 (exp -> unary_exp .)
    NOT_EQUALS      reduce using rule 25 (exp -> unary_exp .)
    LESS            reduce using rule 25 (exp -> unary_exp .)
    LESS_EQUAL      reduce using rule 25 (exp -> unary_exp .)
    GREATER         reduce using rule 25 (exp -> unary_exp .)
    GREATER_EQUAL   reduce using rule 25 (exp -> unary_exp .)
    AND             reduce using rule 25 (exp -> unary_exp .)
    OR              reduce using rule 25 (exp -> unary_exp .)
    SEMICOLON       reduce using rule 25 (exp -> unary_exp .)
    LET             reduce using rule 25 (exp -> unary_exp .)
    $end            reduce using rule 25 (exp -> unary_exp .)
    RPAREN          reduce using rule 25 (exp -> unary_exp .)
    THEN            reduce using rule 25 (exp -> unary_exp .)
    DO              reduce using rule 25 (exp -> unary_exp .)
    COMMA           reduce using rule 25 (exp -> unary_exp .)
    RBRACKET        reduce using rule 25 (exp -> unary_exp .)
    ELSE            reduce using rule 25 (exp -> unary_exp .)
    BAR             reduce using rule 25 (exp -> unary_exp .)


state 39

    (26) exp -> function_call .

    PLUS            reduce using rule 26 (exp -> function_call .)
    MINUS           reduce using rule 26 (exp -> function_call .)
    TIMES           reduce using rule 26 (exp -> function_call .)
    DIVIDE          reduce using rule 26 (exp -> function_call .)
    MOD             reduce using rule 26 (exp -> function_call .)
    POWER           reduce using rule 26 (exp -> function_call .)
    EQUALS          reduce using rule 26 (exp -> function_call .)
    NOT_EQUALS      reduce using rule 26 (exp -> function_call .)
    LESS            reduce using rule 26 (exp -> function_call .)
    LESS_EQUAL      reduce using rule 26 (exp -> function_call .)
    GREATER         reduce using rule 26 (exp -> function_call .)
    GREATER_EQUAL   reduce using rule 26 (exp -> function_call .)
    AND             reduce using rule 26 (exp -> function_call .)
    OR              reduce using rule 26 (exp -> function_call .)
    SEMICOLON       reduce using rule 26 (exp -> function_call .)
    LET             reduce using rule 26 (exp -> function_call .)
    $end            reduce using rule 26 (exp -> function_call .)
    RPAREN          reduce using rule 26 (exp -> function_call .)
    THEN            reduce using rule 26 (exp -> function_call .)
    DO              reduce using rule 26 (exp -> function_call .)
    COMMA           reduce using rule 26 (exp -> function_call .)
    RBRACKET        reduce using rule 26 (exp -> function_call .)
    ELSE            reduce using rule 26 (exp -> function_call .)
    BAR             reduce using rule 26 (exp -> function_call .)


state 40

    (27) exp -> assignment .

    PLUS            reduce using rule 27 (exp -> assignment .)
    MINUS           reduce using rule 27 (exp -> assignment .)
    TIMES           reduce using rule 27 (exp -> assignment .)
    DIVIDE          reduce using rule 27 (exp -> assignment .)
    MOD             reduce using rule 27 (exp -> assignment .)
    POWER           reduce using rule 27 (exp -> assignment .)
    EQUALS          reduce using rule 27 (exp -> assignment .)
    NOT_EQUALS      reduce using rule 27 (exp -> assignment .)
    LESS            reduce using rule 27 (exp -> assignment .)
    LESS_EQUAL      reduce using rule 27 (exp -> assignment .)
    GREATER         reduce using rule 27 (exp -> assignment .)
    GREATER_EQUAL   reduce using rule 27 (exp -> assignment .)
    AND             reduce using rule 27 (exp -> assignment .)
    OR              reduce using rule 27 (exp -> assignment .)
    SEMICOLON       reduce using rule 27 (exp -> assignment .)
    LET             reduce using rule 27 (exp -> assignment .)
    $end            reduce using rule 27 (exp -> assignment .)
    RPAREN          reduce using rule 27 (exp -> assignment .)
    THEN            reduce using rule 27 (exp -> assignment .)
    DO              reduce using rule 27 (exp -> assignment .)
    COMMA           reduce using rule 27 (exp -> assignment .)
    RBRACKET        reduce using rule 27 (exp -> assignment .)
    ELSE            reduce using rule 27 (exp -> assignment .)
    BAR             reduce using rule 27 (exp -> assignment .)


state 41

    (28) exp -> variable_declaration .

    PLUS            reduce using rule 28 (exp -> variable_declaration .)
    MINUS           reduce using rule 28 (exp -> variable_declaration .)
    TIMES           reduce using rule 28 (exp -> variable_declaration .)
    DIVIDE          reduce using rule 28 (exp -> variable_declaration .)
    MOD             reduce using rule 28 (exp -> variable_declaration .)
    POWER           reduce using rule 28 (exp -> variable_declaration .)
    EQUALS          reduce using rule 28 (exp -> variable_declaration .)
    NOT_EQUALS      reduce using rule 28 (exp -> variable_declaration .)
    LESS            reduce using rule 28 (exp -> variable_declaration .)
    LESS_EQUAL      reduce using rule 28 (exp -> variable_declaration .)
    GREATER         reduce using rule 28 (exp -> variable_declaration .)
    GREATER_EQUAL   reduce using rule 28 (exp -> variable_declaration .)
    AND             reduce using rule 28 (exp -> variable_declaration .)
    OR              reduce using rule 28 (exp -> variable_declaration .)
    SEMICOLON       reduce using rule 28 (exp -> variable_declaration .)
    LET             reduce using rule 28 (exp -> variable_declaration .)
    $end            reduce using rule 28 (exp -> variable_declaration .)
    RPAREN          reduce using rule 28 (exp -> variable_declaration .)
    THEN            reduce using rule 28 (exp -> variable_declaration .)
    DO              reduce using rule 28 (exp -> variable_declaration .)
    COMMA           reduce using rule 28 (exp -> variable_declaration .)
    RBRACKET        reduce using rule 28 (exp -> variable_declaration .)
    ELSE            reduce using rule 28 (exp -> variable_declaration .)
    BAR             reduce using rule 28 (exp -> variable_declaration .)


state 42

    (29) exp -> if_then_else .

    PLUS            reduce using rule 29 (exp -> if_then_else .)
    MINUS           reduce using rule 29 (exp -> if_then_else .)
    TIMES           reduce using rule 29 (exp -> if_then_else .)
    DIVIDE          reduce using rule 29 (exp -> if_then_else .)
    MOD             reduce using rule 29 (exp -> if_then_else .)
    POWER           reduce using rule 29 (exp -> if_then_else .)
    EQUALS          reduce using rule 29 (exp -> if_then_else .)
    NOT_EQUALS      reduce using rule 29 (exp -> if_then_else .)
    LESS            reduce using rule 29 (exp -> if_then_else .)
    LESS_EQUAL      reduce using rule 29 (exp -> if_then_else .)
    GREATER         reduce using rule 29 (exp -> if_then_else .)
    GREATER_EQUAL   reduce using rule 29 (exp -> if_then_else .)
    AND             reduce using rule 29 (exp -> if_then_else .)
    OR              reduce using rule 29 (exp -> if_then_else .)
    SEMICOLON       reduce using rule 29 (exp -> if_then_else .)
    LET             reduce using rule 29 (exp -> if_then_else .)
    $end            reduce using rule 29 (exp -> if_then_else .)
    RPAREN          reduce using rule 29 (exp -> if_then_else .)
    THEN            reduce using rule 29 (exp -> if_then_else .)
    DO              reduce using rule 29 (exp -> if_then_else .)
    COMMA           reduce using rule 29 (exp -> if_then_else .)
    RBRACKET        reduce using rule 29 (exp -> if_then_else .)
    ELSE            reduce using rule 29 (exp -> if_then_else .)
    BAR             reduce using rule 29 (exp -> if_then_else .)


state 43

    (30) exp -> if_then .

    PLUS            reduce using rule 30 (exp -> if_then .)
    MINUS           reduce using rule 30 (exp -> if_then .)
    TIMES           reduce using rule 30 (exp -> if_then .)
    DIVIDE          reduce using rule 30 (exp -> if_then .)
    MOD             reduce using rule 30 (exp -> if_then .)
    POWER           reduce using rule 30 (exp -> if_then .)
    EQUALS          reduce using rule 30 (exp -> if_then .)
    NOT_EQUALS      reduce using rule 30 (exp -> if_then .)
    LESS            reduce using rule 30 (exp -> if_then .)
    LESS_EQUAL      reduce using rule 30 (exp -> if_then .)
    GREATER         reduce using rule 30 (exp -> if_then .)
    GREATER_EQUAL   reduce using rule 30 (exp -> if_then .)
    AND             reduce using rule 30 (exp -> if_then .)
    OR              reduce using rule 30 (exp -> if_then .)
    SEMICOLON       reduce using rule 30 (exp -> if_then .)
    LET             reduce using rule 30 (exp -> if_then .)
    $end            reduce using rule 30 (exp -> if_then .)
    RPAREN          reduce using rule 30 (exp -> if_then .)
    THEN            reduce using rule 30 (exp -> if_then .)
    DO              reduce using rule 30 (exp -> if_then .)
    COMMA           reduce using rule 30 (exp -> if_then .)
    RBRACKET        reduce using rule 30 (exp -> if_then .)
    ELSE            reduce using rule 30 (exp -> if_then .)
    BAR             reduce using rule 30 (exp -> if_then .)


state 44

    (31) exp -> while_loop .

    PLUS            reduce using rule 31 (exp -> while_loop .)
    MINUS           reduce using rule 31 (exp -> while_loop .)
    TIMES           reduce using rule 31 (exp -> while_loop .)
    DIVIDE          reduce using rule 31 (exp -> while_loop .)
    MOD             reduce using rule 31 (exp -> while_loop .)
    POWER           reduce using rule 31 (exp -> while_loop .)
    EQUALS          reduce using rule 31 (exp -> while_loop .)
    NOT_EQUALS      reduce using rule 31 (exp -> while_loop .)
    LESS            reduce using rule 31 (exp -> while_loop .)
    LESS_EQUAL      reduce using rule 31 (exp -> while_loop .)
    GREATER         reduce using rule 31 (exp -> while_loop .)
    GREATER_EQUAL   reduce using rule 31 (exp -> while_loop .)
    AND             reduce using rule 31 (exp -> while_loop .)
    OR              reduce using rule 31 (exp -> while_loop .)
    SEMICOLON       reduce using rule 31 (exp -> while_loop .)
    LET             reduce using rule 31 (exp -> while_loop .)
    $end            reduce using rule 31 (exp -> while_loop .)
    RPAREN          reduce using rule 31 (exp -> while_loop .)
    THEN            reduce using rule 31 (exp -> while_loop .)
    DO              reduce using rule 31 (exp -> while_loop .)
    COMMA           reduce using rule 31 (exp -> while_loop .)
    RBRACKET        reduce using rule 31 (exp -> while_loop .)
    ELSE            reduce using rule 31 (exp -> while_loop .)
    BAR             reduce using rule 31 (exp -> while_loop .)


state 45

    (32) exp -> array_creation .

    PLUS            reduce using rule 32 (exp -> array_creation .)
    MINUS           reduce using rule 32 (exp -> array_creation .)
    TIMES           reduce using rule 32 (exp -> array_creation .)
    DIVIDE          reduce using rule 32 (exp -> array_creation .)
    MOD             reduce using rule 32 (exp -> array_creation .)
    POWER           reduce using rule 32 (exp -> array_creation .)
    EQUALS          reduce using rule 32 (exp -> array_creation .)
    NOT_EQUALS      reduce using rule 32 (exp -> array_creation .)
    LESS            reduce using rule 32 (exp -> array_creation .)
    LESS_EQUAL      reduce using rule 32 (exp -> array_creation .)
    GREATER         reduce using rule 32 (exp -> array_creation .)
    GREATER_EQUAL   reduce using rule 32 (exp -> array_creation .)
    AND             reduce using rule 32 (exp -> array_creation .)
    OR              reduce using rule 32 (exp -> array_creation .)
    SEMICOLON       reduce using rule 32 (exp -> array_creation .)
    LET             reduce using rule 32 (exp -> array_creation .)
    $end            reduce using rule 32 (exp -> array_creation .)
    RPAREN          reduce using rule 32 (exp -> array_creation .)
    THEN            reduce using rule 32 (exp -> array_creation .)
    DO              reduce using rule 32 (exp -> array_creation .)
    COMMA           reduce using rule 32 (exp -> array_creation .)
    RBRACKET        reduce using rule 32 (exp -> array_creation .)
    ELSE            reduce using rule 32 (exp -> array_creation .)
    BAR             reduce using rule 32 (exp -> array_creation .)


state 46

    (33) exp -> array_access .
    (66) lhs -> array_access .

    PLUS            reduce using rule 33 (exp -> array_access .)
    MINUS           reduce using rule 33 (exp -> array_access .)
    TIMES           reduce using rule 33 (exp -> array_access .)
    DIVIDE          reduce using rule 33 (exp -> array_access .)
    MOD             reduce using rule 33 (exp -> array_access .)
    POWER           reduce using rule 33 (exp -> array_access .)
    EQUALS          reduce using rule 33 (exp -> array_access .)
    NOT_EQUALS      reduce using rule 33 (exp -> array_access .)
    LESS            reduce using rule 33 (exp -> array_access .)
    LESS_EQUAL      reduce using rule 33 (exp -> array_access .)
    GREATER         reduce using rule 33 (exp -> array_access .)
    GREATER_EQUAL   reduce using rule 33 (exp -> array_access .)
    AND             reduce using rule 33 (exp -> array_access .)
    OR              reduce using rule 33 (exp -> array_access .)
    SEMICOLON       reduce using rule 33 (exp -> array_access .)
    LET             reduce using rule 33 (exp -> array_access .)
    $end            reduce using rule 33 (exp -> array_access .)
    RPAREN          reduce using rule 33 (exp -> array_access .)
    THEN            reduce using rule 33 (exp -> array_access .)
    DO              reduce using rule 33 (exp -> array_access .)
    COMMA           reduce using rule 33 (exp -> array_access .)
    RBRACKET        reduce using rule 33 (exp -> array_access .)
    ELSE            reduce using rule 33 (exp -> array_access .)
    BAR             reduce using rule 33 (exp -> array_access .)
    LBRACKET        reduce using rule 66 (lhs -> array_access .)


state 47

    (34) exp -> group .

    PLUS            reduce using rule 34 (exp -> group .)
    MINUS           reduce using rule 34 (exp -> group .)
    TIMES           reduce using rule 34 (exp -> group .)
    DIVIDE          reduce using rule 34 (exp -> group .)
    MOD             reduce using rule 34 (exp -> group .)
    POWER           reduce using rule 34 (exp -> group .)
    EQUALS          reduce using rule 34 (exp -> group .)
    NOT_EQUALS      reduce using rule 34 (exp -> group .)
    LESS            reduce using rule 34 (exp -> group .)
    LESS_EQUAL      reduce using rule 34 (exp -> group .)
    GREATER         reduce using rule 34 (exp -> group .)
    GREATER_EQUAL   reduce using rule 34 (exp -> group .)
    AND             reduce using rule 34 (exp -> group .)
    OR              reduce using rule 34 (exp -> group .)
    SEMICOLON       reduce using rule 34 (exp -> group .)
    LET             reduce using rule 34 (exp -> group .)
    $end            reduce using rule 34 (exp -> group .)
    RPAREN          reduce using rule 34 (exp -> group .)
    THEN            reduce using rule 34 (exp -> group .)
    DO              reduce using rule 34 (exp -> group .)
    COMMA           reduce using rule 34 (exp -> group .)
    RBRACKET        reduce using rule 34 (exp -> group .)
    ELSE            reduce using rule 34 (exp -> group .)
    BAR             reduce using rule 34 (exp -> group .)


state 48

    (37) literal -> INT_LITERAL .

    PLUS            reduce using rule 37 (literal -> INT_LITERAL .)
    MINUS           reduce using rule 37 (literal -> INT_LITERAL .)
    TIMES           reduce using rule 37 (literal -> INT_LITERAL .)
    DIVIDE          reduce using rule 37 (literal -> INT_LITERAL .)
    MOD             reduce using rule 37 (literal -> INT_LITERAL .)
    POWER           reduce using rule 37 (literal -> INT_LITERAL .)
    EQUALS          reduce using rule 37 (literal -> INT_LITERAL .)
    NOT_EQUALS      reduce using rule 37 (literal -> INT_LITERAL .)
    LESS            reduce using rule 37 (literal -> INT_LITERAL .)
    LESS_EQUAL      reduce using rule 37 (literal -> INT_LITERAL .)
    GREATER         reduce using rule 37 (literal -> INT_LITERAL .)
    GREATER_EQUAL   reduce using rule 37 (literal -> INT_LITERAL .)
    AND             reduce using rule 37 (literal -> INT_LITERAL .)
    OR              reduce using rule 37 (literal -> INT_LITERAL .)
    SEMICOLON       reduce using rule 37 (literal -> INT_LITERAL .)
    LET             reduce using rule 37 (literal -> INT_LITERAL .)
    $end            reduce using rule 37 (literal -> INT_LITERAL .)
    RPAREN          reduce using rule 37 (literal -> INT_LITERAL .)
    THEN            reduce using rule 37 (literal -> INT_LITERAL .)
    DO              reduce using rule 37 (literal -> INT_LITERAL .)
    COMMA           reduce using rule 37 (literal -> INT_LITERAL .)
    RBRACKET        reduce using rule 37 (literal -> INT_LITERAL .)
    ELSE            reduce using rule 37 (literal -> INT_LITERAL .)
    BAR             reduce using rule 37 (literal -> INT_LITERAL .)


state 49

    (38) literal -> TRUE .

    PLUS            reduce using rule 38 (literal -> TRUE .)
    MINUS           reduce using rule 38 (literal -> TRUE .)
    TIMES           reduce using rule 38 (literal -> TRUE .)
    DIVIDE          reduce using rule 38 (literal -> TRUE .)
    MOD             reduce using rule 38 (literal -> TRUE .)
    POWER           reduce using rule 38 (literal -> TRUE .)
    EQUALS          reduce using rule 38 (literal -> TRUE .)
    NOT_EQUALS      reduce using rule 38 (literal -> TRUE .)
    LESS            reduce using rule 38 (literal -> TRUE .)
    LESS_EQUAL      reduce using rule 38 (literal -> TRUE .)
    GREATER         reduce using rule 38 (literal -> TRUE .)
    GREATER_EQUAL   reduce using rule 38 (literal -> TRUE .)
    AND             reduce using rule 38 (literal -> TRUE .)
    OR              reduce using rule 38 (literal -> TRUE .)
    SEMICOLON       reduce using rule 38 (literal -> TRUE .)
    LET             reduce using rule 38 (literal -> TRUE .)
    $end            reduce using rule 38 (literal -> TRUE .)
    RPAREN          reduce using rule 38 (literal -> TRUE .)
    THEN            reduce using rule 38 (literal -> TRUE .)
    DO              reduce using rule 38 (literal -> TRUE .)
    COMMA           reduce using rule 38 (literal -> TRUE .)
    RBRACKET        reduce using rule 38 (literal -> TRUE .)
    ELSE            reduce using rule 38 (literal -> TRUE .)
    BAR             reduce using rule 38 (literal -> TRUE .)


state 50

    (39) literal -> FALSE .

    PLUS            reduce using rule 39 (literal -> FALSE .)
    MINUS           reduce using rule 39 (literal -> FALSE .)
    TIMES           reduce using rule 39 (literal -> FALSE .)
    DIVIDE          reduce using rule 39 (literal -> FALSE .)
    MOD             reduce using rule 39 (literal -> FALSE .)
    POWER           reduce using rule 39 (literal -> FALSE .)
    EQUALS          reduce using rule 39 (literal -> FALSE .)
    NOT_EQUALS      reduce using rule 39 (literal -> FALSE .)
    LESS            reduce using rule 39 (literal -> FALSE .)
    LESS_EQUAL      reduce using rule 39 (literal -> FALSE .)
    GREATER         reduce using rule 39 (literal -> FALSE .)
    GREATER_EQUAL   reduce using rule 39 (literal -> FALSE .)
    AND             reduce using rule 39 (literal -> FALSE .)
    OR              reduce using rule 39 (literal -> FALSE .)
    SEMICOLON       reduce using rule 39 (literal -> FALSE .)
    LET             reduce using rule 39 (literal -> FALSE .)
    $end            reduce using rule 39 (literal -> FALSE .)
    RPAREN          reduce using rule 39 (literal -> FALSE .)
    THEN            reduce using rule 39 (literal -> FALSE .)
    DO              reduce using rule 39 (literal -> FALSE .)
    COMMA           reduce using rule 39 (literal -> FALSE .)
    RBRACKET        reduce using rule 39 (literal -> FALSE .)
    ELSE            reduce using rule 39 (literal -> FALSE .)
    BAR             reduce using rule 39 (literal -> FALSE .)


state 51

    (40) literal -> NULL .

    PLUS            reduce using rule 40 (literal -> NULL .)
    MINUS           reduce using rule 40 (literal -> NULL .)
    TIMES           reduce using rule 40 (literal -> NULL .)
    DIVIDE          reduce using rule 40 (literal -> NULL .)
    MOD             reduce using rule 40 (literal -> NULL .)
    POWER           reduce using rule 40 (literal -> NULL .)
    EQUALS          reduce using rule 40 (literal -> NULL .)
    NOT_EQUALS      reduce using rule 40 (literal -> NULL .)
    LESS            reduce using rule 40 (literal -> NULL .)
    LESS_EQUAL      reduce using rule 40 (literal -> NULL .)
    GREATER         reduce using rule 40 (literal -> NULL .)
    GREATER_EQUAL   reduce using rule 40 (literal -> NULL .)
    AND             reduce using rule 40 (literal -> NULL .)
    OR              reduce using rule 40 (literal -> NULL .)
    SEMICOLON       reduce using rule 40 (literal -> NULL .)
    LET             reduce using rule 40 (literal -> NULL .)
    $end            reduce using rule 40 (literal -> NULL .)
    RPAREN          reduce using rule 40 (literal -> NULL .)
    THEN            reduce using rule 40 (literal -> NULL .)
    DO              reduce using rule 40 (literal -> NULL .)
    COMMA           reduce using rule 40 (literal -> NULL .)
    RBRACKET        reduce using rule 40 (literal -> NULL .)
    ELSE            reduce using rule 40 (literal -> NULL .)
    BAR             reduce using rule 40 (literal -> NULL .)


state 52

    (41) literal -> UNIT .

    PLUS            reduce using rule 41 (literal -> UNIT .)
    MINUS           reduce using rule 41 (literal -> UNIT .)
    TIMES           reduce using rule 41 (literal -> UNIT .)
    DIVIDE          reduce using rule 41 (literal -> UNIT .)
    MOD             reduce using rule 41 (literal -> UNIT .)
    POWER           reduce using rule 41 (literal -> UNIT .)
    EQUALS          reduce using rule 41 (literal -> UNIT .)
    NOT_EQUALS      reduce using rule 41 (literal -> UNIT .)
    LESS            reduce using rule 41 (literal -> UNIT .)
    LESS_EQUAL      reduce using rule 41 (literal -> UNIT .)
    GREATER         reduce using rule 41 (literal -> UNIT .)
    GREATER_EQUAL   reduce using rule 41 (literal -> UNIT .)
    AND             reduce using rule 41 (literal -> UNIT .)
    OR              reduce using rule 41 (literal -> UNIT .)
    SEMICOLON       reduce using rule 41 (literal -> UNIT .)
    LET             reduce using rule 41 (literal -> UNIT .)
    $end            reduce using rule 41 (literal -> UNIT .)
    RPAREN          reduce using rule 41 (literal -> UNIT .)
    THEN            reduce using rule 41 (literal -> UNIT .)
    DO              reduce using rule 41 (literal -> UNIT .)
    COMMA           reduce using rule 41 (literal -> UNIT .)
    RBRACKET        reduce using rule 41 (literal -> UNIT .)
    ELSE            reduce using rule 41 (literal -> UNIT .)
    BAR             reduce using rule 41 (literal -> UNIT .)


state 53

    (42) literal -> STRING_LITERAL .

    PLUS            reduce using rule 42 (literal -> STRING_LITERAL .)
    MINUS           reduce using rule 42 (literal -> STRING_LITERAL .)
    TIMES           reduce using rule 42 (literal -> STRING_LITERAL .)
    DIVIDE          reduce using rule 42 (literal -> STRING_LITERAL .)
    MOD             reduce using rule 42 (literal -> STRING_LITERAL .)
    POWER           reduce using rule 42 (literal -> STRING_LITERAL .)
    EQUALS          reduce using rule 42 (literal -> STRING_LITERAL .)
    NOT_EQUALS      reduce using rule 42 (literal -> STRING_LITERAL .)
    LESS            reduce using rule 42 (literal -> STRING_LITERAL .)
    LESS_EQUAL      reduce using rule 42 (literal -> STRING_LITERAL .)
    GREATER         reduce using rule 42 (literal -> STRING_LITERAL .)
    GREATER_EQUAL   reduce using rule 42 (literal -> STRING_LITERAL .)
    AND             reduce using rule 42 (literal -> STRING_LITERAL .)
    OR              reduce using rule 42 (literal -> STRING_LITERAL .)
    SEMICOLON       reduce using rule 42 (literal -> STRING_LITERAL .)
    LET             reduce using rule 42 (literal -> STRING_LITERAL .)
    $end            reduce using rule 42 (literal -> STRING_LITERAL .)
    RPAREN          reduce using rule 42 (literal -> STRING_LITERAL .)
    THEN            reduce using rule 42 (literal -> STRING_LITERAL .)
    DO              reduce using rule 42 (literal -> STRING_LITERAL .)
    COMMA           reduce using rule 42 (literal -> STRING_LITERAL .)
    RBRACKET        reduce using rule 42 (literal -> STRING_LITERAL .)
    ELSE            reduce using rule 42 (literal -> STRING_LITERAL .)
    BAR             reduce using rule 42 (literal -> STRING_LITERAL .)


state 54

    (58) unary_exp -> MINUS . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs EQUALS exp
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    NULL            shift and go to state 51
    UNIT            shift and go to state 52
    STRING_LITERAL  shift and go to state 53
    MINUS           shift and go to state 54
    NOT             shift and go to state 55
    SET             shift and go to state 57
    LET             shift and go to state 33
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    NEW             shift and go to state 61
    LPAREN          shift and go to state 56

    exp                            shift and go to state 81
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    if_then_else                   shift and go to state 42
    if_then                        shift and go to state 43
    while_loop                     shift and go to state 44
    array_creation                 shift and go to state 45
    array_access                   shift and go to state 46
    group                          shift and go to state 47
    lhs                            shift and go to state 58

state 55

    (59) unary_exp -> NOT . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs EQUALS exp
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    NULL            shift and go to state 51
    UNIT            shift and go to state 52
    STRING_LITERAL  shift and go to state 53
    MINUS           shift and go to state 54
    NOT             shift and go to state 55
    SET             shift and go to state 57
    LET             shift and go to state 33
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    NEW             shift and go to state 61
    LPAREN          shift and go to state 56

    exp                            shift and go to state 82
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    if_then_else                   shift and go to state 42
    if_then                        shift and go to state 43
    while_loop                     shift and go to state 44
    array_creation                 shift and go to state 45
    array_access                   shift and go to state 46
    group                          shift and go to state 47
    lhs                            shift and go to state 58

state 56

    (73) group -> LPAREN . exp RPAREN
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs EQUALS exp
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    NULL            shift and go to state 51
    UNIT            shift and go to state 52
    STRING_LITERAL  shift and go to state 53
    MINUS           shift and go to state 54
    NOT             shift and go to state 55
    SET             shift and go to state 57
    LET             shift and go to state 33
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    NEW             shift and go to state 61
    LPAREN          shift and go to state 56

    exp                            shift and go to state 83
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    if_then_else                   shift and go to state 42
    if_then                        shift and go to state 43
    while_loop                     shift and go to state 44
    array_creation                 shift and go to state 45
    array_access                   shift and go to state 46
    group                          shift and go to state 47
    lhs                            shift and go to state 58

state 57

    (64) assignment -> SET . lhs EQUALS exp
    (65) lhs -> . variable
    (66) lhs -> . array_access
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (67) array_access -> . lhs LBRACKET exp RBRACKET

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12

    lhs                            shift and go to state 84
    variable                       shift and go to state 85
    array_access                   shift and go to state 86

state 58

    (67) array_access -> lhs . LBRACKET exp RBRACKET

    LBRACKET        shift and go to state 87


state 59

    (69) if_then_else -> IF . exp THEN exp ELSE exp
    (70) if_then -> IF . exp THEN exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs EQUALS exp
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    NULL            shift and go to state 51
    UNIT            shift and go to state 52
    STRING_LITERAL  shift and go to state 53
    MINUS           shift and go to state 54
    NOT             shift and go to state 55
    SET             shift and go to state 57
    LET             shift and go to state 33
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    NEW             shift and go to state 61
    LPAREN          shift and go to state 56

    exp                            shift and go to state 88
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    if_then_else                   shift and go to state 42
    if_then                        shift and go to state 43
    while_loop                     shift and go to state 44
    array_creation                 shift and go to state 45
    array_access                   shift and go to state 46
    group                          shift and go to state 47
    lhs                            shift and go to state 58

state 60

    (71) while_loop -> WHILE . exp DO exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs EQUALS exp
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    NULL            shift and go to state 51
    UNIT            shift and go to state 52
    STRING_LITERAL  shift and go to state 53
    MINUS           shift and go to state 54
    NOT             shift and go to state 55
    SET             shift and go to state 57
    LET             shift and go to state 33
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    NEW             shift and go to state 61
    LPAREN          shift and go to state 56

    exp                            shift and go to state 89
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    if_then_else                   shift and go to state 42
    if_then                        shift and go to state 43
    while_loop                     shift and go to state 44
    array_creation                 shift and go to state 45
    array_access                   shift and go to state 46
    group                          shift and go to state 47
    lhs                            shift and go to state 58

state 61

    (72) array_creation -> NEW . type LBRACKET exp BAR exp RBRACKET
    (11) type -> . base_type array_suffix
    (12) base_type -> . INT_TYPE
    (13) base_type -> . BOOL_TYPE
    (14) base_type -> . UNIT_TYPE
    (15) base_type -> . STRING_TYPE

    INT_TYPE        shift and go to state 18
    BOOL_TYPE       shift and go to state 19
    UNIT_TYPE       shift and go to state 20
    STRING_TYPE     shift and go to state 21

    type                           shift and go to state 90
    base_type                      shift and go to state 17

state 62

    (16) array_suffix -> LBRACKET RBRACKET . array_suffix
    (16) array_suffix -> . LBRACKET RBRACKET array_suffix
    (17) array_suffix -> . empty
    (74) empty -> .

  ! shift/reduce conflict for LBRACKET resolved as shift
    LBRACKET        shift and go to state 27
    EQUALS          reduce using rule 74 (empty -> .)
    ARROW           reduce using rule 74 (empty -> .)
    COMMA           reduce using rule 74 (empty -> .)
    RPAREN          reduce using rule 74 (empty -> .)

  ! LBRACKET        [ reduce using rule 74 (empty -> .) ]

    array_suffix                   shift and go to state 91
    empty                          shift and go to state 28

state 63

    (7) function_declaration -> LET ID LPAREN parameters RPAREN COLON . function_type EQUALS exp
    (18) function_type -> . type ARROW type
    (19) function_type -> . LPAREN type function_type_tail RPAREN ARROW type
    (11) type -> . base_type array_suffix
    (12) base_type -> . INT_TYPE
    (13) base_type -> . BOOL_TYPE
    (14) base_type -> . UNIT_TYPE
    (15) base_type -> . STRING_TYPE

    LPAREN          shift and go to state 92
    INT_TYPE        shift and go to state 18
    BOOL_TYPE       shift and go to state 19
    UNIT_TYPE       shift and go to state 20
    STRING_TYPE     shift and go to state 21

    function_type                  shift and go to state 93
    type                           shift and go to state 94
    base_type                      shift and go to state 17

state 64

    (9) parameters_tail -> COMMA variable . parameters_tail
    (9) parameters_tail -> . COMMA variable parameters_tail
    (10) parameters_tail -> . empty
    (74) empty -> .

    COMMA           shift and go to state 31
    RPAREN          reduce using rule 74 (empty -> .)

    parameters_tail                shift and go to state 95
    empty                          shift and go to state 32

state 65

    (60) function_call -> variable LPAREN . arguments RPAREN
    (61) arguments -> . exp arguments_tail
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs EQUALS exp
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    NULL            shift and go to state 51
    UNIT            shift and go to state 52
    STRING_LITERAL  shift and go to state 53
    MINUS           shift and go to state 54
    NOT             shift and go to state 55
    SET             shift and go to state 57
    LET             shift and go to state 33
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    NEW             shift and go to state 61
    LPAREN          shift and go to state 56

    variable                       shift and go to state 34
    arguments                      shift and go to state 96
    exp                            shift and go to state 97
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    if_then_else                   shift and go to state 42
    if_then                        shift and go to state 43
    while_loop                     shift and go to state 44
    array_creation                 shift and go to state 45
    array_access                   shift and go to state 46
    group                          shift and go to state 47
    lhs                            shift and go to state 58

state 66

    (49) binary_exp -> exp EQUALS . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs EQUALS exp
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    NULL            shift and go to state 51
    UNIT            shift and go to state 52
    STRING_LITERAL  shift and go to state 53
    MINUS           shift and go to state 54
    NOT             shift and go to state 55
    SET             shift and go to state 57
    LET             shift and go to state 33
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    NEW             shift and go to state 61
    LPAREN          shift and go to state 56

    exp                            shift and go to state 98
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    if_then_else                   shift and go to state 42
    if_then                        shift and go to state 43
    while_loop                     shift and go to state 44
    array_creation                 shift and go to state 45
    array_access                   shift and go to state 46
    group                          shift and go to state 47
    lhs                            shift and go to state 58

state 67

    (43) binary_exp -> exp PLUS . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs EQUALS exp
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    NULL            shift and go to state 51
    UNIT            shift and go to state 52
    STRING_LITERAL  shift and go to state 53
    MINUS           shift and go to state 54
    NOT             shift and go to state 55
    SET             shift and go to state 57
    LET             shift and go to state 33
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    NEW             shift and go to state 61
    LPAREN          shift and go to state 56

    exp                            shift and go to state 99
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    if_then_else                   shift and go to state 42
    if_then                        shift and go to state 43
    while_loop                     shift and go to state 44
    array_creation                 shift and go to state 45
    array_access                   shift and go to state 46
    group                          shift and go to state 47
    lhs                            shift and go to state 58

state 68

    (44) binary_exp -> exp MINUS . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs EQUALS exp
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    NULL            shift and go to state 51
    UNIT            shift and go to state 52
    STRING_LITERAL  shift and go to state 53
    MINUS           shift and go to state 54
    NOT             shift and go to state 55
    SET             shift and go to state 57
    LET             shift and go to state 33
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    NEW             shift and go to state 61
    LPAREN          shift and go to state 56

    exp                            shift and go to state 100
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    if_then_else                   shift and go to state 42
    if_then                        shift and go to state 43
    while_loop                     shift and go to state 44
    array_creation                 shift and go to state 45
    array_access                   shift and go to state 46
    group                          shift and go to state 47
    lhs                            shift and go to state 58

state 69

    (45) binary_exp -> exp TIMES . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs EQUALS exp
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    NULL            shift and go to state 51
    UNIT            shift and go to state 52
    STRING_LITERAL  shift and go to state 53
    MINUS           shift and go to state 54
    NOT             shift and go to state 55
    SET             shift and go to state 57
    LET             shift and go to state 33
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    NEW             shift and go to state 61
    LPAREN          shift and go to state 56

    exp                            shift and go to state 101
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    if_then_else                   shift and go to state 42
    if_then                        shift and go to state 43
    while_loop                     shift and go to state 44
    array_creation                 shift and go to state 45
    array_access                   shift and go to state 46
    group                          shift and go to state 47
    lhs                            shift and go to state 58

state 70

    (46) binary_exp -> exp DIVIDE . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs EQUALS exp
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    NULL            shift and go to state 51
    UNIT            shift and go to state 52
    STRING_LITERAL  shift and go to state 53
    MINUS           shift and go to state 54
    NOT             shift and go to state 55
    SET             shift and go to state 57
    LET             shift and go to state 33
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    NEW             shift and go to state 61
    LPAREN          shift and go to state 56

    exp                            shift and go to state 102
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    if_then_else                   shift and go to state 42
    if_then                        shift and go to state 43
    while_loop                     shift and go to state 44
    array_creation                 shift and go to state 45
    array_access                   shift and go to state 46
    group                          shift and go to state 47
    lhs                            shift and go to state 58

state 71

    (47) binary_exp -> exp MOD . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs EQUALS exp
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    NULL            shift and go to state 51
    UNIT            shift and go to state 52
    STRING_LITERAL  shift and go to state 53
    MINUS           shift and go to state 54
    NOT             shift and go to state 55
    SET             shift and go to state 57
    LET             shift and go to state 33
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    NEW             shift and go to state 61
    LPAREN          shift and go to state 56

    exp                            shift and go to state 103
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    if_then_else                   shift and go to state 42
    if_then                        shift and go to state 43
    while_loop                     shift and go to state 44
    array_creation                 shift and go to state 45
    array_access                   shift and go to state 46
    group                          shift and go to state 47
    lhs                            shift and go to state 58

state 72

    (48) binary_exp -> exp POWER . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs EQUALS exp
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    NULL            shift and go to state 51
    UNIT            shift and go to state 52
    STRING_LITERAL  shift and go to state 53
    MINUS           shift and go to state 54
    NOT             shift and go to state 55
    SET             shift and go to state 57
    LET             shift and go to state 33
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    NEW             shift and go to state 61
    LPAREN          shift and go to state 56

    exp                            shift and go to state 104
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    if_then_else                   shift and go to state 42
    if_then                        shift and go to state 43
    while_loop                     shift and go to state 44
    array_creation                 shift and go to state 45
    array_access                   shift and go to state 46
    group                          shift and go to state 47
    lhs                            shift and go to state 58

state 73

    (50) binary_exp -> exp NOT_EQUALS . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs EQUALS exp
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    NULL            shift and go to state 51
    UNIT            shift and go to state 52
    STRING_LITERAL  shift and go to state 53
    MINUS           shift and go to state 54
    NOT             shift and go to state 55
    SET             shift and go to state 57
    LET             shift and go to state 33
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    NEW             shift and go to state 61
    LPAREN          shift and go to state 56

    exp                            shift and go to state 105
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    if_then_else                   shift and go to state 42
    if_then                        shift and go to state 43
    while_loop                     shift and go to state 44
    array_creation                 shift and go to state 45
    array_access                   shift and go to state 46
    group                          shift and go to state 47
    lhs                            shift and go to state 58

state 74

    (51) binary_exp -> exp LESS . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs EQUALS exp
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    NULL            shift and go to state 51
    UNIT            shift and go to state 52
    STRING_LITERAL  shift and go to state 53
    MINUS           shift and go to state 54
    NOT             shift and go to state 55
    SET             shift and go to state 57
    LET             shift and go to state 33
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    NEW             shift and go to state 61
    LPAREN          shift and go to state 56

    exp                            shift and go to state 106
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    if_then_else                   shift and go to state 42
    if_then                        shift and go to state 43
    while_loop                     shift and go to state 44
    array_creation                 shift and go to state 45
    array_access                   shift and go to state 46
    group                          shift and go to state 47
    lhs                            shift and go to state 58

state 75

    (52) binary_exp -> exp LESS_EQUAL . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs EQUALS exp
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    NULL            shift and go to state 51
    UNIT            shift and go to state 52
    STRING_LITERAL  shift and go to state 53
    MINUS           shift and go to state 54
    NOT             shift and go to state 55
    SET             shift and go to state 57
    LET             shift and go to state 33
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    NEW             shift and go to state 61
    LPAREN          shift and go to state 56

    exp                            shift and go to state 107
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    if_then_else                   shift and go to state 42
    if_then                        shift and go to state 43
    while_loop                     shift and go to state 44
    array_creation                 shift and go to state 45
    array_access                   shift and go to state 46
    group                          shift and go to state 47
    lhs                            shift and go to state 58

state 76

    (53) binary_exp -> exp GREATER . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs EQUALS exp
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    NULL            shift and go to state 51
    UNIT            shift and go to state 52
    STRING_LITERAL  shift and go to state 53
    MINUS           shift and go to state 54
    NOT             shift and go to state 55
    SET             shift and go to state 57
    LET             shift and go to state 33
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    NEW             shift and go to state 61
    LPAREN          shift and go to state 56

    exp                            shift and go to state 108
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    if_then_else                   shift and go to state 42
    if_then                        shift and go to state 43
    while_loop                     shift and go to state 44
    array_creation                 shift and go to state 45
    array_access                   shift and go to state 46
    group                          shift and go to state 47
    lhs                            shift and go to state 58

state 77

    (54) binary_exp -> exp GREATER_EQUAL . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs EQUALS exp
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    NULL            shift and go to state 51
    UNIT            shift and go to state 52
    STRING_LITERAL  shift and go to state 53
    MINUS           shift and go to state 54
    NOT             shift and go to state 55
    SET             shift and go to state 57
    LET             shift and go to state 33
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    NEW             shift and go to state 61
    LPAREN          shift and go to state 56

    exp                            shift and go to state 109
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    if_then_else                   shift and go to state 42
    if_then                        shift and go to state 43
    while_loop                     shift and go to state 44
    array_creation                 shift and go to state 45
    array_access                   shift and go to state 46
    group                          shift and go to state 47
    lhs                            shift and go to state 58

state 78

    (55) binary_exp -> exp AND . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs EQUALS exp
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    NULL            shift and go to state 51
    UNIT            shift and go to state 52
    STRING_LITERAL  shift and go to state 53
    MINUS           shift and go to state 54
    NOT             shift and go to state 55
    SET             shift and go to state 57
    LET             shift and go to state 33
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    NEW             shift and go to state 61
    LPAREN          shift and go to state 56

    exp                            shift and go to state 110
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    if_then_else                   shift and go to state 42
    if_then                        shift and go to state 43
    while_loop                     shift and go to state 44
    array_creation                 shift and go to state 45
    array_access                   shift and go to state 46
    group                          shift and go to state 47
    lhs                            shift and go to state 58

state 79

    (56) binary_exp -> exp OR . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs EQUALS exp
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    NULL            shift and go to state 51
    UNIT            shift and go to state 52
    STRING_LITERAL  shift and go to state 53
    MINUS           shift and go to state 54
    NOT             shift and go to state 55
    SET             shift and go to state 57
    LET             shift and go to state 33
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    NEW             shift and go to state 61
    LPAREN          shift and go to state 56

    exp                            shift and go to state 111
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    if_then_else                   shift and go to state 42
    if_then                        shift and go to state 43
    while_loop                     shift and go to state 44
    array_creation                 shift and go to state 45
    array_access                   shift and go to state 46
    group                          shift and go to state 47
    lhs                            shift and go to state 58

state 80

    (57) binary_exp -> exp SEMICOLON . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs EQUALS exp
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    NULL            shift and go to state 51
    UNIT            shift and go to state 52
    STRING_LITERAL  shift and go to state 53
    MINUS           shift and go to state 54
    NOT             shift and go to state 55
    SET             shift and go to state 57
    LET             shift and go to state 33
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    NEW             shift and go to state 61
    LPAREN          shift and go to state 56

    exp                            shift and go to state 112
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    if_then_else                   shift and go to state 42
    if_then                        shift and go to state 43
    while_loop                     shift and go to state 44
    array_creation                 shift and go to state 45
    array_access                   shift and go to state 46
    group                          shift and go to state 47
    lhs                            shift and go to state 58

state 81

    (58) unary_exp -> MINUS exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    PLUS            reduce using rule 58 (unary_exp -> MINUS exp .)
    MINUS           reduce using rule 58 (unary_exp -> MINUS exp .)
    TIMES           reduce using rule 58 (unary_exp -> MINUS exp .)
    DIVIDE          reduce using rule 58 (unary_exp -> MINUS exp .)
    MOD             reduce using rule 58 (unary_exp -> MINUS exp .)
    POWER           reduce using rule 58 (unary_exp -> MINUS exp .)
    EQUALS          reduce using rule 58 (unary_exp -> MINUS exp .)
    NOT_EQUALS      reduce using rule 58 (unary_exp -> MINUS exp .)
    LESS            reduce using rule 58 (unary_exp -> MINUS exp .)
    LESS_EQUAL      reduce using rule 58 (unary_exp -> MINUS exp .)
    GREATER         reduce using rule 58 (unary_exp -> MINUS exp .)
    GREATER_EQUAL   reduce using rule 58 (unary_exp -> MINUS exp .)
    AND             reduce using rule 58 (unary_exp -> MINUS exp .)
    OR              reduce using rule 58 (unary_exp -> MINUS exp .)
    SEMICOLON       reduce using rule 58 (unary_exp -> MINUS exp .)
    LET             reduce using rule 58 (unary_exp -> MINUS exp .)
    $end            reduce using rule 58 (unary_exp -> MINUS exp .)
    RPAREN          reduce using rule 58 (unary_exp -> MINUS exp .)
    THEN            reduce using rule 58 (unary_exp -> MINUS exp .)
    DO              reduce using rule 58 (unary_exp -> MINUS exp .)
    COMMA           reduce using rule 58 (unary_exp -> MINUS exp .)
    RBRACKET        reduce using rule 58 (unary_exp -> MINUS exp .)
    ELSE            reduce using rule 58 (unary_exp -> MINUS exp .)
    BAR             reduce using rule 58 (unary_exp -> MINUS exp .)

  ! PLUS            [ shift and go to state 67 ]
  ! MINUS           [ shift and go to state 68 ]
  ! TIMES           [ shift and go to state 69 ]
  ! DIVIDE          [ shift and go to state 70 ]
  ! MOD             [ shift and go to state 71 ]
  ! POWER           [ shift and go to state 72 ]
  ! EQUALS          [ shift and go to state 66 ]
  ! NOT_EQUALS      [ shift and go to state 73 ]
  ! LESS            [ shift and go to state 74 ]
  ! LESS_EQUAL      [ shift and go to state 75 ]
  ! GREATER         [ shift and go to state 76 ]
  ! GREATER_EQUAL   [ shift and go to state 77 ]
  ! AND             [ shift and go to state 78 ]
  ! OR              [ shift and go to state 79 ]
  ! SEMICOLON       [ shift and go to state 80 ]


state 82

    (59) unary_exp -> NOT exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    PLUS            reduce using rule 59 (unary_exp -> NOT exp .)
    MINUS           reduce using rule 59 (unary_exp -> NOT exp .)
    TIMES           reduce using rule 59 (unary_exp -> NOT exp .)
    DIVIDE          reduce using rule 59 (unary_exp -> NOT exp .)
    MOD             reduce using rule 59 (unary_exp -> NOT exp .)
    POWER           reduce using rule 59 (unary_exp -> NOT exp .)
    EQUALS          reduce using rule 59 (unary_exp -> NOT exp .)
    NOT_EQUALS      reduce using rule 59 (unary_exp -> NOT exp .)
    LESS            reduce using rule 59 (unary_exp -> NOT exp .)
    LESS_EQUAL      reduce using rule 59 (unary_exp -> NOT exp .)
    GREATER         reduce using rule 59 (unary_exp -> NOT exp .)
    GREATER_EQUAL   reduce using rule 59 (unary_exp -> NOT exp .)
    AND             reduce using rule 59 (unary_exp -> NOT exp .)
    OR              reduce using rule 59 (unary_exp -> NOT exp .)
    SEMICOLON       reduce using rule 59 (unary_exp -> NOT exp .)
    LET             reduce using rule 59 (unary_exp -> NOT exp .)
    $end            reduce using rule 59 (unary_exp -> NOT exp .)
    RPAREN          reduce using rule 59 (unary_exp -> NOT exp .)
    THEN            reduce using rule 59 (unary_exp -> NOT exp .)
    DO              reduce using rule 59 (unary_exp -> NOT exp .)
    COMMA           reduce using rule 59 (unary_exp -> NOT exp .)
    RBRACKET        reduce using rule 59 (unary_exp -> NOT exp .)
    ELSE            reduce using rule 59 (unary_exp -> NOT exp .)
    BAR             reduce using rule 59 (unary_exp -> NOT exp .)

  ! PLUS            [ shift and go to state 67 ]
  ! MINUS           [ shift and go to state 68 ]
  ! TIMES           [ shift and go to state 69 ]
  ! DIVIDE          [ shift and go to state 70 ]
  ! MOD             [ shift and go to state 71 ]
  ! POWER           [ shift and go to state 72 ]
  ! EQUALS          [ shift and go to state 66 ]
  ! NOT_EQUALS      [ shift and go to state 73 ]
  ! LESS            [ shift and go to state 74 ]
  ! LESS_EQUAL      [ shift and go to state 75 ]
  ! GREATER         [ shift and go to state 76 ]
  ! GREATER_EQUAL   [ shift and go to state 77 ]
  ! AND             [ shift and go to state 78 ]
  ! OR              [ shift and go to state 79 ]
  ! SEMICOLON       [ shift and go to state 80 ]


state 83

    (73) group -> LPAREN exp . RPAREN
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    RPAREN          shift and go to state 113
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    MOD             shift and go to state 71
    POWER           shift and go to state 72
    EQUALS          shift and go to state 66
    NOT_EQUALS      shift and go to state 73
    LESS            shift and go to state 74
    LESS_EQUAL      shift and go to state 75
    GREATER         shift and go to state 76
    GREATER_EQUAL   shift and go to state 77
    AND             shift and go to state 78
    OR              shift and go to state 79
    SEMICOLON       shift and go to state 80


state 84

    (64) assignment -> SET lhs . EQUALS exp
    (67) array_access -> lhs . LBRACKET exp RBRACKET

    EQUALS          shift and go to state 114
    LBRACKET        shift and go to state 87


state 85

    (65) lhs -> variable .

    EQUALS          reduce using rule 65 (lhs -> variable .)
    LBRACKET        reduce using rule 65 (lhs -> variable .)


state 86

    (66) lhs -> array_access .

    EQUALS          reduce using rule 66 (lhs -> array_access .)
    LBRACKET        reduce using rule 66 (lhs -> array_access .)


state 87

    (67) array_access -> lhs LBRACKET . exp RBRACKET
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs EQUALS exp
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    NULL            shift and go to state 51
    UNIT            shift and go to state 52
    STRING_LITERAL  shift and go to state 53
    MINUS           shift and go to state 54
    NOT             shift and go to state 55
    SET             shift and go to state 57
    LET             shift and go to state 33
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    NEW             shift and go to state 61
    LPAREN          shift and go to state 56

    lhs                            shift and go to state 58
    exp                            shift and go to state 115
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    if_then_else                   shift and go to state 42
    if_then                        shift and go to state 43
    while_loop                     shift and go to state 44
    array_creation                 shift and go to state 45
    array_access                   shift and go to state 46
    group                          shift and go to state 47

state 88

    (69) if_then_else -> IF exp . THEN exp ELSE exp
    (70) if_then -> IF exp . THEN exp
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    THEN            shift and go to state 116
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    MOD             shift and go to state 71
    POWER           shift and go to state 72
    EQUALS          shift and go to state 66
    NOT_EQUALS      shift and go to state 73
    LESS            shift and go to state 74
    LESS_EQUAL      shift and go to state 75
    GREATER         shift and go to state 76
    GREATER_EQUAL   shift and go to state 77
    AND             shift and go to state 78
    OR              shift and go to state 79
    SEMICOLON       shift and go to state 80


state 89

    (71) while_loop -> WHILE exp . DO exp
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    DO              shift and go to state 117
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    MOD             shift and go to state 71
    POWER           shift and go to state 72
    EQUALS          shift and go to state 66
    NOT_EQUALS      shift and go to state 73
    LESS            shift and go to state 74
    LESS_EQUAL      shift and go to state 75
    GREATER         shift and go to state 76
    GREATER_EQUAL   shift and go to state 77
    AND             shift and go to state 78
    OR              shift and go to state 79
    SEMICOLON       shift and go to state 80


state 90

    (72) array_creation -> NEW type . LBRACKET exp BAR exp RBRACKET

    LBRACKET        shift and go to state 118


state 91

    (16) array_suffix -> LBRACKET RBRACKET array_suffix .

    EQUALS          reduce using rule 16 (array_suffix -> LBRACKET RBRACKET array_suffix .)
    LBRACKET        reduce using rule 16 (array_suffix -> LBRACKET RBRACKET array_suffix .)
    ARROW           reduce using rule 16 (array_suffix -> LBRACKET RBRACKET array_suffix .)
    COMMA           reduce using rule 16 (array_suffix -> LBRACKET RBRACKET array_suffix .)
    RPAREN          reduce using rule 16 (array_suffix -> LBRACKET RBRACKET array_suffix .)


state 92

    (19) function_type -> LPAREN . type function_type_tail RPAREN ARROW type
    (11) type -> . base_type array_suffix
    (12) base_type -> . INT_TYPE
    (13) base_type -> . BOOL_TYPE
    (14) base_type -> . UNIT_TYPE
    (15) base_type -> . STRING_TYPE

    INT_TYPE        shift and go to state 18
    BOOL_TYPE       shift and go to state 19
    UNIT_TYPE       shift and go to state 20
    STRING_TYPE     shift and go to state 21

    type                           shift and go to state 119
    base_type                      shift and go to state 17

state 93

    (7) function_declaration -> LET ID LPAREN parameters RPAREN COLON function_type . EQUALS exp

    EQUALS          shift and go to state 120


state 94

    (18) function_type -> type . ARROW type

    ARROW           shift and go to state 121


state 95

    (9) parameters_tail -> COMMA variable parameters_tail .

    RPAREN          reduce using rule 9 (parameters_tail -> COMMA variable parameters_tail .)


state 96

    (60) function_call -> variable LPAREN arguments . RPAREN

    RPAREN          shift and go to state 122


state 97

    (61) arguments -> exp . arguments_tail
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp
    (62) arguments_tail -> . COMMA exp arguments_tail
    (63) arguments_tail -> . empty
    (74) empty -> .

    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    MOD             shift and go to state 71
    POWER           shift and go to state 72
    EQUALS          shift and go to state 66
    NOT_EQUALS      shift and go to state 73
    LESS            shift and go to state 74
    LESS_EQUAL      shift and go to state 75
    GREATER         shift and go to state 76
    GREATER_EQUAL   shift and go to state 77
    AND             shift and go to state 78
    OR              shift and go to state 79
    SEMICOLON       shift and go to state 80
    COMMA           shift and go to state 124
    RPAREN          reduce using rule 74 (empty -> .)

    arguments_tail                 shift and go to state 123
    empty                          shift and go to state 125

state 98

    (49) binary_exp -> exp EQUALS exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    EQUALS          reduce using rule 49 (binary_exp -> exp EQUALS exp .)
    NOT_EQUALS      reduce using rule 49 (binary_exp -> exp EQUALS exp .)
    AND             reduce using rule 49 (binary_exp -> exp EQUALS exp .)
    OR              reduce using rule 49 (binary_exp -> exp EQUALS exp .)
    SEMICOLON       reduce using rule 49 (binary_exp -> exp EQUALS exp .)
    LET             reduce using rule 49 (binary_exp -> exp EQUALS exp .)
    $end            reduce using rule 49 (binary_exp -> exp EQUALS exp .)
    RPAREN          reduce using rule 49 (binary_exp -> exp EQUALS exp .)
    THEN            reduce using rule 49 (binary_exp -> exp EQUALS exp .)
    DO              reduce using rule 49 (binary_exp -> exp EQUALS exp .)
    COMMA           reduce using rule 49 (binary_exp -> exp EQUALS exp .)
    RBRACKET        reduce using rule 49 (binary_exp -> exp EQUALS exp .)
    ELSE            reduce using rule 49 (binary_exp -> exp EQUALS exp .)
    BAR             reduce using rule 49 (binary_exp -> exp EQUALS exp .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    MOD             shift and go to state 71
    POWER           shift and go to state 72
    LESS            shift and go to state 74
    LESS_EQUAL      shift and go to state 75
    GREATER         shift and go to state 76
    GREATER_EQUAL   shift and go to state 77

  ! PLUS            [ reduce using rule 49 (binary_exp -> exp EQUALS exp .) ]
  ! MINUS           [ reduce using rule 49 (binary_exp -> exp EQUALS exp .) ]
  ! TIMES           [ reduce using rule 49 (binary_exp -> exp EQUALS exp .) ]
  ! DIVIDE          [ reduce using rule 49 (binary_exp -> exp EQUALS exp .) ]
  ! MOD             [ reduce using rule 49 (binary_exp -> exp EQUALS exp .) ]
  ! POWER           [ reduce using rule 49 (binary_exp -> exp EQUALS exp .) ]
  ! LESS            [ reduce using rule 49 (binary_exp -> exp EQUALS exp .) ]
  ! LESS_EQUAL      [ reduce using rule 49 (binary_exp -> exp EQUALS exp .) ]
  ! GREATER         [ reduce using rule 49 (binary_exp -> exp EQUALS exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 49 (binary_exp -> exp EQUALS exp .) ]
  ! EQUALS          [ shift and go to state 66 ]
  ! NOT_EQUALS      [ shift and go to state 73 ]
  ! AND             [ shift and go to state 78 ]
  ! OR              [ shift and go to state 79 ]
  ! SEMICOLON       [ shift and go to state 80 ]


state 99

    (43) binary_exp -> exp PLUS exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    PLUS            reduce using rule 43 (binary_exp -> exp PLUS exp .)
    MINUS           reduce using rule 43 (binary_exp -> exp PLUS exp .)
    EQUALS          reduce using rule 43 (binary_exp -> exp PLUS exp .)
    NOT_EQUALS      reduce using rule 43 (binary_exp -> exp PLUS exp .)
    LESS            reduce using rule 43 (binary_exp -> exp PLUS exp .)
    LESS_EQUAL      reduce using rule 43 (binary_exp -> exp PLUS exp .)
    GREATER         reduce using rule 43 (binary_exp -> exp PLUS exp .)
    GREATER_EQUAL   reduce using rule 43 (binary_exp -> exp PLUS exp .)
    AND             reduce using rule 43 (binary_exp -> exp PLUS exp .)
    OR              reduce using rule 43 (binary_exp -> exp PLUS exp .)
    SEMICOLON       reduce using rule 43 (binary_exp -> exp PLUS exp .)
    LET             reduce using rule 43 (binary_exp -> exp PLUS exp .)
    $end            reduce using rule 43 (binary_exp -> exp PLUS exp .)
    RPAREN          reduce using rule 43 (binary_exp -> exp PLUS exp .)
    THEN            reduce using rule 43 (binary_exp -> exp PLUS exp .)
    DO              reduce using rule 43 (binary_exp -> exp PLUS exp .)
    COMMA           reduce using rule 43 (binary_exp -> exp PLUS exp .)
    RBRACKET        reduce using rule 43 (binary_exp -> exp PLUS exp .)
    ELSE            reduce using rule 43 (binary_exp -> exp PLUS exp .)
    BAR             reduce using rule 43 (binary_exp -> exp PLUS exp .)
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    MOD             shift and go to state 71
    POWER           shift and go to state 72

  ! TIMES           [ reduce using rule 43 (binary_exp -> exp PLUS exp .) ]
  ! DIVIDE          [ reduce using rule 43 (binary_exp -> exp PLUS exp .) ]
  ! MOD             [ reduce using rule 43 (binary_exp -> exp PLUS exp .) ]
  ! POWER           [ reduce using rule 43 (binary_exp -> exp PLUS exp .) ]
  ! PLUS            [ shift and go to state 67 ]
  ! MINUS           [ shift and go to state 68 ]
  ! EQUALS          [ shift and go to state 66 ]
  ! NOT_EQUALS      [ shift and go to state 73 ]
  ! LESS            [ shift and go to state 74 ]
  ! LESS_EQUAL      [ shift and go to state 75 ]
  ! GREATER         [ shift and go to state 76 ]
  ! GREATER_EQUAL   [ shift and go to state 77 ]
  ! AND             [ shift and go to state 78 ]
  ! OR              [ shift and go to state 79 ]
  ! SEMICOLON       [ shift and go to state 80 ]


state 100

    (44) binary_exp -> exp MINUS exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    PLUS            reduce using rule 44 (binary_exp -> exp MINUS exp .)
    MINUS           reduce using rule 44 (binary_exp -> exp MINUS exp .)
    EQUALS          reduce using rule 44 (binary_exp -> exp MINUS exp .)
    NOT_EQUALS      reduce using rule 44 (binary_exp -> exp MINUS exp .)
    LESS            reduce using rule 44 (binary_exp -> exp MINUS exp .)
    LESS_EQUAL      reduce using rule 44 (binary_exp -> exp MINUS exp .)
    GREATER         reduce using rule 44 (binary_exp -> exp MINUS exp .)
    GREATER_EQUAL   reduce using rule 44 (binary_exp -> exp MINUS exp .)
    AND             reduce using rule 44 (binary_exp -> exp MINUS exp .)
    OR              reduce using rule 44 (binary_exp -> exp MINUS exp .)
    SEMICOLON       reduce using rule 44 (binary_exp -> exp MINUS exp .)
    LET             reduce using rule 44 (binary_exp -> exp MINUS exp .)
    $end            reduce using rule 44 (binary_exp -> exp MINUS exp .)
    RPAREN          reduce using rule 44 (binary_exp -> exp MINUS exp .)
    THEN            reduce using rule 44 (binary_exp -> exp MINUS exp .)
    DO              reduce using rule 44 (binary_exp -> exp MINUS exp .)
    COMMA           reduce using rule 44 (binary_exp -> exp MINUS exp .)
    RBRACKET        reduce using rule 44 (binary_exp -> exp MINUS exp .)
    ELSE            reduce using rule 44 (binary_exp -> exp MINUS exp .)
    BAR             reduce using rule 44 (binary_exp -> exp MINUS exp .)
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    MOD             shift and go to state 71
    POWER           shift and go to state 72

  ! TIMES           [ reduce using rule 44 (binary_exp -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 44 (binary_exp -> exp MINUS exp .) ]
  ! MOD             [ reduce using rule 44 (binary_exp -> exp MINUS exp .) ]
  ! POWER           [ reduce using rule 44 (binary_exp -> exp MINUS exp .) ]
  ! PLUS            [ shift and go to state 67 ]
  ! MINUS           [ shift and go to state 68 ]
  ! EQUALS          [ shift and go to state 66 ]
  ! NOT_EQUALS      [ shift and go to state 73 ]
  ! LESS            [ shift and go to state 74 ]
  ! LESS_EQUAL      [ shift and go to state 75 ]
  ! GREATER         [ shift and go to state 76 ]
  ! GREATER_EQUAL   [ shift and go to state 77 ]
  ! AND             [ shift and go to state 78 ]
  ! OR              [ shift and go to state 79 ]
  ! SEMICOLON       [ shift and go to state 80 ]


state 101

    (45) binary_exp -> exp TIMES exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    PLUS            reduce using rule 45 (binary_exp -> exp TIMES exp .)
    MINUS           reduce using rule 45 (binary_exp -> exp TIMES exp .)
    TIMES           reduce using rule 45 (binary_exp -> exp TIMES exp .)
    DIVIDE          reduce using rule 45 (binary_exp -> exp TIMES exp .)
    MOD             reduce using rule 45 (binary_exp -> exp TIMES exp .)
    EQUALS          reduce using rule 45 (binary_exp -> exp TIMES exp .)
    NOT_EQUALS      reduce using rule 45 (binary_exp -> exp TIMES exp .)
    LESS            reduce using rule 45 (binary_exp -> exp TIMES exp .)
    LESS_EQUAL      reduce using rule 45 (binary_exp -> exp TIMES exp .)
    GREATER         reduce using rule 45 (binary_exp -> exp TIMES exp .)
    GREATER_EQUAL   reduce using rule 45 (binary_exp -> exp TIMES exp .)
    AND             reduce using rule 45 (binary_exp -> exp TIMES exp .)
    OR              reduce using rule 45 (binary_exp -> exp TIMES exp .)
    SEMICOLON       reduce using rule 45 (binary_exp -> exp TIMES exp .)
    LET             reduce using rule 45 (binary_exp -> exp TIMES exp .)
    $end            reduce using rule 45 (binary_exp -> exp TIMES exp .)
    RPAREN          reduce using rule 45 (binary_exp -> exp TIMES exp .)
    THEN            reduce using rule 45 (binary_exp -> exp TIMES exp .)
    DO              reduce using rule 45 (binary_exp -> exp TIMES exp .)
    COMMA           reduce using rule 45 (binary_exp -> exp TIMES exp .)
    RBRACKET        reduce using rule 45 (binary_exp -> exp TIMES exp .)
    ELSE            reduce using rule 45 (binary_exp -> exp TIMES exp .)
    BAR             reduce using rule 45 (binary_exp -> exp TIMES exp .)
    POWER           shift and go to state 72

  ! POWER           [ reduce using rule 45 (binary_exp -> exp TIMES exp .) ]
  ! PLUS            [ shift and go to state 67 ]
  ! MINUS           [ shift and go to state 68 ]
  ! TIMES           [ shift and go to state 69 ]
  ! DIVIDE          [ shift and go to state 70 ]
  ! MOD             [ shift and go to state 71 ]
  ! EQUALS          [ shift and go to state 66 ]
  ! NOT_EQUALS      [ shift and go to state 73 ]
  ! LESS            [ shift and go to state 74 ]
  ! LESS_EQUAL      [ shift and go to state 75 ]
  ! GREATER         [ shift and go to state 76 ]
  ! GREATER_EQUAL   [ shift and go to state 77 ]
  ! AND             [ shift and go to state 78 ]
  ! OR              [ shift and go to state 79 ]
  ! SEMICOLON       [ shift and go to state 80 ]


state 102

    (46) binary_exp -> exp DIVIDE exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    PLUS            reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    MINUS           reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    TIMES           reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    DIVIDE          reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    MOD             reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    EQUALS          reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    NOT_EQUALS      reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    LESS            reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    LESS_EQUAL      reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    GREATER         reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    GREATER_EQUAL   reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    AND             reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    OR              reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    SEMICOLON       reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    LET             reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    $end            reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    RPAREN          reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    THEN            reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    DO              reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    COMMA           reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    RBRACKET        reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    ELSE            reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    BAR             reduce using rule 46 (binary_exp -> exp DIVIDE exp .)
    POWER           shift and go to state 72

  ! POWER           [ reduce using rule 46 (binary_exp -> exp DIVIDE exp .) ]
  ! PLUS            [ shift and go to state 67 ]
  ! MINUS           [ shift and go to state 68 ]
  ! TIMES           [ shift and go to state 69 ]
  ! DIVIDE          [ shift and go to state 70 ]
  ! MOD             [ shift and go to state 71 ]
  ! EQUALS          [ shift and go to state 66 ]
  ! NOT_EQUALS      [ shift and go to state 73 ]
  ! LESS            [ shift and go to state 74 ]
  ! LESS_EQUAL      [ shift and go to state 75 ]
  ! GREATER         [ shift and go to state 76 ]
  ! GREATER_EQUAL   [ shift and go to state 77 ]
  ! AND             [ shift and go to state 78 ]
  ! OR              [ shift and go to state 79 ]
  ! SEMICOLON       [ shift and go to state 80 ]


state 103

    (47) binary_exp -> exp MOD exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    PLUS            reduce using rule 47 (binary_exp -> exp MOD exp .)
    MINUS           reduce using rule 47 (binary_exp -> exp MOD exp .)
    TIMES           reduce using rule 47 (binary_exp -> exp MOD exp .)
    DIVIDE          reduce using rule 47 (binary_exp -> exp MOD exp .)
    MOD             reduce using rule 47 (binary_exp -> exp MOD exp .)
    EQUALS          reduce using rule 47 (binary_exp -> exp MOD exp .)
    NOT_EQUALS      reduce using rule 47 (binary_exp -> exp MOD exp .)
    LESS            reduce using rule 47 (binary_exp -> exp MOD exp .)
    LESS_EQUAL      reduce using rule 47 (binary_exp -> exp MOD exp .)
    GREATER         reduce using rule 47 (binary_exp -> exp MOD exp .)
    GREATER_EQUAL   reduce using rule 47 (binary_exp -> exp MOD exp .)
    AND             reduce using rule 47 (binary_exp -> exp MOD exp .)
    OR              reduce using rule 47 (binary_exp -> exp MOD exp .)
    SEMICOLON       reduce using rule 47 (binary_exp -> exp MOD exp .)
    LET             reduce using rule 47 (binary_exp -> exp MOD exp .)
    $end            reduce using rule 47 (binary_exp -> exp MOD exp .)
    RPAREN          reduce using rule 47 (binary_exp -> exp MOD exp .)
    THEN            reduce using rule 47 (binary_exp -> exp MOD exp .)
    DO              reduce using rule 47 (binary_exp -> exp MOD exp .)
    COMMA           reduce using rule 47 (binary_exp -> exp MOD exp .)
    RBRACKET        reduce using rule 47 (binary_exp -> exp MOD exp .)
    ELSE            reduce using rule 47 (binary_exp -> exp MOD exp .)
    BAR             reduce using rule 47 (binary_exp -> exp MOD exp .)
    POWER           shift and go to state 72

  ! POWER           [ reduce using rule 47 (binary_exp -> exp MOD exp .) ]
  ! PLUS            [ shift and go to state 67 ]
  ! MINUS           [ shift and go to state 68 ]
  ! TIMES           [ shift and go to state 69 ]
  ! DIVIDE          [ shift and go to state 70 ]
  ! MOD             [ shift and go to state 71 ]
  ! EQUALS          [ shift and go to state 66 ]
  ! NOT_EQUALS      [ shift and go to state 73 ]
  ! LESS            [ shift and go to state 74 ]
  ! LESS_EQUAL      [ shift and go to state 75 ]
  ! GREATER         [ shift and go to state 76 ]
  ! GREATER_EQUAL   [ shift and go to state 77 ]
  ! AND             [ shift and go to state 78 ]
  ! OR              [ shift and go to state 79 ]
  ! SEMICOLON       [ shift and go to state 80 ]


state 104

    (48) binary_exp -> exp POWER exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    PLUS            reduce using rule 48 (binary_exp -> exp POWER exp .)
    MINUS           reduce using rule 48 (binary_exp -> exp POWER exp .)
    TIMES           reduce using rule 48 (binary_exp -> exp POWER exp .)
    DIVIDE          reduce using rule 48 (binary_exp -> exp POWER exp .)
    MOD             reduce using rule 48 (binary_exp -> exp POWER exp .)
    EQUALS          reduce using rule 48 (binary_exp -> exp POWER exp .)
    NOT_EQUALS      reduce using rule 48 (binary_exp -> exp POWER exp .)
    LESS            reduce using rule 48 (binary_exp -> exp POWER exp .)
    LESS_EQUAL      reduce using rule 48 (binary_exp -> exp POWER exp .)
    GREATER         reduce using rule 48 (binary_exp -> exp POWER exp .)
    GREATER_EQUAL   reduce using rule 48 (binary_exp -> exp POWER exp .)
    AND             reduce using rule 48 (binary_exp -> exp POWER exp .)
    OR              reduce using rule 48 (binary_exp -> exp POWER exp .)
    SEMICOLON       reduce using rule 48 (binary_exp -> exp POWER exp .)
    LET             reduce using rule 48 (binary_exp -> exp POWER exp .)
    $end            reduce using rule 48 (binary_exp -> exp POWER exp .)
    RPAREN          reduce using rule 48 (binary_exp -> exp POWER exp .)
    THEN            reduce using rule 48 (binary_exp -> exp POWER exp .)
    DO              reduce using rule 48 (binary_exp -> exp POWER exp .)
    COMMA           reduce using rule 48 (binary_exp -> exp POWER exp .)
    RBRACKET        reduce using rule 48 (binary_exp -> exp POWER exp .)
    ELSE            reduce using rule 48 (binary_exp -> exp POWER exp .)
    BAR             reduce using rule 48 (binary_exp -> exp POWER exp .)
    POWER           shift and go to state 72

  ! POWER           [ reduce using rule 48 (binary_exp -> exp POWER exp .) ]
  ! PLUS            [ shift and go to state 67 ]
  ! MINUS           [ shift and go to state 68 ]
  ! TIMES           [ shift and go to state 69 ]
  ! DIVIDE          [ shift and go to state 70 ]
  ! MOD             [ shift and go to state 71 ]
  ! EQUALS          [ shift and go to state 66 ]
  ! NOT_EQUALS      [ shift and go to state 73 ]
  ! LESS            [ shift and go to state 74 ]
  ! LESS_EQUAL      [ shift and go to state 75 ]
  ! GREATER         [ shift and go to state 76 ]
  ! GREATER_EQUAL   [ shift and go to state 77 ]
  ! AND             [ shift and go to state 78 ]
  ! OR              [ shift and go to state 79 ]
  ! SEMICOLON       [ shift and go to state 80 ]


state 105

    (50) binary_exp -> exp NOT_EQUALS exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    EQUALS          reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .)
    NOT_EQUALS      reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .)
    AND             reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .)
    OR              reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .)
    SEMICOLON       reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .)
    LET             reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .)
    $end            reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .)
    RPAREN          reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .)
    THEN            reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .)
    DO              reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .)
    COMMA           reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .)
    RBRACKET        reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .)
    ELSE            reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .)
    BAR             reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    MOD             shift and go to state 71
    POWER           shift and go to state 72
    LESS            shift and go to state 74
    LESS_EQUAL      shift and go to state 75
    GREATER         shift and go to state 76
    GREATER_EQUAL   shift and go to state 77

  ! PLUS            [ reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! MINUS           [ reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! TIMES           [ reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! DIVIDE          [ reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! MOD             [ reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! POWER           [ reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! LESS            [ reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! LESS_EQUAL      [ reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! GREATER         [ reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 50 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! EQUALS          [ shift and go to state 66 ]
  ! NOT_EQUALS      [ shift and go to state 73 ]
  ! AND             [ shift and go to state 78 ]
  ! OR              [ shift and go to state 79 ]
  ! SEMICOLON       [ shift and go to state 80 ]


state 106

    (51) binary_exp -> exp LESS exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    EQUALS          reduce using rule 51 (binary_exp -> exp LESS exp .)
    NOT_EQUALS      reduce using rule 51 (binary_exp -> exp LESS exp .)
    LESS            reduce using rule 51 (binary_exp -> exp LESS exp .)
    LESS_EQUAL      reduce using rule 51 (binary_exp -> exp LESS exp .)
    GREATER         reduce using rule 51 (binary_exp -> exp LESS exp .)
    GREATER_EQUAL   reduce using rule 51 (binary_exp -> exp LESS exp .)
    AND             reduce using rule 51 (binary_exp -> exp LESS exp .)
    OR              reduce using rule 51 (binary_exp -> exp LESS exp .)
    SEMICOLON       reduce using rule 51 (binary_exp -> exp LESS exp .)
    LET             reduce using rule 51 (binary_exp -> exp LESS exp .)
    $end            reduce using rule 51 (binary_exp -> exp LESS exp .)
    RPAREN          reduce using rule 51 (binary_exp -> exp LESS exp .)
    THEN            reduce using rule 51 (binary_exp -> exp LESS exp .)
    DO              reduce using rule 51 (binary_exp -> exp LESS exp .)
    COMMA           reduce using rule 51 (binary_exp -> exp LESS exp .)
    RBRACKET        reduce using rule 51 (binary_exp -> exp LESS exp .)
    ELSE            reduce using rule 51 (binary_exp -> exp LESS exp .)
    BAR             reduce using rule 51 (binary_exp -> exp LESS exp .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    MOD             shift and go to state 71
    POWER           shift and go to state 72

  ! PLUS            [ reduce using rule 51 (binary_exp -> exp LESS exp .) ]
  ! MINUS           [ reduce using rule 51 (binary_exp -> exp LESS exp .) ]
  ! TIMES           [ reduce using rule 51 (binary_exp -> exp LESS exp .) ]
  ! DIVIDE          [ reduce using rule 51 (binary_exp -> exp LESS exp .) ]
  ! MOD             [ reduce using rule 51 (binary_exp -> exp LESS exp .) ]
  ! POWER           [ reduce using rule 51 (binary_exp -> exp LESS exp .) ]
  ! EQUALS          [ shift and go to state 66 ]
  ! NOT_EQUALS      [ shift and go to state 73 ]
  ! LESS            [ shift and go to state 74 ]
  ! LESS_EQUAL      [ shift and go to state 75 ]
  ! GREATER         [ shift and go to state 76 ]
  ! GREATER_EQUAL   [ shift and go to state 77 ]
  ! AND             [ shift and go to state 78 ]
  ! OR              [ shift and go to state 79 ]
  ! SEMICOLON       [ shift and go to state 80 ]


state 107

    (52) binary_exp -> exp LESS_EQUAL exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    EQUALS          reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    NOT_EQUALS      reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    LESS            reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    LESS_EQUAL      reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    GREATER         reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    GREATER_EQUAL   reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    AND             reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    OR              reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    SEMICOLON       reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    LET             reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    $end            reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    RPAREN          reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    THEN            reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    DO              reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    COMMA           reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    RBRACKET        reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    ELSE            reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    BAR             reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    MOD             shift and go to state 71
    POWER           shift and go to state 72

  ! PLUS            [ reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .) ]
  ! MINUS           [ reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .) ]
  ! TIMES           [ reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .) ]
  ! DIVIDE          [ reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .) ]
  ! MOD             [ reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .) ]
  ! POWER           [ reduce using rule 52 (binary_exp -> exp LESS_EQUAL exp .) ]
  ! EQUALS          [ shift and go to state 66 ]
  ! NOT_EQUALS      [ shift and go to state 73 ]
  ! LESS            [ shift and go to state 74 ]
  ! LESS_EQUAL      [ shift and go to state 75 ]
  ! GREATER         [ shift and go to state 76 ]
  ! GREATER_EQUAL   [ shift and go to state 77 ]
  ! AND             [ shift and go to state 78 ]
  ! OR              [ shift and go to state 79 ]
  ! SEMICOLON       [ shift and go to state 80 ]


state 108

    (53) binary_exp -> exp GREATER exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    EQUALS          reduce using rule 53 (binary_exp -> exp GREATER exp .)
    NOT_EQUALS      reduce using rule 53 (binary_exp -> exp GREATER exp .)
    LESS            reduce using rule 53 (binary_exp -> exp GREATER exp .)
    LESS_EQUAL      reduce using rule 53 (binary_exp -> exp GREATER exp .)
    GREATER         reduce using rule 53 (binary_exp -> exp GREATER exp .)
    GREATER_EQUAL   reduce using rule 53 (binary_exp -> exp GREATER exp .)
    AND             reduce using rule 53 (binary_exp -> exp GREATER exp .)
    OR              reduce using rule 53 (binary_exp -> exp GREATER exp .)
    SEMICOLON       reduce using rule 53 (binary_exp -> exp GREATER exp .)
    LET             reduce using rule 53 (binary_exp -> exp GREATER exp .)
    $end            reduce using rule 53 (binary_exp -> exp GREATER exp .)
    RPAREN          reduce using rule 53 (binary_exp -> exp GREATER exp .)
    THEN            reduce using rule 53 (binary_exp -> exp GREATER exp .)
    DO              reduce using rule 53 (binary_exp -> exp GREATER exp .)
    COMMA           reduce using rule 53 (binary_exp -> exp GREATER exp .)
    RBRACKET        reduce using rule 53 (binary_exp -> exp GREATER exp .)
    ELSE            reduce using rule 53 (binary_exp -> exp GREATER exp .)
    BAR             reduce using rule 53 (binary_exp -> exp GREATER exp .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    MOD             shift and go to state 71
    POWER           shift and go to state 72

  ! PLUS            [ reduce using rule 53 (binary_exp -> exp GREATER exp .) ]
  ! MINUS           [ reduce using rule 53 (binary_exp -> exp GREATER exp .) ]
  ! TIMES           [ reduce using rule 53 (binary_exp -> exp GREATER exp .) ]
  ! DIVIDE          [ reduce using rule 53 (binary_exp -> exp GREATER exp .) ]
  ! MOD             [ reduce using rule 53 (binary_exp -> exp GREATER exp .) ]
  ! POWER           [ reduce using rule 53 (binary_exp -> exp GREATER exp .) ]
  ! EQUALS          [ shift and go to state 66 ]
  ! NOT_EQUALS      [ shift and go to state 73 ]
  ! LESS            [ shift and go to state 74 ]
  ! LESS_EQUAL      [ shift and go to state 75 ]
  ! GREATER         [ shift and go to state 76 ]
  ! GREATER_EQUAL   [ shift and go to state 77 ]
  ! AND             [ shift and go to state 78 ]
  ! OR              [ shift and go to state 79 ]
  ! SEMICOLON       [ shift and go to state 80 ]


state 109

    (54) binary_exp -> exp GREATER_EQUAL exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    EQUALS          reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    NOT_EQUALS      reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    LESS            reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    LESS_EQUAL      reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    GREATER         reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    GREATER_EQUAL   reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    AND             reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    OR              reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    SEMICOLON       reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    LET             reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    $end            reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    RPAREN          reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    THEN            reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    DO              reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    COMMA           reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    RBRACKET        reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    ELSE            reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    BAR             reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    MOD             shift and go to state 71
    POWER           shift and go to state 72

  ! PLUS            [ reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .) ]
  ! MINUS           [ reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .) ]
  ! TIMES           [ reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .) ]
  ! DIVIDE          [ reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .) ]
  ! MOD             [ reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .) ]
  ! POWER           [ reduce using rule 54 (binary_exp -> exp GREATER_EQUAL exp .) ]
  ! EQUALS          [ shift and go to state 66 ]
  ! NOT_EQUALS      [ shift and go to state 73 ]
  ! LESS            [ shift and go to state 74 ]
  ! LESS_EQUAL      [ shift and go to state 75 ]
  ! GREATER         [ shift and go to state 76 ]
  ! GREATER_EQUAL   [ shift and go to state 77 ]
  ! AND             [ shift and go to state 78 ]
  ! OR              [ shift and go to state 79 ]
  ! SEMICOLON       [ shift and go to state 80 ]


state 110

    (55) binary_exp -> exp AND exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    AND             reduce using rule 55 (binary_exp -> exp AND exp .)
    OR              reduce using rule 55 (binary_exp -> exp AND exp .)
    SEMICOLON       reduce using rule 55 (binary_exp -> exp AND exp .)
    LET             reduce using rule 55 (binary_exp -> exp AND exp .)
    $end            reduce using rule 55 (binary_exp -> exp AND exp .)
    RPAREN          reduce using rule 55 (binary_exp -> exp AND exp .)
    THEN            reduce using rule 55 (binary_exp -> exp AND exp .)
    DO              reduce using rule 55 (binary_exp -> exp AND exp .)
    COMMA           reduce using rule 55 (binary_exp -> exp AND exp .)
    RBRACKET        reduce using rule 55 (binary_exp -> exp AND exp .)
    ELSE            reduce using rule 55 (binary_exp -> exp AND exp .)
    BAR             reduce using rule 55 (binary_exp -> exp AND exp .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    MOD             shift and go to state 71
    POWER           shift and go to state 72
    EQUALS          shift and go to state 66
    NOT_EQUALS      shift and go to state 73
    LESS            shift and go to state 74
    LESS_EQUAL      shift and go to state 75
    GREATER         shift and go to state 76
    GREATER_EQUAL   shift and go to state 77

  ! PLUS            [ reduce using rule 55 (binary_exp -> exp AND exp .) ]
  ! MINUS           [ reduce using rule 55 (binary_exp -> exp AND exp .) ]
  ! TIMES           [ reduce using rule 55 (binary_exp -> exp AND exp .) ]
  ! DIVIDE          [ reduce using rule 55 (binary_exp -> exp AND exp .) ]
  ! MOD             [ reduce using rule 55 (binary_exp -> exp AND exp .) ]
  ! POWER           [ reduce using rule 55 (binary_exp -> exp AND exp .) ]
  ! EQUALS          [ reduce using rule 55 (binary_exp -> exp AND exp .) ]
  ! NOT_EQUALS      [ reduce using rule 55 (binary_exp -> exp AND exp .) ]
  ! LESS            [ reduce using rule 55 (binary_exp -> exp AND exp .) ]
  ! LESS_EQUAL      [ reduce using rule 55 (binary_exp -> exp AND exp .) ]
  ! GREATER         [ reduce using rule 55 (binary_exp -> exp AND exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 55 (binary_exp -> exp AND exp .) ]
  ! AND             [ shift and go to state 78 ]
  ! OR              [ shift and go to state 79 ]
  ! SEMICOLON       [ shift and go to state 80 ]


state 111

    (56) binary_exp -> exp OR exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    OR              reduce using rule 56 (binary_exp -> exp OR exp .)
    SEMICOLON       reduce using rule 56 (binary_exp -> exp OR exp .)
    LET             reduce using rule 56 (binary_exp -> exp OR exp .)
    $end            reduce using rule 56 (binary_exp -> exp OR exp .)
    RPAREN          reduce using rule 56 (binary_exp -> exp OR exp .)
    THEN            reduce using rule 56 (binary_exp -> exp OR exp .)
    DO              reduce using rule 56 (binary_exp -> exp OR exp .)
    COMMA           reduce using rule 56 (binary_exp -> exp OR exp .)
    RBRACKET        reduce using rule 56 (binary_exp -> exp OR exp .)
    ELSE            reduce using rule 56 (binary_exp -> exp OR exp .)
    BAR             reduce using rule 56 (binary_exp -> exp OR exp .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    MOD             shift and go to state 71
    POWER           shift and go to state 72
    EQUALS          shift and go to state 66
    NOT_EQUALS      shift and go to state 73
    LESS            shift and go to state 74
    LESS_EQUAL      shift and go to state 75
    GREATER         shift and go to state 76
    GREATER_EQUAL   shift and go to state 77
    AND             shift and go to state 78

  ! PLUS            [ reduce using rule 56 (binary_exp -> exp OR exp .) ]
  ! MINUS           [ reduce using rule 56 (binary_exp -> exp OR exp .) ]
  ! TIMES           [ reduce using rule 56 (binary_exp -> exp OR exp .) ]
  ! DIVIDE          [ reduce using rule 56 (binary_exp -> exp OR exp .) ]
  ! MOD             [ reduce using rule 56 (binary_exp -> exp OR exp .) ]
  ! POWER           [ reduce using rule 56 (binary_exp -> exp OR exp .) ]
  ! EQUALS          [ reduce using rule 56 (binary_exp -> exp OR exp .) ]
  ! NOT_EQUALS      [ reduce using rule 56 (binary_exp -> exp OR exp .) ]
  ! LESS            [ reduce using rule 56 (binary_exp -> exp OR exp .) ]
  ! LESS_EQUAL      [ reduce using rule 56 (binary_exp -> exp OR exp .) ]
  ! GREATER         [ reduce using rule 56 (binary_exp -> exp OR exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 56 (binary_exp -> exp OR exp .) ]
  ! AND             [ reduce using rule 56 (binary_exp -> exp OR exp .) ]
  ! OR              [ shift and go to state 79 ]
  ! SEMICOLON       [ shift and go to state 80 ]


state 112

    (57) binary_exp -> exp SEMICOLON exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    LET             reduce using rule 57 (binary_exp -> exp SEMICOLON exp .)
    $end            reduce using rule 57 (binary_exp -> exp SEMICOLON exp .)
    RPAREN          reduce using rule 57 (binary_exp -> exp SEMICOLON exp .)
    THEN            reduce using rule 57 (binary_exp -> exp SEMICOLON exp .)
    DO              reduce using rule 57 (binary_exp -> exp SEMICOLON exp .)
    COMMA           reduce using rule 57 (binary_exp -> exp SEMICOLON exp .)
    RBRACKET        reduce using rule 57 (binary_exp -> exp SEMICOLON exp .)
    ELSE            reduce using rule 57 (binary_exp -> exp SEMICOLON exp .)
    BAR             reduce using rule 57 (binary_exp -> exp SEMICOLON exp .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    MOD             shift and go to state 71
    POWER           shift and go to state 72
    EQUALS          shift and go to state 66
    NOT_EQUALS      shift and go to state 73
    LESS            shift and go to state 74
    LESS_EQUAL      shift and go to state 75
    GREATER         shift and go to state 76
    GREATER_EQUAL   shift and go to state 77
    AND             shift and go to state 78
    OR              shift and go to state 79
    SEMICOLON       shift and go to state 80

  ! PLUS            [ reduce using rule 57 (binary_exp -> exp SEMICOLON exp .) ]
  ! MINUS           [ reduce using rule 57 (binary_exp -> exp SEMICOLON exp .) ]
  ! TIMES           [ reduce using rule 57 (binary_exp -> exp SEMICOLON exp .) ]
  ! DIVIDE          [ reduce using rule 57 (binary_exp -> exp SEMICOLON exp .) ]
  ! MOD             [ reduce using rule 57 (binary_exp -> exp SEMICOLON exp .) ]
  ! POWER           [ reduce using rule 57 (binary_exp -> exp SEMICOLON exp .) ]
  ! EQUALS          [ reduce using rule 57 (binary_exp -> exp SEMICOLON exp .) ]
  ! NOT_EQUALS      [ reduce using rule 57 (binary_exp -> exp SEMICOLON exp .) ]
  ! LESS            [ reduce using rule 57 (binary_exp -> exp SEMICOLON exp .) ]
  ! LESS_EQUAL      [ reduce using rule 57 (binary_exp -> exp SEMICOLON exp .) ]
  ! GREATER         [ reduce using rule 57 (binary_exp -> exp SEMICOLON exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 57 (binary_exp -> exp SEMICOLON exp .) ]
  ! AND             [ reduce using rule 57 (binary_exp -> exp SEMICOLON exp .) ]
  ! OR              [ reduce using rule 57 (binary_exp -> exp SEMICOLON exp .) ]
  ! SEMICOLON       [ reduce using rule 57 (binary_exp -> exp SEMICOLON exp .) ]


state 113

    (73) group -> LPAREN exp RPAREN .

    PLUS            reduce using rule 73 (group -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 73 (group -> LPAREN exp RPAREN .)
    TIMES           reduce using rule 73 (group -> LPAREN exp RPAREN .)
    DIVIDE          reduce using rule 73 (group -> LPAREN exp RPAREN .)
    MOD             reduce using rule 73 (group -> LPAREN exp RPAREN .)
    POWER           reduce using rule 73 (group -> LPAREN exp RPAREN .)
    EQUALS          reduce using rule 73 (group -> LPAREN exp RPAREN .)
    NOT_EQUALS      reduce using rule 73 (group -> LPAREN exp RPAREN .)
    LESS            reduce using rule 73 (group -> LPAREN exp RPAREN .)
    LESS_EQUAL      reduce using rule 73 (group -> LPAREN exp RPAREN .)
    GREATER         reduce using rule 73 (group -> LPAREN exp RPAREN .)
    GREATER_EQUAL   reduce using rule 73 (group -> LPAREN exp RPAREN .)
    AND             reduce using rule 73 (group -> LPAREN exp RPAREN .)
    OR              reduce using rule 73 (group -> LPAREN exp RPAREN .)
    SEMICOLON       reduce using rule 73 (group -> LPAREN exp RPAREN .)
    LET             reduce using rule 73 (group -> LPAREN exp RPAREN .)
    $end            reduce using rule 73 (group -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 73 (group -> LPAREN exp RPAREN .)
    THEN            reduce using rule 73 (group -> LPAREN exp RPAREN .)
    DO              reduce using rule 73 (group -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 73 (group -> LPAREN exp RPAREN .)
    RBRACKET        reduce using rule 73 (group -> LPAREN exp RPAREN .)
    ELSE            reduce using rule 73 (group -> LPAREN exp RPAREN .)
    BAR             reduce using rule 73 (group -> LPAREN exp RPAREN .)


state 114

    (64) assignment -> SET lhs EQUALS . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs EQUALS exp
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    NULL            shift and go to state 51
    UNIT            shift and go to state 52
    STRING_LITERAL  shift and go to state 53
    MINUS           shift and go to state 54
    NOT             shift and go to state 55
    SET             shift and go to state 57
    LET             shift and go to state 33
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    NEW             shift and go to state 61
    LPAREN          shift and go to state 56

    lhs                            shift and go to state 58
    exp                            shift and go to state 126
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    if_then_else                   shift and go to state 42
    if_then                        shift and go to state 43
    while_loop                     shift and go to state 44
    array_creation                 shift and go to state 45
    array_access                   shift and go to state 46
    group                          shift and go to state 47

state 115

    (67) array_access -> lhs LBRACKET exp . RBRACKET
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    RBRACKET        shift and go to state 127
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    MOD             shift and go to state 71
    POWER           shift and go to state 72
    EQUALS          shift and go to state 66
    NOT_EQUALS      shift and go to state 73
    LESS            shift and go to state 74
    LESS_EQUAL      shift and go to state 75
    GREATER         shift and go to state 76
    GREATER_EQUAL   shift and go to state 77
    AND             shift and go to state 78
    OR              shift and go to state 79
    SEMICOLON       shift and go to state 80


state 116

    (69) if_then_else -> IF exp THEN . exp ELSE exp
    (70) if_then -> IF exp THEN . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs EQUALS exp
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    NULL            shift and go to state 51
    UNIT            shift and go to state 52
    STRING_LITERAL  shift and go to state 53
    MINUS           shift and go to state 54
    NOT             shift and go to state 55
    SET             shift and go to state 57
    LET             shift and go to state 33
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    NEW             shift and go to state 61
    LPAREN          shift and go to state 56

    exp                            shift and go to state 128
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    if_then_else                   shift and go to state 42
    if_then                        shift and go to state 43
    while_loop                     shift and go to state 44
    array_creation                 shift and go to state 45
    array_access                   shift and go to state 46
    group                          shift and go to state 47
    lhs                            shift and go to state 58

state 117

    (71) while_loop -> WHILE exp DO . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs EQUALS exp
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    NULL            shift and go to state 51
    UNIT            shift and go to state 52
    STRING_LITERAL  shift and go to state 53
    MINUS           shift and go to state 54
    NOT             shift and go to state 55
    SET             shift and go to state 57
    LET             shift and go to state 33
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    NEW             shift and go to state 61
    LPAREN          shift and go to state 56

    exp                            shift and go to state 129
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    if_then_else                   shift and go to state 42
    if_then                        shift and go to state 43
    while_loop                     shift and go to state 44
    array_creation                 shift and go to state 45
    array_access                   shift and go to state 46
    group                          shift and go to state 47
    lhs                            shift and go to state 58

state 118

    (72) array_creation -> NEW type LBRACKET . exp BAR exp RBRACKET
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs EQUALS exp
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    NULL            shift and go to state 51
    UNIT            shift and go to state 52
    STRING_LITERAL  shift and go to state 53
    MINUS           shift and go to state 54
    NOT             shift and go to state 55
    SET             shift and go to state 57
    LET             shift and go to state 33
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    NEW             shift and go to state 61
    LPAREN          shift and go to state 56

    exp                            shift and go to state 130
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    if_then_else                   shift and go to state 42
    if_then                        shift and go to state 43
    while_loop                     shift and go to state 44
    array_creation                 shift and go to state 45
    array_access                   shift and go to state 46
    group                          shift and go to state 47
    lhs                            shift and go to state 58

state 119

    (19) function_type -> LPAREN type . function_type_tail RPAREN ARROW type
    (20) function_type_tail -> . COMMA type function_type_tail
    (21) function_type_tail -> . empty
    (74) empty -> .

    COMMA           shift and go to state 132
    RPAREN          reduce using rule 74 (empty -> .)

    function_type_tail             shift and go to state 131
    empty                          shift and go to state 133

state 120

    (7) function_declaration -> LET ID LPAREN parameters RPAREN COLON function_type EQUALS . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs EQUALS exp
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    NULL            shift and go to state 51
    UNIT            shift and go to state 52
    STRING_LITERAL  shift and go to state 53
    MINUS           shift and go to state 54
    NOT             shift and go to state 55
    SET             shift and go to state 57
    LET             shift and go to state 33
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    NEW             shift and go to state 61
    LPAREN          shift and go to state 56

    exp                            shift and go to state 134
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    if_then_else                   shift and go to state 42
    if_then                        shift and go to state 43
    while_loop                     shift and go to state 44
    array_creation                 shift and go to state 45
    array_access                   shift and go to state 46
    group                          shift and go to state 47
    lhs                            shift and go to state 58

state 121

    (18) function_type -> type ARROW . type
    (11) type -> . base_type array_suffix
    (12) base_type -> . INT_TYPE
    (13) base_type -> . BOOL_TYPE
    (14) base_type -> . UNIT_TYPE
    (15) base_type -> . STRING_TYPE

    INT_TYPE        shift and go to state 18
    BOOL_TYPE       shift and go to state 19
    UNIT_TYPE       shift and go to state 20
    STRING_TYPE     shift and go to state 21

    type                           shift and go to state 135
    base_type                      shift and go to state 17

state 122

    (60) function_call -> variable LPAREN arguments RPAREN .

    PLUS            reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    MINUS           reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    TIMES           reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    DIVIDE          reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    MOD             reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    POWER           reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    EQUALS          reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    NOT_EQUALS      reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    LESS            reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    LESS_EQUAL      reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    GREATER         reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    GREATER_EQUAL   reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    AND             reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    OR              reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    SEMICOLON       reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    LET             reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    $end            reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    THEN            reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    DO              reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    COMMA           reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    RBRACKET        reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    ELSE            reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)
    BAR             reduce using rule 60 (function_call -> variable LPAREN arguments RPAREN .)


state 123

    (61) arguments -> exp arguments_tail .

    RPAREN          reduce using rule 61 (arguments -> exp arguments_tail .)


state 124

    (62) arguments_tail -> COMMA . exp arguments_tail
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs EQUALS exp
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    NULL            shift and go to state 51
    UNIT            shift and go to state 52
    STRING_LITERAL  shift and go to state 53
    MINUS           shift and go to state 54
    NOT             shift and go to state 55
    SET             shift and go to state 57
    LET             shift and go to state 33
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    NEW             shift and go to state 61
    LPAREN          shift and go to state 56

    exp                            shift and go to state 136
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    if_then_else                   shift and go to state 42
    if_then                        shift and go to state 43
    while_loop                     shift and go to state 44
    array_creation                 shift and go to state 45
    array_access                   shift and go to state 46
    group                          shift and go to state 47
    lhs                            shift and go to state 58

state 125

    (63) arguments_tail -> empty .

    RPAREN          reduce using rule 63 (arguments_tail -> empty .)


state 126

    (64) assignment -> SET lhs EQUALS exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    EQUALS          reduce using rule 64 (assignment -> SET lhs EQUALS exp .)
    NOT_EQUALS      reduce using rule 64 (assignment -> SET lhs EQUALS exp .)
    AND             reduce using rule 64 (assignment -> SET lhs EQUALS exp .)
    OR              reduce using rule 64 (assignment -> SET lhs EQUALS exp .)
    SEMICOLON       reduce using rule 64 (assignment -> SET lhs EQUALS exp .)
    LET             reduce using rule 64 (assignment -> SET lhs EQUALS exp .)
    $end            reduce using rule 64 (assignment -> SET lhs EQUALS exp .)
    RPAREN          reduce using rule 64 (assignment -> SET lhs EQUALS exp .)
    THEN            reduce using rule 64 (assignment -> SET lhs EQUALS exp .)
    DO              reduce using rule 64 (assignment -> SET lhs EQUALS exp .)
    COMMA           reduce using rule 64 (assignment -> SET lhs EQUALS exp .)
    RBRACKET        reduce using rule 64 (assignment -> SET lhs EQUALS exp .)
    ELSE            reduce using rule 64 (assignment -> SET lhs EQUALS exp .)
    BAR             reduce using rule 64 (assignment -> SET lhs EQUALS exp .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    MOD             shift and go to state 71
    POWER           shift and go to state 72
    LESS            shift and go to state 74
    LESS_EQUAL      shift and go to state 75
    GREATER         shift and go to state 76
    GREATER_EQUAL   shift and go to state 77

  ! PLUS            [ reduce using rule 64 (assignment -> SET lhs EQUALS exp .) ]
  ! MINUS           [ reduce using rule 64 (assignment -> SET lhs EQUALS exp .) ]
  ! TIMES           [ reduce using rule 64 (assignment -> SET lhs EQUALS exp .) ]
  ! DIVIDE          [ reduce using rule 64 (assignment -> SET lhs EQUALS exp .) ]
  ! MOD             [ reduce using rule 64 (assignment -> SET lhs EQUALS exp .) ]
  ! POWER           [ reduce using rule 64 (assignment -> SET lhs EQUALS exp .) ]
  ! LESS            [ reduce using rule 64 (assignment -> SET lhs EQUALS exp .) ]
  ! LESS_EQUAL      [ reduce using rule 64 (assignment -> SET lhs EQUALS exp .) ]
  ! GREATER         [ reduce using rule 64 (assignment -> SET lhs EQUALS exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 64 (assignment -> SET lhs EQUALS exp .) ]
  ! EQUALS          [ shift and go to state 66 ]
  ! NOT_EQUALS      [ shift and go to state 73 ]
  ! AND             [ shift and go to state 78 ]
  ! OR              [ shift and go to state 79 ]
  ! SEMICOLON       [ shift and go to state 80 ]


state 127

    (67) array_access -> lhs LBRACKET exp RBRACKET .

    PLUS            reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    MINUS           reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    TIMES           reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    DIVIDE          reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    MOD             reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    POWER           reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    EQUALS          reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    NOT_EQUALS      reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    LESS            reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    LESS_EQUAL      reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    GREATER         reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    GREATER_EQUAL   reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    AND             reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    OR              reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    SEMICOLON       reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    LET             reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    $end            reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    THEN            reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    DO              reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    COMMA           reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    RBRACKET        reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    ELSE            reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    BAR             reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)
    LBRACKET        reduce using rule 67 (array_access -> lhs LBRACKET exp RBRACKET .)


state 128

    (69) if_then_else -> IF exp THEN exp . ELSE exp
    (70) if_then -> IF exp THEN exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    ELSE            shift and go to state 137
    SEMICOLON       reduce using rule 70 (if_then -> IF exp THEN exp .)
    LET             reduce using rule 70 (if_then -> IF exp THEN exp .)
    $end            reduce using rule 70 (if_then -> IF exp THEN exp .)
    RPAREN          reduce using rule 70 (if_then -> IF exp THEN exp .)
    THEN            reduce using rule 70 (if_then -> IF exp THEN exp .)
    DO              reduce using rule 70 (if_then -> IF exp THEN exp .)
    COMMA           reduce using rule 70 (if_then -> IF exp THEN exp .)
    RBRACKET        reduce using rule 70 (if_then -> IF exp THEN exp .)
    BAR             reduce using rule 70 (if_then -> IF exp THEN exp .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    MOD             shift and go to state 71
    POWER           shift and go to state 72
    EQUALS          shift and go to state 66
    NOT_EQUALS      shift and go to state 73
    LESS            shift and go to state 74
    LESS_EQUAL      shift and go to state 75
    GREATER         shift and go to state 76
    GREATER_EQUAL   shift and go to state 77
    AND             shift and go to state 78
    OR              shift and go to state 79

  ! PLUS            [ reduce using rule 70 (if_then -> IF exp THEN exp .) ]
  ! MINUS           [ reduce using rule 70 (if_then -> IF exp THEN exp .) ]
  ! TIMES           [ reduce using rule 70 (if_then -> IF exp THEN exp .) ]
  ! DIVIDE          [ reduce using rule 70 (if_then -> IF exp THEN exp .) ]
  ! MOD             [ reduce using rule 70 (if_then -> IF exp THEN exp .) ]
  ! POWER           [ reduce using rule 70 (if_then -> IF exp THEN exp .) ]
  ! EQUALS          [ reduce using rule 70 (if_then -> IF exp THEN exp .) ]
  ! NOT_EQUALS      [ reduce using rule 70 (if_then -> IF exp THEN exp .) ]
  ! LESS            [ reduce using rule 70 (if_then -> IF exp THEN exp .) ]
  ! LESS_EQUAL      [ reduce using rule 70 (if_then -> IF exp THEN exp .) ]
  ! GREATER         [ reduce using rule 70 (if_then -> IF exp THEN exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 70 (if_then -> IF exp THEN exp .) ]
  ! AND             [ reduce using rule 70 (if_then -> IF exp THEN exp .) ]
  ! OR              [ reduce using rule 70 (if_then -> IF exp THEN exp .) ]
  ! ELSE            [ reduce using rule 70 (if_then -> IF exp THEN exp .) ]
  ! SEMICOLON       [ shift and go to state 80 ]


state 129

    (71) while_loop -> WHILE exp DO exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    SEMICOLON       reduce using rule 71 (while_loop -> WHILE exp DO exp .)
    LET             reduce using rule 71 (while_loop -> WHILE exp DO exp .)
    $end            reduce using rule 71 (while_loop -> WHILE exp DO exp .)
    RPAREN          reduce using rule 71 (while_loop -> WHILE exp DO exp .)
    THEN            reduce using rule 71 (while_loop -> WHILE exp DO exp .)
    DO              reduce using rule 71 (while_loop -> WHILE exp DO exp .)
    COMMA           reduce using rule 71 (while_loop -> WHILE exp DO exp .)
    RBRACKET        reduce using rule 71 (while_loop -> WHILE exp DO exp .)
    ELSE            reduce using rule 71 (while_loop -> WHILE exp DO exp .)
    BAR             reduce using rule 71 (while_loop -> WHILE exp DO exp .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    MOD             shift and go to state 71
    POWER           shift and go to state 72
    EQUALS          shift and go to state 66
    NOT_EQUALS      shift and go to state 73
    LESS            shift and go to state 74
    LESS_EQUAL      shift and go to state 75
    GREATER         shift and go to state 76
    GREATER_EQUAL   shift and go to state 77
    AND             shift and go to state 78
    OR              shift and go to state 79

  ! PLUS            [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! MINUS           [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! TIMES           [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! DIVIDE          [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! MOD             [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! POWER           [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! EQUALS          [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! NOT_EQUALS      [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! LESS            [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! LESS_EQUAL      [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! GREATER         [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! AND             [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! OR              [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! SEMICOLON       [ shift and go to state 80 ]


state 130

    (72) array_creation -> NEW type LBRACKET exp . BAR exp RBRACKET
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    BAR             shift and go to state 138
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    MOD             shift and go to state 71
    POWER           shift and go to state 72
    EQUALS          shift and go to state 66
    NOT_EQUALS      shift and go to state 73
    LESS            shift and go to state 74
    LESS_EQUAL      shift and go to state 75
    GREATER         shift and go to state 76
    GREATER_EQUAL   shift and go to state 77
    AND             shift and go to state 78
    OR              shift and go to state 79
    SEMICOLON       shift and go to state 80


state 131

    (19) function_type -> LPAREN type function_type_tail . RPAREN ARROW type

    RPAREN          shift and go to state 139


state 132

    (20) function_type_tail -> COMMA . type function_type_tail
    (11) type -> . base_type array_suffix
    (12) base_type -> . INT_TYPE
    (13) base_type -> . BOOL_TYPE
    (14) base_type -> . UNIT_TYPE
    (15) base_type -> . STRING_TYPE

    INT_TYPE        shift and go to state 18
    BOOL_TYPE       shift and go to state 19
    UNIT_TYPE       shift and go to state 20
    STRING_TYPE     shift and go to state 21

    type                           shift and go to state 140
    base_type                      shift and go to state 17

state 133

    (21) function_type_tail -> empty .

    RPAREN          reduce using rule 21 (function_type_tail -> empty .)


state 134

    (7) function_declaration -> LET ID LPAREN parameters RPAREN COLON function_type EQUALS exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    LET             reduce using rule 7 (function_declaration -> LET ID LPAREN parameters RPAREN COLON function_type EQUALS exp .)
    $end            reduce using rule 7 (function_declaration -> LET ID LPAREN parameters RPAREN COLON function_type EQUALS exp .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    MOD             shift and go to state 71
    POWER           shift and go to state 72
    EQUALS          shift and go to state 66
    NOT_EQUALS      shift and go to state 73
    LESS            shift and go to state 74
    LESS_EQUAL      shift and go to state 75
    GREATER         shift and go to state 76
    GREATER_EQUAL   shift and go to state 77
    AND             shift and go to state 78
    OR              shift and go to state 79
    SEMICOLON       shift and go to state 80


state 135

    (18) function_type -> type ARROW type .

    EQUALS          reduce using rule 18 (function_type -> type ARROW type .)


state 136

    (62) arguments_tail -> COMMA exp . arguments_tail
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp
    (62) arguments_tail -> . COMMA exp arguments_tail
    (63) arguments_tail -> . empty
    (74) empty -> .

    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    MOD             shift and go to state 71
    POWER           shift and go to state 72
    EQUALS          shift and go to state 66
    NOT_EQUALS      shift and go to state 73
    LESS            shift and go to state 74
    LESS_EQUAL      shift and go to state 75
    GREATER         shift and go to state 76
    GREATER_EQUAL   shift and go to state 77
    AND             shift and go to state 78
    OR              shift and go to state 79
    SEMICOLON       shift and go to state 80
    COMMA           shift and go to state 124
    RPAREN          reduce using rule 74 (empty -> .)

    arguments_tail                 shift and go to state 141
    empty                          shift and go to state 125

state 137

    (69) if_then_else -> IF exp THEN exp ELSE . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs EQUALS exp
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    NULL            shift and go to state 51
    UNIT            shift and go to state 52
    STRING_LITERAL  shift and go to state 53
    MINUS           shift and go to state 54
    NOT             shift and go to state 55
    SET             shift and go to state 57
    LET             shift and go to state 33
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    NEW             shift and go to state 61
    LPAREN          shift and go to state 56

    exp                            shift and go to state 142
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    if_then_else                   shift and go to state 42
    if_then                        shift and go to state 43
    while_loop                     shift and go to state 44
    array_creation                 shift and go to state 45
    array_access                   shift and go to state 46
    group                          shift and go to state 47
    lhs                            shift and go to state 58

state 138

    (72) array_creation -> NEW type LBRACKET exp BAR . exp RBRACKET
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . if_then_else
    (30) exp -> . if_then
    (31) exp -> . while_loop
    (32) exp -> . array_creation
    (33) exp -> . array_access
    (34) exp -> . group
    (35) variable -> . ID
    (36) variable -> . UNDERSCORE
    (37) literal -> . INT_LITERAL
    (38) literal -> . TRUE
    (39) literal -> . FALSE
    (40) literal -> . NULL
    (41) literal -> . UNIT
    (42) literal -> . STRING_LITERAL
    (43) binary_exp -> . exp PLUS exp
    (44) binary_exp -> . exp MINUS exp
    (45) binary_exp -> . exp TIMES exp
    (46) binary_exp -> . exp DIVIDE exp
    (47) binary_exp -> . exp MOD exp
    (48) binary_exp -> . exp POWER exp
    (49) binary_exp -> . exp EQUALS exp
    (50) binary_exp -> . exp NOT_EQUALS exp
    (51) binary_exp -> . exp LESS exp
    (52) binary_exp -> . exp LESS_EQUAL exp
    (53) binary_exp -> . exp GREATER exp
    (54) binary_exp -> . exp GREATER_EQUAL exp
    (55) binary_exp -> . exp AND exp
    (56) binary_exp -> . exp OR exp
    (57) binary_exp -> . exp SEMICOLON exp
    (58) unary_exp -> . MINUS exp
    (59) unary_exp -> . NOT exp
    (60) function_call -> . variable LPAREN arguments RPAREN
    (64) assignment -> . SET lhs EQUALS exp
    (68) variable_declaration -> . LET variable COLON type EQUALS exp
    (69) if_then_else -> . IF exp THEN exp ELSE exp
    (70) if_then -> . IF exp THEN exp
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (67) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (65) lhs -> . variable
    (66) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    NULL            shift and go to state 51
    UNIT            shift and go to state 52
    STRING_LITERAL  shift and go to state 53
    MINUS           shift and go to state 54
    NOT             shift and go to state 55
    SET             shift and go to state 57
    LET             shift and go to state 33
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    NEW             shift and go to state 61
    LPAREN          shift and go to state 56

    exp                            shift and go to state 143
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    if_then_else                   shift and go to state 42
    if_then                        shift and go to state 43
    while_loop                     shift and go to state 44
    array_creation                 shift and go to state 45
    array_access                   shift and go to state 46
    group                          shift and go to state 47
    lhs                            shift and go to state 58

state 139

    (19) function_type -> LPAREN type function_type_tail RPAREN . ARROW type

    ARROW           shift and go to state 144


state 140

    (20) function_type_tail -> COMMA type . function_type_tail
    (20) function_type_tail -> . COMMA type function_type_tail
    (21) function_type_tail -> . empty
    (74) empty -> .

    COMMA           shift and go to state 132
    RPAREN          reduce using rule 74 (empty -> .)

    function_type_tail             shift and go to state 145
    empty                          shift and go to state 133

state 141

    (62) arguments_tail -> COMMA exp arguments_tail .

    RPAREN          reduce using rule 62 (arguments_tail -> COMMA exp arguments_tail .)


state 142

    (69) if_then_else -> IF exp THEN exp ELSE exp .
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    SEMICOLON       reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .)
    LET             reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .)
    $end            reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .)
    RPAREN          reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .)
    THEN            reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .)
    DO              reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .)
    COMMA           reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .)
    RBRACKET        reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .)
    ELSE            reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .)
    BAR             reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    MOD             shift and go to state 71
    POWER           shift and go to state 72
    EQUALS          shift and go to state 66
    NOT_EQUALS      shift and go to state 73
    LESS            shift and go to state 74
    LESS_EQUAL      shift and go to state 75
    GREATER         shift and go to state 76
    GREATER_EQUAL   shift and go to state 77
    AND             shift and go to state 78
    OR              shift and go to state 79

  ! PLUS            [ reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! MINUS           [ reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! TIMES           [ reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! DIVIDE          [ reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! MOD             [ reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! POWER           [ reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! EQUALS          [ reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! NOT_EQUALS      [ reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! LESS            [ reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! LESS_EQUAL      [ reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! GREATER         [ reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! AND             [ reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! OR              [ reduce using rule 69 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! SEMICOLON       [ shift and go to state 80 ]


state 143

    (72) array_creation -> NEW type LBRACKET exp BAR exp . RBRACKET
    (43) binary_exp -> exp . PLUS exp
    (44) binary_exp -> exp . MINUS exp
    (45) binary_exp -> exp . TIMES exp
    (46) binary_exp -> exp . DIVIDE exp
    (47) binary_exp -> exp . MOD exp
    (48) binary_exp -> exp . POWER exp
    (49) binary_exp -> exp . EQUALS exp
    (50) binary_exp -> exp . NOT_EQUALS exp
    (51) binary_exp -> exp . LESS exp
    (52) binary_exp -> exp . LESS_EQUAL exp
    (53) binary_exp -> exp . GREATER exp
    (54) binary_exp -> exp . GREATER_EQUAL exp
    (55) binary_exp -> exp . AND exp
    (56) binary_exp -> exp . OR exp
    (57) binary_exp -> exp . SEMICOLON exp

    RBRACKET        shift and go to state 146
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    MOD             shift and go to state 71
    POWER           shift and go to state 72
    EQUALS          shift and go to state 66
    NOT_EQUALS      shift and go to state 73
    LESS            shift and go to state 74
    LESS_EQUAL      shift and go to state 75
    GREATER         shift and go to state 76
    GREATER_EQUAL   shift and go to state 77
    AND             shift and go to state 78
    OR              shift and go to state 79
    SEMICOLON       shift and go to state 80


state 144

    (19) function_type -> LPAREN type function_type_tail RPAREN ARROW . type
    (11) type -> . base_type array_suffix
    (12) base_type -> . INT_TYPE
    (13) base_type -> . BOOL_TYPE
    (14) base_type -> . UNIT_TYPE
    (15) base_type -> . STRING_TYPE

    INT_TYPE        shift and go to state 18
    BOOL_TYPE       shift and go to state 19
    UNIT_TYPE       shift and go to state 20
    STRING_TYPE     shift and go to state 21

    type                           shift and go to state 147
    base_type                      shift and go to state 17

state 145

    (20) function_type_tail -> COMMA type function_type_tail .

    RPAREN          reduce using rule 20 (function_type_tail -> COMMA type function_type_tail .)


state 146

    (72) array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .

    PLUS            reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    MINUS           reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    TIMES           reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    DIVIDE          reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    MOD             reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    POWER           reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    EQUALS          reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    NOT_EQUALS      reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    LESS            reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    LESS_EQUAL      reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    GREATER         reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    GREATER_EQUAL   reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    AND             reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    OR              reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    SEMICOLON       reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    LET             reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    $end            reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    RPAREN          reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    THEN            reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    DO              reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    COMMA           reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    RBRACKET        reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    ELSE            reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    BAR             reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)


state 147

    (19) function_type -> LPAREN type function_type_tail RPAREN ARROW type .

    EQUALS          reduce using rule 19 (function_type -> LPAREN type function_type_tail RPAREN ARROW type .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LBRACKET in state 17 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 62 resolved as shift
