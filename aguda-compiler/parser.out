Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> declarations
Rule 2     declarations -> declaration declarations_tail
Rule 3     declarations_tail -> declaration declarations_tail
Rule 4     declarations_tail -> empty
Rule 5     declaration -> variable_declaration
Rule 6     declaration -> function_declaration
Rule 7     function_declaration -> LET ID LPAREN parameters RPAREN COLON function_type ASSIGN exp
Rule 8     parameters -> variable parameters_tail
Rule 9     parameters_tail -> COMMA variable parameters_tail
Rule 10    parameters_tail -> empty
Rule 11    type -> INT_TYPE
Rule 12    type -> STRING_TYPE
Rule 13    type -> UNIT_TYPE
Rule 14    type -> BOOL_TYPE
Rule 15    type -> array_type
Rule 16    array_type -> type LBRACKET RBRACKET
Rule 17    function_type -> type ARROW type
Rule 18    function_type -> LPAREN type function_type_tail RPAREN ARROW type
Rule 19    function_type_tail -> COMMA type function_type_tail
Rule 20    function_type_tail -> empty
Rule 21    exp -> variable
Rule 22    exp -> literal
Rule 23    exp -> binary_exp
Rule 24    exp -> unary_exp
Rule 25    exp -> function_call
Rule 26    exp -> assignment
Rule 27    exp -> variable_declaration
Rule 28    exp -> if_then_else
Rule 29    exp -> if_then
Rule 30    exp -> while_loop
Rule 31    exp -> array_creation
Rule 32    exp -> array_access
Rule 33    exp -> group
Rule 34    variable -> ID
Rule 35    variable -> UNDERSCORE
Rule 36    literal -> INT_LITERAL
Rule 37    literal -> TRUE
Rule 38    literal -> FALSE
Rule 39    literal -> NULL
Rule 40    literal -> UNIT
Rule 41    literal -> STRING_LITERAL
Rule 42    binary_exp -> exp PLUS exp
Rule 43    binary_exp -> exp MINUS exp
Rule 44    binary_exp -> exp TIMES exp
Rule 45    binary_exp -> exp DIVIDE exp
Rule 46    binary_exp -> exp MOD exp
Rule 47    binary_exp -> exp POWER exp
Rule 48    binary_exp -> exp EQUALS exp
Rule 49    binary_exp -> exp NOT_EQUALS exp
Rule 50    binary_exp -> exp LESS exp
Rule 51    binary_exp -> exp LESS_EQUAL exp
Rule 52    binary_exp -> exp GREATER exp
Rule 53    binary_exp -> exp GREATER_EQUAL exp
Rule 54    binary_exp -> exp AND exp
Rule 55    binary_exp -> exp OR exp
Rule 56    binary_exp -> exp SEMICOLON exp
Rule 57    unary_exp -> MINUS exp
Rule 58    unary_exp -> NOT exp
Rule 59    function_call -> variable LPAREN arguments RPAREN
Rule 60    arguments -> exp arguments_tail
Rule 61    arguments_tail -> COMMA exp arguments_tail
Rule 62    arguments_tail -> empty
Rule 63    assignment -> SET lhs ASSIGN exp
Rule 64    lhs -> variable
Rule 65    lhs -> array_access
Rule 66    array_access -> lhs LBRACKET exp RBRACKET
Rule 67    variable_declaration -> LET variable COLON type ASSIGN exp
Rule 68    if_then_else -> IF exp THEN exp ELSE exp
Rule 69    if_then -> IF exp THEN exp
Rule 70    while_loop -> WHILE exp DO exp
Rule 71    array_creation -> NEW type LBRACKET exp BAR exp RBRACKET
Rule 72    group -> LPAREN exp RPAREN
Rule 73    empty -> <empty>

Terminals, with rules where they appear

AND                  : 54
ARROW                : 17 18
ASSIGN               : 7 63 67
BAR                  : 71
BOOL_TYPE            : 14
COLON                : 7 67
COMMA                : 9 19 61
DIVIDE               : 45
DO                   : 70
ELSE                 : 68
EQUALS               : 48
FALSE                : 38
GREATER              : 52
GREATER_EQUAL        : 53
ID                   : 7 34
IF                   : 68 69
INT_LITERAL          : 36
INT_TYPE             : 11
LBRACKET             : 16 66 71
LESS                 : 50
LESS_EQUAL           : 51
LET                  : 7 67
LPAREN               : 7 18 59 72
MINUS                : 43 57
MOD                  : 46
NEW                  : 71
NOT                  : 58
NOT_EQUALS           : 49
NULL                 : 39
OR                   : 55
PLUS                 : 42
POWER                : 47
RBRACKET             : 16 66 71
RPAREN               : 7 18 59 72
SEMICOLON            : 56
SET                  : 63
STRING_LITERAL       : 41
STRING_TYPE          : 12
THEN                 : 68 69
TIMES                : 44
TRUE                 : 37
UNDERSCORE           : 35
UNIT                 : 40
UNIT_TYPE            : 13
WHILE                : 70
error                : 

Nonterminals, with rules where they appear

arguments            : 59
arguments_tail       : 60 61
array_access         : 32 65
array_creation       : 31
array_type           : 15
assignment           : 26
binary_exp           : 23
declaration          : 2 3
declarations         : 1
declarations_tail    : 2 3
empty                : 4 10 20 62
exp                  : 7 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 58 60 61 63 66 67 68 68 68 69 69 70 70 71 71 72
function_call        : 25
function_declaration : 6
function_type        : 7
function_type_tail   : 18 19
group                : 33
if_then              : 29
if_then_else         : 28
lhs                  : 63 66
literal              : 22
parameters           : 7
parameters_tail      : 8 9
program              : 0
type                 : 16 17 17 18 18 19 67 71
unary_exp            : 24
variable             : 8 9 21 59 64 67
variable_declaration : 5 27
while_loop           : 30

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declarations
    (2) declarations -> . declaration declarations_tail
    (5) declaration -> . variable_declaration
    (6) declaration -> . function_declaration
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (7) function_declaration -> . LET ID LPAREN parameters RPAREN COLON function_type ASSIGN exp

    LET             shift and go to state 6

    program                        shift and go to state 1
    declarations                   shift and go to state 2
    declaration                    shift and go to state 3
    variable_declaration           shift and go to state 4
    function_declaration           shift and go to state 5

state 1

    (0) S' -> program .



state 2

    (1) program -> declarations .

    $end            reduce using rule 1 (program -> declarations .)


state 3

    (2) declarations -> declaration . declarations_tail
    (3) declarations_tail -> . declaration declarations_tail
    (4) declarations_tail -> . empty
    (5) declaration -> . variable_declaration
    (6) declaration -> . function_declaration
    (73) empty -> .
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (7) function_declaration -> . LET ID LPAREN parameters RPAREN COLON function_type ASSIGN exp

    $end            reduce using rule 73 (empty -> .)
    LET             shift and go to state 6

    declaration                    shift and go to state 7
    declarations_tail              shift and go to state 8
    empty                          shift and go to state 9
    variable_declaration           shift and go to state 4
    function_declaration           shift and go to state 5

state 4

    (5) declaration -> variable_declaration .

    LET             reduce using rule 5 (declaration -> variable_declaration .)
    $end            reduce using rule 5 (declaration -> variable_declaration .)


state 5

    (6) declaration -> function_declaration .

    LET             reduce using rule 6 (declaration -> function_declaration .)
    $end            reduce using rule 6 (declaration -> function_declaration .)


state 6

    (67) variable_declaration -> LET . variable COLON type ASSIGN exp
    (7) function_declaration -> LET . ID LPAREN parameters RPAREN COLON function_type ASSIGN exp
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE

    ID              shift and go to state 11
    UNDERSCORE      shift and go to state 12

    variable                       shift and go to state 10

state 7

    (3) declarations_tail -> declaration . declarations_tail
    (3) declarations_tail -> . declaration declarations_tail
    (4) declarations_tail -> . empty
    (5) declaration -> . variable_declaration
    (6) declaration -> . function_declaration
    (73) empty -> .
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (7) function_declaration -> . LET ID LPAREN parameters RPAREN COLON function_type ASSIGN exp

    $end            reduce using rule 73 (empty -> .)
    LET             shift and go to state 6

    declaration                    shift and go to state 7
    declarations_tail              shift and go to state 13
    empty                          shift and go to state 9
    variable_declaration           shift and go to state 4
    function_declaration           shift and go to state 5

state 8

    (2) declarations -> declaration declarations_tail .

    $end            reduce using rule 2 (declarations -> declaration declarations_tail .)


state 9

    (4) declarations_tail -> empty .

    $end            reduce using rule 4 (declarations_tail -> empty .)


state 10

    (67) variable_declaration -> LET variable . COLON type ASSIGN exp

    COLON           shift and go to state 14


state 11

    (7) function_declaration -> LET ID . LPAREN parameters RPAREN COLON function_type ASSIGN exp
    (34) variable -> ID .

    LPAREN          shift and go to state 15
    COLON           reduce using rule 34 (variable -> ID .)


state 12

    (35) variable -> UNDERSCORE .

    COLON           reduce using rule 35 (variable -> UNDERSCORE .)
    COMMA           reduce using rule 35 (variable -> UNDERSCORE .)
    RPAREN          reduce using rule 35 (variable -> UNDERSCORE .)
    LPAREN          reduce using rule 35 (variable -> UNDERSCORE .)
    PLUS            reduce using rule 35 (variable -> UNDERSCORE .)
    MINUS           reduce using rule 35 (variable -> UNDERSCORE .)
    TIMES           reduce using rule 35 (variable -> UNDERSCORE .)
    DIVIDE          reduce using rule 35 (variable -> UNDERSCORE .)
    MOD             reduce using rule 35 (variable -> UNDERSCORE .)
    POWER           reduce using rule 35 (variable -> UNDERSCORE .)
    EQUALS          reduce using rule 35 (variable -> UNDERSCORE .)
    NOT_EQUALS      reduce using rule 35 (variable -> UNDERSCORE .)
    LESS            reduce using rule 35 (variable -> UNDERSCORE .)
    LESS_EQUAL      reduce using rule 35 (variable -> UNDERSCORE .)
    GREATER         reduce using rule 35 (variable -> UNDERSCORE .)
    GREATER_EQUAL   reduce using rule 35 (variable -> UNDERSCORE .)
    AND             reduce using rule 35 (variable -> UNDERSCORE .)
    OR              reduce using rule 35 (variable -> UNDERSCORE .)
    SEMICOLON       reduce using rule 35 (variable -> UNDERSCORE .)
    LET             reduce using rule 35 (variable -> UNDERSCORE .)
    $end            reduce using rule 35 (variable -> UNDERSCORE .)
    THEN            reduce using rule 35 (variable -> UNDERSCORE .)
    DO              reduce using rule 35 (variable -> UNDERSCORE .)
    RBRACKET        reduce using rule 35 (variable -> UNDERSCORE .)
    ELSE            reduce using rule 35 (variable -> UNDERSCORE .)
    BAR             reduce using rule 35 (variable -> UNDERSCORE .)
    LBRACKET        reduce using rule 35 (variable -> UNDERSCORE .)
    ASSIGN          reduce using rule 35 (variable -> UNDERSCORE .)


state 13

    (3) declarations_tail -> declaration declarations_tail .

    $end            reduce using rule 3 (declarations_tail -> declaration declarations_tail .)


state 14

    (67) variable_declaration -> LET variable COLON . type ASSIGN exp
    (11) type -> . INT_TYPE
    (12) type -> . STRING_TYPE
    (13) type -> . UNIT_TYPE
    (14) type -> . BOOL_TYPE
    (15) type -> . array_type
    (16) array_type -> . type LBRACKET RBRACKET

    INT_TYPE        shift and go to state 17
    STRING_TYPE     shift and go to state 18
    UNIT_TYPE       shift and go to state 19
    BOOL_TYPE       shift and go to state 20

    type                           shift and go to state 16
    array_type                     shift and go to state 21

state 15

    (7) function_declaration -> LET ID LPAREN . parameters RPAREN COLON function_type ASSIGN exp
    (8) parameters -> . variable parameters_tail
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12

    parameters                     shift and go to state 23
    variable                       shift and go to state 24

state 16

    (67) variable_declaration -> LET variable COLON type . ASSIGN exp
    (16) array_type -> type . LBRACKET RBRACKET

    ASSIGN          shift and go to state 25
    LBRACKET        shift and go to state 26


state 17

    (11) type -> INT_TYPE .

    ASSIGN          reduce using rule 11 (type -> INT_TYPE .)
    LBRACKET        reduce using rule 11 (type -> INT_TYPE .)
    ARROW           reduce using rule 11 (type -> INT_TYPE .)
    COMMA           reduce using rule 11 (type -> INT_TYPE .)
    RPAREN          reduce using rule 11 (type -> INT_TYPE .)


state 18

    (12) type -> STRING_TYPE .

    ASSIGN          reduce using rule 12 (type -> STRING_TYPE .)
    LBRACKET        reduce using rule 12 (type -> STRING_TYPE .)
    ARROW           reduce using rule 12 (type -> STRING_TYPE .)
    COMMA           reduce using rule 12 (type -> STRING_TYPE .)
    RPAREN          reduce using rule 12 (type -> STRING_TYPE .)


state 19

    (13) type -> UNIT_TYPE .

    ASSIGN          reduce using rule 13 (type -> UNIT_TYPE .)
    LBRACKET        reduce using rule 13 (type -> UNIT_TYPE .)
    ARROW           reduce using rule 13 (type -> UNIT_TYPE .)
    COMMA           reduce using rule 13 (type -> UNIT_TYPE .)
    RPAREN          reduce using rule 13 (type -> UNIT_TYPE .)


state 20

    (14) type -> BOOL_TYPE .

    ASSIGN          reduce using rule 14 (type -> BOOL_TYPE .)
    LBRACKET        reduce using rule 14 (type -> BOOL_TYPE .)
    ARROW           reduce using rule 14 (type -> BOOL_TYPE .)
    COMMA           reduce using rule 14 (type -> BOOL_TYPE .)
    RPAREN          reduce using rule 14 (type -> BOOL_TYPE .)


state 21

    (15) type -> array_type .

    ASSIGN          reduce using rule 15 (type -> array_type .)
    LBRACKET        reduce using rule 15 (type -> array_type .)
    ARROW           reduce using rule 15 (type -> array_type .)
    COMMA           reduce using rule 15 (type -> array_type .)
    RPAREN          reduce using rule 15 (type -> array_type .)


state 22

    (34) variable -> ID .

    COMMA           reduce using rule 34 (variable -> ID .)
    RPAREN          reduce using rule 34 (variable -> ID .)
    LPAREN          reduce using rule 34 (variable -> ID .)
    PLUS            reduce using rule 34 (variable -> ID .)
    MINUS           reduce using rule 34 (variable -> ID .)
    TIMES           reduce using rule 34 (variable -> ID .)
    DIVIDE          reduce using rule 34 (variable -> ID .)
    MOD             reduce using rule 34 (variable -> ID .)
    POWER           reduce using rule 34 (variable -> ID .)
    EQUALS          reduce using rule 34 (variable -> ID .)
    NOT_EQUALS      reduce using rule 34 (variable -> ID .)
    LESS            reduce using rule 34 (variable -> ID .)
    LESS_EQUAL      reduce using rule 34 (variable -> ID .)
    GREATER         reduce using rule 34 (variable -> ID .)
    GREATER_EQUAL   reduce using rule 34 (variable -> ID .)
    AND             reduce using rule 34 (variable -> ID .)
    OR              reduce using rule 34 (variable -> ID .)
    SEMICOLON       reduce using rule 34 (variable -> ID .)
    LET             reduce using rule 34 (variable -> ID .)
    $end            reduce using rule 34 (variable -> ID .)
    THEN            reduce using rule 34 (variable -> ID .)
    DO              reduce using rule 34 (variable -> ID .)
    RBRACKET        reduce using rule 34 (variable -> ID .)
    ELSE            reduce using rule 34 (variable -> ID .)
    BAR             reduce using rule 34 (variable -> ID .)
    LBRACKET        reduce using rule 34 (variable -> ID .)
    COLON           reduce using rule 34 (variable -> ID .)
    ASSIGN          reduce using rule 34 (variable -> ID .)


state 23

    (7) function_declaration -> LET ID LPAREN parameters . RPAREN COLON function_type ASSIGN exp

    RPAREN          shift and go to state 27


state 24

    (8) parameters -> variable . parameters_tail
    (9) parameters_tail -> . COMMA variable parameters_tail
    (10) parameters_tail -> . empty
    (73) empty -> .

    COMMA           shift and go to state 29
    RPAREN          reduce using rule 73 (empty -> .)

    parameters_tail                shift and go to state 28
    empty                          shift and go to state 30

state 25

    (67) variable_declaration -> LET variable COLON type ASSIGN . exp
    (21) exp -> . variable
    (22) exp -> . literal
    (23) exp -> . binary_exp
    (24) exp -> . unary_exp
    (25) exp -> . function_call
    (26) exp -> . assignment
    (27) exp -> . variable_declaration
    (28) exp -> . if_then_else
    (29) exp -> . if_then
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs ASSIGN exp
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (68) if_then_else -> . IF exp THEN exp ELSE exp
    (69) if_then -> . IF exp THEN exp
    (70) while_loop -> . WHILE exp DO exp
    (71) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (72) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NULL            shift and go to state 49
    UNIT            shift and go to state 50
    STRING_LITERAL  shift and go to state 51
    MINUS           shift and go to state 52
    NOT             shift and go to state 53
    SET             shift and go to state 55
    LET             shift and go to state 31
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    NEW             shift and go to state 59
    LPAREN          shift and go to state 54

    variable                       shift and go to state 32
    exp                            shift and go to state 33
    literal                        shift and go to state 34
    binary_exp                     shift and go to state 35
    unary_exp                      shift and go to state 36
    function_call                  shift and go to state 37
    assignment                     shift and go to state 38
    variable_declaration           shift and go to state 39
    if_then_else                   shift and go to state 40
    if_then                        shift and go to state 41
    while_loop                     shift and go to state 42
    array_creation                 shift and go to state 43
    array_access                   shift and go to state 44
    group                          shift and go to state 45
    lhs                            shift and go to state 56

state 26

    (16) array_type -> type LBRACKET . RBRACKET

    RBRACKET        shift and go to state 60


state 27

    (7) function_declaration -> LET ID LPAREN parameters RPAREN . COLON function_type ASSIGN exp

    COLON           shift and go to state 61


state 28

    (8) parameters -> variable parameters_tail .

    RPAREN          reduce using rule 8 (parameters -> variable parameters_tail .)


state 29

    (9) parameters_tail -> COMMA . variable parameters_tail
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12

    variable                       shift and go to state 62

state 30

    (10) parameters_tail -> empty .

    RPAREN          reduce using rule 10 (parameters_tail -> empty .)


state 31

    (67) variable_declaration -> LET . variable COLON type ASSIGN exp
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12

    variable                       shift and go to state 10

state 32

    (21) exp -> variable .
    (59) function_call -> variable . LPAREN arguments RPAREN
    (64) lhs -> variable .

    PLUS            reduce using rule 21 (exp -> variable .)
    MINUS           reduce using rule 21 (exp -> variable .)
    TIMES           reduce using rule 21 (exp -> variable .)
    DIVIDE          reduce using rule 21 (exp -> variable .)
    MOD             reduce using rule 21 (exp -> variable .)
    POWER           reduce using rule 21 (exp -> variable .)
    EQUALS          reduce using rule 21 (exp -> variable .)
    NOT_EQUALS      reduce using rule 21 (exp -> variable .)
    LESS            reduce using rule 21 (exp -> variable .)
    LESS_EQUAL      reduce using rule 21 (exp -> variable .)
    GREATER         reduce using rule 21 (exp -> variable .)
    GREATER_EQUAL   reduce using rule 21 (exp -> variable .)
    AND             reduce using rule 21 (exp -> variable .)
    OR              reduce using rule 21 (exp -> variable .)
    SEMICOLON       reduce using rule 21 (exp -> variable .)
    LET             reduce using rule 21 (exp -> variable .)
    $end            reduce using rule 21 (exp -> variable .)
    RPAREN          reduce using rule 21 (exp -> variable .)
    THEN            reduce using rule 21 (exp -> variable .)
    DO              reduce using rule 21 (exp -> variable .)
    COMMA           reduce using rule 21 (exp -> variable .)
    RBRACKET        reduce using rule 21 (exp -> variable .)
    ELSE            reduce using rule 21 (exp -> variable .)
    BAR             reduce using rule 21 (exp -> variable .)
    LPAREN          shift and go to state 63
    LBRACKET        reduce using rule 64 (lhs -> variable .)


state 33

    (67) variable_declaration -> LET variable COLON type ASSIGN exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    LET             reduce using rule 67 (variable_declaration -> LET variable COLON type ASSIGN exp .)
    $end            reduce using rule 67 (variable_declaration -> LET variable COLON type ASSIGN exp .)
    SEMICOLON       reduce using rule 67 (variable_declaration -> LET variable COLON type ASSIGN exp .)
    RPAREN          reduce using rule 67 (variable_declaration -> LET variable COLON type ASSIGN exp .)
    THEN            reduce using rule 67 (variable_declaration -> LET variable COLON type ASSIGN exp .)
    DO              reduce using rule 67 (variable_declaration -> LET variable COLON type ASSIGN exp .)
    COMMA           reduce using rule 67 (variable_declaration -> LET variable COLON type ASSIGN exp .)
    RBRACKET        reduce using rule 67 (variable_declaration -> LET variable COLON type ASSIGN exp .)
    ELSE            reduce using rule 67 (variable_declaration -> LET variable COLON type ASSIGN exp .)
    BAR             reduce using rule 67 (variable_declaration -> LET variable COLON type ASSIGN exp .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69
    EQUALS          shift and go to state 70
    NOT_EQUALS      shift and go to state 71
    LESS            shift and go to state 72
    LESS_EQUAL      shift and go to state 73
    GREATER         shift and go to state 74
    GREATER_EQUAL   shift and go to state 75
    AND             shift and go to state 76
    OR              shift and go to state 77

  ! PLUS            [ reduce using rule 67 (variable_declaration -> LET variable COLON type ASSIGN exp .) ]
  ! MINUS           [ reduce using rule 67 (variable_declaration -> LET variable COLON type ASSIGN exp .) ]
  ! TIMES           [ reduce using rule 67 (variable_declaration -> LET variable COLON type ASSIGN exp .) ]
  ! DIVIDE          [ reduce using rule 67 (variable_declaration -> LET variable COLON type ASSIGN exp .) ]
  ! MOD             [ reduce using rule 67 (variable_declaration -> LET variable COLON type ASSIGN exp .) ]
  ! POWER           [ reduce using rule 67 (variable_declaration -> LET variable COLON type ASSIGN exp .) ]
  ! EQUALS          [ reduce using rule 67 (variable_declaration -> LET variable COLON type ASSIGN exp .) ]
  ! NOT_EQUALS      [ reduce using rule 67 (variable_declaration -> LET variable COLON type ASSIGN exp .) ]
  ! LESS            [ reduce using rule 67 (variable_declaration -> LET variable COLON type ASSIGN exp .) ]
  ! LESS_EQUAL      [ reduce using rule 67 (variable_declaration -> LET variable COLON type ASSIGN exp .) ]
  ! GREATER         [ reduce using rule 67 (variable_declaration -> LET variable COLON type ASSIGN exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 67 (variable_declaration -> LET variable COLON type ASSIGN exp .) ]
  ! AND             [ reduce using rule 67 (variable_declaration -> LET variable COLON type ASSIGN exp .) ]
  ! OR              [ reduce using rule 67 (variable_declaration -> LET variable COLON type ASSIGN exp .) ]
  ! SEMICOLON       [ shift and go to state 78 ]


state 34

    (22) exp -> literal .

    PLUS            reduce using rule 22 (exp -> literal .)
    MINUS           reduce using rule 22 (exp -> literal .)
    TIMES           reduce using rule 22 (exp -> literal .)
    DIVIDE          reduce using rule 22 (exp -> literal .)
    MOD             reduce using rule 22 (exp -> literal .)
    POWER           reduce using rule 22 (exp -> literal .)
    EQUALS          reduce using rule 22 (exp -> literal .)
    NOT_EQUALS      reduce using rule 22 (exp -> literal .)
    LESS            reduce using rule 22 (exp -> literal .)
    LESS_EQUAL      reduce using rule 22 (exp -> literal .)
    GREATER         reduce using rule 22 (exp -> literal .)
    GREATER_EQUAL   reduce using rule 22 (exp -> literal .)
    AND             reduce using rule 22 (exp -> literal .)
    OR              reduce using rule 22 (exp -> literal .)
    SEMICOLON       reduce using rule 22 (exp -> literal .)
    LET             reduce using rule 22 (exp -> literal .)
    $end            reduce using rule 22 (exp -> literal .)
    RPAREN          reduce using rule 22 (exp -> literal .)
    THEN            reduce using rule 22 (exp -> literal .)
    DO              reduce using rule 22 (exp -> literal .)
    COMMA           reduce using rule 22 (exp -> literal .)
    RBRACKET        reduce using rule 22 (exp -> literal .)
    ELSE            reduce using rule 22 (exp -> literal .)
    BAR             reduce using rule 22 (exp -> literal .)


state 35

    (23) exp -> binary_exp .

    PLUS            reduce using rule 23 (exp -> binary_exp .)
    MINUS           reduce using rule 23 (exp -> binary_exp .)
    TIMES           reduce using rule 23 (exp -> binary_exp .)
    DIVIDE          reduce using rule 23 (exp -> binary_exp .)
    MOD             reduce using rule 23 (exp -> binary_exp .)
    POWER           reduce using rule 23 (exp -> binary_exp .)
    EQUALS          reduce using rule 23 (exp -> binary_exp .)
    NOT_EQUALS      reduce using rule 23 (exp -> binary_exp .)
    LESS            reduce using rule 23 (exp -> binary_exp .)
    LESS_EQUAL      reduce using rule 23 (exp -> binary_exp .)
    GREATER         reduce using rule 23 (exp -> binary_exp .)
    GREATER_EQUAL   reduce using rule 23 (exp -> binary_exp .)
    AND             reduce using rule 23 (exp -> binary_exp .)
    OR              reduce using rule 23 (exp -> binary_exp .)
    SEMICOLON       reduce using rule 23 (exp -> binary_exp .)
    LET             reduce using rule 23 (exp -> binary_exp .)
    $end            reduce using rule 23 (exp -> binary_exp .)
    RPAREN          reduce using rule 23 (exp -> binary_exp .)
    THEN            reduce using rule 23 (exp -> binary_exp .)
    DO              reduce using rule 23 (exp -> binary_exp .)
    COMMA           reduce using rule 23 (exp -> binary_exp .)
    RBRACKET        reduce using rule 23 (exp -> binary_exp .)
    ELSE            reduce using rule 23 (exp -> binary_exp .)
    BAR             reduce using rule 23 (exp -> binary_exp .)


state 36

    (24) exp -> unary_exp .

    PLUS            reduce using rule 24 (exp -> unary_exp .)
    MINUS           reduce using rule 24 (exp -> unary_exp .)
    TIMES           reduce using rule 24 (exp -> unary_exp .)
    DIVIDE          reduce using rule 24 (exp -> unary_exp .)
    MOD             reduce using rule 24 (exp -> unary_exp .)
    POWER           reduce using rule 24 (exp -> unary_exp .)
    EQUALS          reduce using rule 24 (exp -> unary_exp .)
    NOT_EQUALS      reduce using rule 24 (exp -> unary_exp .)
    LESS            reduce using rule 24 (exp -> unary_exp .)
    LESS_EQUAL      reduce using rule 24 (exp -> unary_exp .)
    GREATER         reduce using rule 24 (exp -> unary_exp .)
    GREATER_EQUAL   reduce using rule 24 (exp -> unary_exp .)
    AND             reduce using rule 24 (exp -> unary_exp .)
    OR              reduce using rule 24 (exp -> unary_exp .)
    SEMICOLON       reduce using rule 24 (exp -> unary_exp .)
    LET             reduce using rule 24 (exp -> unary_exp .)
    $end            reduce using rule 24 (exp -> unary_exp .)
    RPAREN          reduce using rule 24 (exp -> unary_exp .)
    THEN            reduce using rule 24 (exp -> unary_exp .)
    DO              reduce using rule 24 (exp -> unary_exp .)
    COMMA           reduce using rule 24 (exp -> unary_exp .)
    RBRACKET        reduce using rule 24 (exp -> unary_exp .)
    ELSE            reduce using rule 24 (exp -> unary_exp .)
    BAR             reduce using rule 24 (exp -> unary_exp .)


state 37

    (25) exp -> function_call .

    PLUS            reduce using rule 25 (exp -> function_call .)
    MINUS           reduce using rule 25 (exp -> function_call .)
    TIMES           reduce using rule 25 (exp -> function_call .)
    DIVIDE          reduce using rule 25 (exp -> function_call .)
    MOD             reduce using rule 25 (exp -> function_call .)
    POWER           reduce using rule 25 (exp -> function_call .)
    EQUALS          reduce using rule 25 (exp -> function_call .)
    NOT_EQUALS      reduce using rule 25 (exp -> function_call .)
    LESS            reduce using rule 25 (exp -> function_call .)
    LESS_EQUAL      reduce using rule 25 (exp -> function_call .)
    GREATER         reduce using rule 25 (exp -> function_call .)
    GREATER_EQUAL   reduce using rule 25 (exp -> function_call .)
    AND             reduce using rule 25 (exp -> function_call .)
    OR              reduce using rule 25 (exp -> function_call .)
    SEMICOLON       reduce using rule 25 (exp -> function_call .)
    LET             reduce using rule 25 (exp -> function_call .)
    $end            reduce using rule 25 (exp -> function_call .)
    RPAREN          reduce using rule 25 (exp -> function_call .)
    THEN            reduce using rule 25 (exp -> function_call .)
    DO              reduce using rule 25 (exp -> function_call .)
    COMMA           reduce using rule 25 (exp -> function_call .)
    RBRACKET        reduce using rule 25 (exp -> function_call .)
    ELSE            reduce using rule 25 (exp -> function_call .)
    BAR             reduce using rule 25 (exp -> function_call .)


state 38

    (26) exp -> assignment .

    PLUS            reduce using rule 26 (exp -> assignment .)
    MINUS           reduce using rule 26 (exp -> assignment .)
    TIMES           reduce using rule 26 (exp -> assignment .)
    DIVIDE          reduce using rule 26 (exp -> assignment .)
    MOD             reduce using rule 26 (exp -> assignment .)
    POWER           reduce using rule 26 (exp -> assignment .)
    EQUALS          reduce using rule 26 (exp -> assignment .)
    NOT_EQUALS      reduce using rule 26 (exp -> assignment .)
    LESS            reduce using rule 26 (exp -> assignment .)
    LESS_EQUAL      reduce using rule 26 (exp -> assignment .)
    GREATER         reduce using rule 26 (exp -> assignment .)
    GREATER_EQUAL   reduce using rule 26 (exp -> assignment .)
    AND             reduce using rule 26 (exp -> assignment .)
    OR              reduce using rule 26 (exp -> assignment .)
    SEMICOLON       reduce using rule 26 (exp -> assignment .)
    LET             reduce using rule 26 (exp -> assignment .)
    $end            reduce using rule 26 (exp -> assignment .)
    RPAREN          reduce using rule 26 (exp -> assignment .)
    THEN            reduce using rule 26 (exp -> assignment .)
    DO              reduce using rule 26 (exp -> assignment .)
    COMMA           reduce using rule 26 (exp -> assignment .)
    RBRACKET        reduce using rule 26 (exp -> assignment .)
    ELSE            reduce using rule 26 (exp -> assignment .)
    BAR             reduce using rule 26 (exp -> assignment .)


state 39

    (27) exp -> variable_declaration .

    PLUS            reduce using rule 27 (exp -> variable_declaration .)
    MINUS           reduce using rule 27 (exp -> variable_declaration .)
    TIMES           reduce using rule 27 (exp -> variable_declaration .)
    DIVIDE          reduce using rule 27 (exp -> variable_declaration .)
    MOD             reduce using rule 27 (exp -> variable_declaration .)
    POWER           reduce using rule 27 (exp -> variable_declaration .)
    EQUALS          reduce using rule 27 (exp -> variable_declaration .)
    NOT_EQUALS      reduce using rule 27 (exp -> variable_declaration .)
    LESS            reduce using rule 27 (exp -> variable_declaration .)
    LESS_EQUAL      reduce using rule 27 (exp -> variable_declaration .)
    GREATER         reduce using rule 27 (exp -> variable_declaration .)
    GREATER_EQUAL   reduce using rule 27 (exp -> variable_declaration .)
    AND             reduce using rule 27 (exp -> variable_declaration .)
    OR              reduce using rule 27 (exp -> variable_declaration .)
    SEMICOLON       reduce using rule 27 (exp -> variable_declaration .)
    LET             reduce using rule 27 (exp -> variable_declaration .)
    $end            reduce using rule 27 (exp -> variable_declaration .)
    RPAREN          reduce using rule 27 (exp -> variable_declaration .)
    THEN            reduce using rule 27 (exp -> variable_declaration .)
    DO              reduce using rule 27 (exp -> variable_declaration .)
    COMMA           reduce using rule 27 (exp -> variable_declaration .)
    RBRACKET        reduce using rule 27 (exp -> variable_declaration .)
    ELSE            reduce using rule 27 (exp -> variable_declaration .)
    BAR             reduce using rule 27 (exp -> variable_declaration .)


state 40

    (28) exp -> if_then_else .

    PLUS            reduce using rule 28 (exp -> if_then_else .)
    MINUS           reduce using rule 28 (exp -> if_then_else .)
    TIMES           reduce using rule 28 (exp -> if_then_else .)
    DIVIDE          reduce using rule 28 (exp -> if_then_else .)
    MOD             reduce using rule 28 (exp -> if_then_else .)
    POWER           reduce using rule 28 (exp -> if_then_else .)
    EQUALS          reduce using rule 28 (exp -> if_then_else .)
    NOT_EQUALS      reduce using rule 28 (exp -> if_then_else .)
    LESS            reduce using rule 28 (exp -> if_then_else .)
    LESS_EQUAL      reduce using rule 28 (exp -> if_then_else .)
    GREATER         reduce using rule 28 (exp -> if_then_else .)
    GREATER_EQUAL   reduce using rule 28 (exp -> if_then_else .)
    AND             reduce using rule 28 (exp -> if_then_else .)
    OR              reduce using rule 28 (exp -> if_then_else .)
    SEMICOLON       reduce using rule 28 (exp -> if_then_else .)
    LET             reduce using rule 28 (exp -> if_then_else .)
    $end            reduce using rule 28 (exp -> if_then_else .)
    RPAREN          reduce using rule 28 (exp -> if_then_else .)
    THEN            reduce using rule 28 (exp -> if_then_else .)
    DO              reduce using rule 28 (exp -> if_then_else .)
    COMMA           reduce using rule 28 (exp -> if_then_else .)
    RBRACKET        reduce using rule 28 (exp -> if_then_else .)
    ELSE            reduce using rule 28 (exp -> if_then_else .)
    BAR             reduce using rule 28 (exp -> if_then_else .)


state 41

    (29) exp -> if_then .

    PLUS            reduce using rule 29 (exp -> if_then .)
    MINUS           reduce using rule 29 (exp -> if_then .)
    TIMES           reduce using rule 29 (exp -> if_then .)
    DIVIDE          reduce using rule 29 (exp -> if_then .)
    MOD             reduce using rule 29 (exp -> if_then .)
    POWER           reduce using rule 29 (exp -> if_then .)
    EQUALS          reduce using rule 29 (exp -> if_then .)
    NOT_EQUALS      reduce using rule 29 (exp -> if_then .)
    LESS            reduce using rule 29 (exp -> if_then .)
    LESS_EQUAL      reduce using rule 29 (exp -> if_then .)
    GREATER         reduce using rule 29 (exp -> if_then .)
    GREATER_EQUAL   reduce using rule 29 (exp -> if_then .)
    AND             reduce using rule 29 (exp -> if_then .)
    OR              reduce using rule 29 (exp -> if_then .)
    SEMICOLON       reduce using rule 29 (exp -> if_then .)
    LET             reduce using rule 29 (exp -> if_then .)
    $end            reduce using rule 29 (exp -> if_then .)
    RPAREN          reduce using rule 29 (exp -> if_then .)
    THEN            reduce using rule 29 (exp -> if_then .)
    DO              reduce using rule 29 (exp -> if_then .)
    COMMA           reduce using rule 29 (exp -> if_then .)
    RBRACKET        reduce using rule 29 (exp -> if_then .)
    ELSE            reduce using rule 29 (exp -> if_then .)
    BAR             reduce using rule 29 (exp -> if_then .)


state 42

    (30) exp -> while_loop .

    PLUS            reduce using rule 30 (exp -> while_loop .)
    MINUS           reduce using rule 30 (exp -> while_loop .)
    TIMES           reduce using rule 30 (exp -> while_loop .)
    DIVIDE          reduce using rule 30 (exp -> while_loop .)
    MOD             reduce using rule 30 (exp -> while_loop .)
    POWER           reduce using rule 30 (exp -> while_loop .)
    EQUALS          reduce using rule 30 (exp -> while_loop .)
    NOT_EQUALS      reduce using rule 30 (exp -> while_loop .)
    LESS            reduce using rule 30 (exp -> while_loop .)
    LESS_EQUAL      reduce using rule 30 (exp -> while_loop .)
    GREATER         reduce using rule 30 (exp -> while_loop .)
    GREATER_EQUAL   reduce using rule 30 (exp -> while_loop .)
    AND             reduce using rule 30 (exp -> while_loop .)
    OR              reduce using rule 30 (exp -> while_loop .)
    SEMICOLON       reduce using rule 30 (exp -> while_loop .)
    LET             reduce using rule 30 (exp -> while_loop .)
    $end            reduce using rule 30 (exp -> while_loop .)
    RPAREN          reduce using rule 30 (exp -> while_loop .)
    THEN            reduce using rule 30 (exp -> while_loop .)
    DO              reduce using rule 30 (exp -> while_loop .)
    COMMA           reduce using rule 30 (exp -> while_loop .)
    RBRACKET        reduce using rule 30 (exp -> while_loop .)
    ELSE            reduce using rule 30 (exp -> while_loop .)
    BAR             reduce using rule 30 (exp -> while_loop .)


state 43

    (31) exp -> array_creation .

    PLUS            reduce using rule 31 (exp -> array_creation .)
    MINUS           reduce using rule 31 (exp -> array_creation .)
    TIMES           reduce using rule 31 (exp -> array_creation .)
    DIVIDE          reduce using rule 31 (exp -> array_creation .)
    MOD             reduce using rule 31 (exp -> array_creation .)
    POWER           reduce using rule 31 (exp -> array_creation .)
    EQUALS          reduce using rule 31 (exp -> array_creation .)
    NOT_EQUALS      reduce using rule 31 (exp -> array_creation .)
    LESS            reduce using rule 31 (exp -> array_creation .)
    LESS_EQUAL      reduce using rule 31 (exp -> array_creation .)
    GREATER         reduce using rule 31 (exp -> array_creation .)
    GREATER_EQUAL   reduce using rule 31 (exp -> array_creation .)
    AND             reduce using rule 31 (exp -> array_creation .)
    OR              reduce using rule 31 (exp -> array_creation .)
    SEMICOLON       reduce using rule 31 (exp -> array_creation .)
    LET             reduce using rule 31 (exp -> array_creation .)
    $end            reduce using rule 31 (exp -> array_creation .)
    RPAREN          reduce using rule 31 (exp -> array_creation .)
    THEN            reduce using rule 31 (exp -> array_creation .)
    DO              reduce using rule 31 (exp -> array_creation .)
    COMMA           reduce using rule 31 (exp -> array_creation .)
    RBRACKET        reduce using rule 31 (exp -> array_creation .)
    ELSE            reduce using rule 31 (exp -> array_creation .)
    BAR             reduce using rule 31 (exp -> array_creation .)


state 44

    (32) exp -> array_access .
    (65) lhs -> array_access .

    PLUS            reduce using rule 32 (exp -> array_access .)
    MINUS           reduce using rule 32 (exp -> array_access .)
    TIMES           reduce using rule 32 (exp -> array_access .)
    DIVIDE          reduce using rule 32 (exp -> array_access .)
    MOD             reduce using rule 32 (exp -> array_access .)
    POWER           reduce using rule 32 (exp -> array_access .)
    EQUALS          reduce using rule 32 (exp -> array_access .)
    NOT_EQUALS      reduce using rule 32 (exp -> array_access .)
    LESS            reduce using rule 32 (exp -> array_access .)
    LESS_EQUAL      reduce using rule 32 (exp -> array_access .)
    GREATER         reduce using rule 32 (exp -> array_access .)
    GREATER_EQUAL   reduce using rule 32 (exp -> array_access .)
    AND             reduce using rule 32 (exp -> array_access .)
    OR              reduce using rule 32 (exp -> array_access .)
    SEMICOLON       reduce using rule 32 (exp -> array_access .)
    LET             reduce using rule 32 (exp -> array_access .)
    $end            reduce using rule 32 (exp -> array_access .)
    RPAREN          reduce using rule 32 (exp -> array_access .)
    THEN            reduce using rule 32 (exp -> array_access .)
    DO              reduce using rule 32 (exp -> array_access .)
    COMMA           reduce using rule 32 (exp -> array_access .)
    RBRACKET        reduce using rule 32 (exp -> array_access .)
    ELSE            reduce using rule 32 (exp -> array_access .)
    BAR             reduce using rule 32 (exp -> array_access .)
    LBRACKET        reduce using rule 65 (lhs -> array_access .)


state 45

    (33) exp -> group .

    PLUS            reduce using rule 33 (exp -> group .)
    MINUS           reduce using rule 33 (exp -> group .)
    TIMES           reduce using rule 33 (exp -> group .)
    DIVIDE          reduce using rule 33 (exp -> group .)
    MOD             reduce using rule 33 (exp -> group .)
    POWER           reduce using rule 33 (exp -> group .)
    EQUALS          reduce using rule 33 (exp -> group .)
    NOT_EQUALS      reduce using rule 33 (exp -> group .)
    LESS            reduce using rule 33 (exp -> group .)
    LESS_EQUAL      reduce using rule 33 (exp -> group .)
    GREATER         reduce using rule 33 (exp -> group .)
    GREATER_EQUAL   reduce using rule 33 (exp -> group .)
    AND             reduce using rule 33 (exp -> group .)
    OR              reduce using rule 33 (exp -> group .)
    SEMICOLON       reduce using rule 33 (exp -> group .)
    LET             reduce using rule 33 (exp -> group .)
    $end            reduce using rule 33 (exp -> group .)
    RPAREN          reduce using rule 33 (exp -> group .)
    THEN            reduce using rule 33 (exp -> group .)
    DO              reduce using rule 33 (exp -> group .)
    COMMA           reduce using rule 33 (exp -> group .)
    RBRACKET        reduce using rule 33 (exp -> group .)
    ELSE            reduce using rule 33 (exp -> group .)
    BAR             reduce using rule 33 (exp -> group .)


state 46

    (36) literal -> INT_LITERAL .

    PLUS            reduce using rule 36 (literal -> INT_LITERAL .)
    MINUS           reduce using rule 36 (literal -> INT_LITERAL .)
    TIMES           reduce using rule 36 (literal -> INT_LITERAL .)
    DIVIDE          reduce using rule 36 (literal -> INT_LITERAL .)
    MOD             reduce using rule 36 (literal -> INT_LITERAL .)
    POWER           reduce using rule 36 (literal -> INT_LITERAL .)
    EQUALS          reduce using rule 36 (literal -> INT_LITERAL .)
    NOT_EQUALS      reduce using rule 36 (literal -> INT_LITERAL .)
    LESS            reduce using rule 36 (literal -> INT_LITERAL .)
    LESS_EQUAL      reduce using rule 36 (literal -> INT_LITERAL .)
    GREATER         reduce using rule 36 (literal -> INT_LITERAL .)
    GREATER_EQUAL   reduce using rule 36 (literal -> INT_LITERAL .)
    AND             reduce using rule 36 (literal -> INT_LITERAL .)
    OR              reduce using rule 36 (literal -> INT_LITERAL .)
    SEMICOLON       reduce using rule 36 (literal -> INT_LITERAL .)
    LET             reduce using rule 36 (literal -> INT_LITERAL .)
    $end            reduce using rule 36 (literal -> INT_LITERAL .)
    RPAREN          reduce using rule 36 (literal -> INT_LITERAL .)
    THEN            reduce using rule 36 (literal -> INT_LITERAL .)
    DO              reduce using rule 36 (literal -> INT_LITERAL .)
    COMMA           reduce using rule 36 (literal -> INT_LITERAL .)
    RBRACKET        reduce using rule 36 (literal -> INT_LITERAL .)
    ELSE            reduce using rule 36 (literal -> INT_LITERAL .)
    BAR             reduce using rule 36 (literal -> INT_LITERAL .)


state 47

    (37) literal -> TRUE .

    PLUS            reduce using rule 37 (literal -> TRUE .)
    MINUS           reduce using rule 37 (literal -> TRUE .)
    TIMES           reduce using rule 37 (literal -> TRUE .)
    DIVIDE          reduce using rule 37 (literal -> TRUE .)
    MOD             reduce using rule 37 (literal -> TRUE .)
    POWER           reduce using rule 37 (literal -> TRUE .)
    EQUALS          reduce using rule 37 (literal -> TRUE .)
    NOT_EQUALS      reduce using rule 37 (literal -> TRUE .)
    LESS            reduce using rule 37 (literal -> TRUE .)
    LESS_EQUAL      reduce using rule 37 (literal -> TRUE .)
    GREATER         reduce using rule 37 (literal -> TRUE .)
    GREATER_EQUAL   reduce using rule 37 (literal -> TRUE .)
    AND             reduce using rule 37 (literal -> TRUE .)
    OR              reduce using rule 37 (literal -> TRUE .)
    SEMICOLON       reduce using rule 37 (literal -> TRUE .)
    LET             reduce using rule 37 (literal -> TRUE .)
    $end            reduce using rule 37 (literal -> TRUE .)
    RPAREN          reduce using rule 37 (literal -> TRUE .)
    THEN            reduce using rule 37 (literal -> TRUE .)
    DO              reduce using rule 37 (literal -> TRUE .)
    COMMA           reduce using rule 37 (literal -> TRUE .)
    RBRACKET        reduce using rule 37 (literal -> TRUE .)
    ELSE            reduce using rule 37 (literal -> TRUE .)
    BAR             reduce using rule 37 (literal -> TRUE .)


state 48

    (38) literal -> FALSE .

    PLUS            reduce using rule 38 (literal -> FALSE .)
    MINUS           reduce using rule 38 (literal -> FALSE .)
    TIMES           reduce using rule 38 (literal -> FALSE .)
    DIVIDE          reduce using rule 38 (literal -> FALSE .)
    MOD             reduce using rule 38 (literal -> FALSE .)
    POWER           reduce using rule 38 (literal -> FALSE .)
    EQUALS          reduce using rule 38 (literal -> FALSE .)
    NOT_EQUALS      reduce using rule 38 (literal -> FALSE .)
    LESS            reduce using rule 38 (literal -> FALSE .)
    LESS_EQUAL      reduce using rule 38 (literal -> FALSE .)
    GREATER         reduce using rule 38 (literal -> FALSE .)
    GREATER_EQUAL   reduce using rule 38 (literal -> FALSE .)
    AND             reduce using rule 38 (literal -> FALSE .)
    OR              reduce using rule 38 (literal -> FALSE .)
    SEMICOLON       reduce using rule 38 (literal -> FALSE .)
    LET             reduce using rule 38 (literal -> FALSE .)
    $end            reduce using rule 38 (literal -> FALSE .)
    RPAREN          reduce using rule 38 (literal -> FALSE .)
    THEN            reduce using rule 38 (literal -> FALSE .)
    DO              reduce using rule 38 (literal -> FALSE .)
    COMMA           reduce using rule 38 (literal -> FALSE .)
    RBRACKET        reduce using rule 38 (literal -> FALSE .)
    ELSE            reduce using rule 38 (literal -> FALSE .)
    BAR             reduce using rule 38 (literal -> FALSE .)


state 49

    (39) literal -> NULL .

    PLUS            reduce using rule 39 (literal -> NULL .)
    MINUS           reduce using rule 39 (literal -> NULL .)
    TIMES           reduce using rule 39 (literal -> NULL .)
    DIVIDE          reduce using rule 39 (literal -> NULL .)
    MOD             reduce using rule 39 (literal -> NULL .)
    POWER           reduce using rule 39 (literal -> NULL .)
    EQUALS          reduce using rule 39 (literal -> NULL .)
    NOT_EQUALS      reduce using rule 39 (literal -> NULL .)
    LESS            reduce using rule 39 (literal -> NULL .)
    LESS_EQUAL      reduce using rule 39 (literal -> NULL .)
    GREATER         reduce using rule 39 (literal -> NULL .)
    GREATER_EQUAL   reduce using rule 39 (literal -> NULL .)
    AND             reduce using rule 39 (literal -> NULL .)
    OR              reduce using rule 39 (literal -> NULL .)
    SEMICOLON       reduce using rule 39 (literal -> NULL .)
    LET             reduce using rule 39 (literal -> NULL .)
    $end            reduce using rule 39 (literal -> NULL .)
    RPAREN          reduce using rule 39 (literal -> NULL .)
    THEN            reduce using rule 39 (literal -> NULL .)
    DO              reduce using rule 39 (literal -> NULL .)
    COMMA           reduce using rule 39 (literal -> NULL .)
    RBRACKET        reduce using rule 39 (literal -> NULL .)
    ELSE            reduce using rule 39 (literal -> NULL .)
    BAR             reduce using rule 39 (literal -> NULL .)


state 50

    (40) literal -> UNIT .

    PLUS            reduce using rule 40 (literal -> UNIT .)
    MINUS           reduce using rule 40 (literal -> UNIT .)
    TIMES           reduce using rule 40 (literal -> UNIT .)
    DIVIDE          reduce using rule 40 (literal -> UNIT .)
    MOD             reduce using rule 40 (literal -> UNIT .)
    POWER           reduce using rule 40 (literal -> UNIT .)
    EQUALS          reduce using rule 40 (literal -> UNIT .)
    NOT_EQUALS      reduce using rule 40 (literal -> UNIT .)
    LESS            reduce using rule 40 (literal -> UNIT .)
    LESS_EQUAL      reduce using rule 40 (literal -> UNIT .)
    GREATER         reduce using rule 40 (literal -> UNIT .)
    GREATER_EQUAL   reduce using rule 40 (literal -> UNIT .)
    AND             reduce using rule 40 (literal -> UNIT .)
    OR              reduce using rule 40 (literal -> UNIT .)
    SEMICOLON       reduce using rule 40 (literal -> UNIT .)
    LET             reduce using rule 40 (literal -> UNIT .)
    $end            reduce using rule 40 (literal -> UNIT .)
    RPAREN          reduce using rule 40 (literal -> UNIT .)
    THEN            reduce using rule 40 (literal -> UNIT .)
    DO              reduce using rule 40 (literal -> UNIT .)
    COMMA           reduce using rule 40 (literal -> UNIT .)
    RBRACKET        reduce using rule 40 (literal -> UNIT .)
    ELSE            reduce using rule 40 (literal -> UNIT .)
    BAR             reduce using rule 40 (literal -> UNIT .)


state 51

    (41) literal -> STRING_LITERAL .

    PLUS            reduce using rule 41 (literal -> STRING_LITERAL .)
    MINUS           reduce using rule 41 (literal -> STRING_LITERAL .)
    TIMES           reduce using rule 41 (literal -> STRING_LITERAL .)
    DIVIDE          reduce using rule 41 (literal -> STRING_LITERAL .)
    MOD             reduce using rule 41 (literal -> STRING_LITERAL .)
    POWER           reduce using rule 41 (literal -> STRING_LITERAL .)
    EQUALS          reduce using rule 41 (literal -> STRING_LITERAL .)
    NOT_EQUALS      reduce using rule 41 (literal -> STRING_LITERAL .)
    LESS            reduce using rule 41 (literal -> STRING_LITERAL .)
    LESS_EQUAL      reduce using rule 41 (literal -> STRING_LITERAL .)
    GREATER         reduce using rule 41 (literal -> STRING_LITERAL .)
    GREATER_EQUAL   reduce using rule 41 (literal -> STRING_LITERAL .)
    AND             reduce using rule 41 (literal -> STRING_LITERAL .)
    OR              reduce using rule 41 (literal -> STRING_LITERAL .)
    SEMICOLON       reduce using rule 41 (literal -> STRING_LITERAL .)
    LET             reduce using rule 41 (literal -> STRING_LITERAL .)
    $end            reduce using rule 41 (literal -> STRING_LITERAL .)
    RPAREN          reduce using rule 41 (literal -> STRING_LITERAL .)
    THEN            reduce using rule 41 (literal -> STRING_LITERAL .)
    DO              reduce using rule 41 (literal -> STRING_LITERAL .)
    COMMA           reduce using rule 41 (literal -> STRING_LITERAL .)
    RBRACKET        reduce using rule 41 (literal -> STRING_LITERAL .)
    ELSE            reduce using rule 41 (literal -> STRING_LITERAL .)
    BAR             reduce using rule 41 (literal -> STRING_LITERAL .)


state 52

    (57) unary_exp -> MINUS . exp
    (21) exp -> . variable
    (22) exp -> . literal
    (23) exp -> . binary_exp
    (24) exp -> . unary_exp
    (25) exp -> . function_call
    (26) exp -> . assignment
    (27) exp -> . variable_declaration
    (28) exp -> . if_then_else
    (29) exp -> . if_then
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs ASSIGN exp
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (68) if_then_else -> . IF exp THEN exp ELSE exp
    (69) if_then -> . IF exp THEN exp
    (70) while_loop -> . WHILE exp DO exp
    (71) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (72) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NULL            shift and go to state 49
    UNIT            shift and go to state 50
    STRING_LITERAL  shift and go to state 51
    MINUS           shift and go to state 52
    NOT             shift and go to state 53
    SET             shift and go to state 55
    LET             shift and go to state 31
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    NEW             shift and go to state 59
    LPAREN          shift and go to state 54

    exp                            shift and go to state 79
    variable                       shift and go to state 32
    literal                        shift and go to state 34
    binary_exp                     shift and go to state 35
    unary_exp                      shift and go to state 36
    function_call                  shift and go to state 37
    assignment                     shift and go to state 38
    variable_declaration           shift and go to state 39
    if_then_else                   shift and go to state 40
    if_then                        shift and go to state 41
    while_loop                     shift and go to state 42
    array_creation                 shift and go to state 43
    array_access                   shift and go to state 44
    group                          shift and go to state 45
    lhs                            shift and go to state 56

state 53

    (58) unary_exp -> NOT . exp
    (21) exp -> . variable
    (22) exp -> . literal
    (23) exp -> . binary_exp
    (24) exp -> . unary_exp
    (25) exp -> . function_call
    (26) exp -> . assignment
    (27) exp -> . variable_declaration
    (28) exp -> . if_then_else
    (29) exp -> . if_then
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs ASSIGN exp
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (68) if_then_else -> . IF exp THEN exp ELSE exp
    (69) if_then -> . IF exp THEN exp
    (70) while_loop -> . WHILE exp DO exp
    (71) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (72) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NULL            shift and go to state 49
    UNIT            shift and go to state 50
    STRING_LITERAL  shift and go to state 51
    MINUS           shift and go to state 52
    NOT             shift and go to state 53
    SET             shift and go to state 55
    LET             shift and go to state 31
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    NEW             shift and go to state 59
    LPAREN          shift and go to state 54

    exp                            shift and go to state 80
    variable                       shift and go to state 32
    literal                        shift and go to state 34
    binary_exp                     shift and go to state 35
    unary_exp                      shift and go to state 36
    function_call                  shift and go to state 37
    assignment                     shift and go to state 38
    variable_declaration           shift and go to state 39
    if_then_else                   shift and go to state 40
    if_then                        shift and go to state 41
    while_loop                     shift and go to state 42
    array_creation                 shift and go to state 43
    array_access                   shift and go to state 44
    group                          shift and go to state 45
    lhs                            shift and go to state 56

state 54

    (72) group -> LPAREN . exp RPAREN
    (21) exp -> . variable
    (22) exp -> . literal
    (23) exp -> . binary_exp
    (24) exp -> . unary_exp
    (25) exp -> . function_call
    (26) exp -> . assignment
    (27) exp -> . variable_declaration
    (28) exp -> . if_then_else
    (29) exp -> . if_then
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs ASSIGN exp
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (68) if_then_else -> . IF exp THEN exp ELSE exp
    (69) if_then -> . IF exp THEN exp
    (70) while_loop -> . WHILE exp DO exp
    (71) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (72) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NULL            shift and go to state 49
    UNIT            shift and go to state 50
    STRING_LITERAL  shift and go to state 51
    MINUS           shift and go to state 52
    NOT             shift and go to state 53
    SET             shift and go to state 55
    LET             shift and go to state 31
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    NEW             shift and go to state 59
    LPAREN          shift and go to state 54

    exp                            shift and go to state 81
    variable                       shift and go to state 32
    literal                        shift and go to state 34
    binary_exp                     shift and go to state 35
    unary_exp                      shift and go to state 36
    function_call                  shift and go to state 37
    assignment                     shift and go to state 38
    variable_declaration           shift and go to state 39
    if_then_else                   shift and go to state 40
    if_then                        shift and go to state 41
    while_loop                     shift and go to state 42
    array_creation                 shift and go to state 43
    array_access                   shift and go to state 44
    group                          shift and go to state 45
    lhs                            shift and go to state 56

state 55

    (63) assignment -> SET . lhs ASSIGN exp
    (64) lhs -> . variable
    (65) lhs -> . array_access
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (66) array_access -> . lhs LBRACKET exp RBRACKET

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12

    lhs                            shift and go to state 82
    variable                       shift and go to state 83
    array_access                   shift and go to state 84

state 56

    (66) array_access -> lhs . LBRACKET exp RBRACKET

    LBRACKET        shift and go to state 85


state 57

    (68) if_then_else -> IF . exp THEN exp ELSE exp
    (69) if_then -> IF . exp THEN exp
    (21) exp -> . variable
    (22) exp -> . literal
    (23) exp -> . binary_exp
    (24) exp -> . unary_exp
    (25) exp -> . function_call
    (26) exp -> . assignment
    (27) exp -> . variable_declaration
    (28) exp -> . if_then_else
    (29) exp -> . if_then
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs ASSIGN exp
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (68) if_then_else -> . IF exp THEN exp ELSE exp
    (69) if_then -> . IF exp THEN exp
    (70) while_loop -> . WHILE exp DO exp
    (71) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (72) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NULL            shift and go to state 49
    UNIT            shift and go to state 50
    STRING_LITERAL  shift and go to state 51
    MINUS           shift and go to state 52
    NOT             shift and go to state 53
    SET             shift and go to state 55
    LET             shift and go to state 31
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    NEW             shift and go to state 59
    LPAREN          shift and go to state 54

    exp                            shift and go to state 86
    variable                       shift and go to state 32
    literal                        shift and go to state 34
    binary_exp                     shift and go to state 35
    unary_exp                      shift and go to state 36
    function_call                  shift and go to state 37
    assignment                     shift and go to state 38
    variable_declaration           shift and go to state 39
    if_then_else                   shift and go to state 40
    if_then                        shift and go to state 41
    while_loop                     shift and go to state 42
    array_creation                 shift and go to state 43
    array_access                   shift and go to state 44
    group                          shift and go to state 45
    lhs                            shift and go to state 56

state 58

    (70) while_loop -> WHILE . exp DO exp
    (21) exp -> . variable
    (22) exp -> . literal
    (23) exp -> . binary_exp
    (24) exp -> . unary_exp
    (25) exp -> . function_call
    (26) exp -> . assignment
    (27) exp -> . variable_declaration
    (28) exp -> . if_then_else
    (29) exp -> . if_then
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs ASSIGN exp
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (68) if_then_else -> . IF exp THEN exp ELSE exp
    (69) if_then -> . IF exp THEN exp
    (70) while_loop -> . WHILE exp DO exp
    (71) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (72) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NULL            shift and go to state 49
    UNIT            shift and go to state 50
    STRING_LITERAL  shift and go to state 51
    MINUS           shift and go to state 52
    NOT             shift and go to state 53
    SET             shift and go to state 55
    LET             shift and go to state 31
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    NEW             shift and go to state 59
    LPAREN          shift and go to state 54

    exp                            shift and go to state 87
    variable                       shift and go to state 32
    literal                        shift and go to state 34
    binary_exp                     shift and go to state 35
    unary_exp                      shift and go to state 36
    function_call                  shift and go to state 37
    assignment                     shift and go to state 38
    variable_declaration           shift and go to state 39
    if_then_else                   shift and go to state 40
    if_then                        shift and go to state 41
    while_loop                     shift and go to state 42
    array_creation                 shift and go to state 43
    array_access                   shift and go to state 44
    group                          shift and go to state 45
    lhs                            shift and go to state 56

state 59

    (71) array_creation -> NEW . type LBRACKET exp BAR exp RBRACKET
    (11) type -> . INT_TYPE
    (12) type -> . STRING_TYPE
    (13) type -> . UNIT_TYPE
    (14) type -> . BOOL_TYPE
    (15) type -> . array_type
    (16) array_type -> . type LBRACKET RBRACKET

    INT_TYPE        shift and go to state 17
    STRING_TYPE     shift and go to state 18
    UNIT_TYPE       shift and go to state 19
    BOOL_TYPE       shift and go to state 20

    type                           shift and go to state 88
    array_type                     shift and go to state 21

state 60

    (16) array_type -> type LBRACKET RBRACKET .

    ASSIGN          reduce using rule 16 (array_type -> type LBRACKET RBRACKET .)
    LBRACKET        reduce using rule 16 (array_type -> type LBRACKET RBRACKET .)
    ARROW           reduce using rule 16 (array_type -> type LBRACKET RBRACKET .)
    COMMA           reduce using rule 16 (array_type -> type LBRACKET RBRACKET .)
    RPAREN          reduce using rule 16 (array_type -> type LBRACKET RBRACKET .)


state 61

    (7) function_declaration -> LET ID LPAREN parameters RPAREN COLON . function_type ASSIGN exp
    (17) function_type -> . type ARROW type
    (18) function_type -> . LPAREN type function_type_tail RPAREN ARROW type
    (11) type -> . INT_TYPE
    (12) type -> . STRING_TYPE
    (13) type -> . UNIT_TYPE
    (14) type -> . BOOL_TYPE
    (15) type -> . array_type
    (16) array_type -> . type LBRACKET RBRACKET

    LPAREN          shift and go to state 89
    INT_TYPE        shift and go to state 17
    STRING_TYPE     shift and go to state 18
    UNIT_TYPE       shift and go to state 19
    BOOL_TYPE       shift and go to state 20

    function_type                  shift and go to state 90
    type                           shift and go to state 91
    array_type                     shift and go to state 21

state 62

    (9) parameters_tail -> COMMA variable . parameters_tail
    (9) parameters_tail -> . COMMA variable parameters_tail
    (10) parameters_tail -> . empty
    (73) empty -> .

    COMMA           shift and go to state 29
    RPAREN          reduce using rule 73 (empty -> .)

    parameters_tail                shift and go to state 92
    empty                          shift and go to state 30

state 63

    (59) function_call -> variable LPAREN . arguments RPAREN
    (60) arguments -> . exp arguments_tail
    (21) exp -> . variable
    (22) exp -> . literal
    (23) exp -> . binary_exp
    (24) exp -> . unary_exp
    (25) exp -> . function_call
    (26) exp -> . assignment
    (27) exp -> . variable_declaration
    (28) exp -> . if_then_else
    (29) exp -> . if_then
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs ASSIGN exp
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (68) if_then_else -> . IF exp THEN exp ELSE exp
    (69) if_then -> . IF exp THEN exp
    (70) while_loop -> . WHILE exp DO exp
    (71) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (72) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NULL            shift and go to state 49
    UNIT            shift and go to state 50
    STRING_LITERAL  shift and go to state 51
    MINUS           shift and go to state 52
    NOT             shift and go to state 53
    SET             shift and go to state 55
    LET             shift and go to state 31
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    NEW             shift and go to state 59
    LPAREN          shift and go to state 54

    variable                       shift and go to state 32
    arguments                      shift and go to state 93
    exp                            shift and go to state 94
    literal                        shift and go to state 34
    binary_exp                     shift and go to state 35
    unary_exp                      shift and go to state 36
    function_call                  shift and go to state 37
    assignment                     shift and go to state 38
    variable_declaration           shift and go to state 39
    if_then_else                   shift and go to state 40
    if_then                        shift and go to state 41
    while_loop                     shift and go to state 42
    array_creation                 shift and go to state 43
    array_access                   shift and go to state 44
    group                          shift and go to state 45
    lhs                            shift and go to state 56

state 64

    (42) binary_exp -> exp PLUS . exp
    (21) exp -> . variable
    (22) exp -> . literal
    (23) exp -> . binary_exp
    (24) exp -> . unary_exp
    (25) exp -> . function_call
    (26) exp -> . assignment
    (27) exp -> . variable_declaration
    (28) exp -> . if_then_else
    (29) exp -> . if_then
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs ASSIGN exp
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (68) if_then_else -> . IF exp THEN exp ELSE exp
    (69) if_then -> . IF exp THEN exp
    (70) while_loop -> . WHILE exp DO exp
    (71) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (72) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NULL            shift and go to state 49
    UNIT            shift and go to state 50
    STRING_LITERAL  shift and go to state 51
    MINUS           shift and go to state 52
    NOT             shift and go to state 53
    SET             shift and go to state 55
    LET             shift and go to state 31
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    NEW             shift and go to state 59
    LPAREN          shift and go to state 54

    exp                            shift and go to state 95
    variable                       shift and go to state 32
    literal                        shift and go to state 34
    binary_exp                     shift and go to state 35
    unary_exp                      shift and go to state 36
    function_call                  shift and go to state 37
    assignment                     shift and go to state 38
    variable_declaration           shift and go to state 39
    if_then_else                   shift and go to state 40
    if_then                        shift and go to state 41
    while_loop                     shift and go to state 42
    array_creation                 shift and go to state 43
    array_access                   shift and go to state 44
    group                          shift and go to state 45
    lhs                            shift and go to state 56

state 65

    (43) binary_exp -> exp MINUS . exp
    (21) exp -> . variable
    (22) exp -> . literal
    (23) exp -> . binary_exp
    (24) exp -> . unary_exp
    (25) exp -> . function_call
    (26) exp -> . assignment
    (27) exp -> . variable_declaration
    (28) exp -> . if_then_else
    (29) exp -> . if_then
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs ASSIGN exp
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (68) if_then_else -> . IF exp THEN exp ELSE exp
    (69) if_then -> . IF exp THEN exp
    (70) while_loop -> . WHILE exp DO exp
    (71) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (72) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NULL            shift and go to state 49
    UNIT            shift and go to state 50
    STRING_LITERAL  shift and go to state 51
    MINUS           shift and go to state 52
    NOT             shift and go to state 53
    SET             shift and go to state 55
    LET             shift and go to state 31
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    NEW             shift and go to state 59
    LPAREN          shift and go to state 54

    exp                            shift and go to state 96
    variable                       shift and go to state 32
    literal                        shift and go to state 34
    binary_exp                     shift and go to state 35
    unary_exp                      shift and go to state 36
    function_call                  shift and go to state 37
    assignment                     shift and go to state 38
    variable_declaration           shift and go to state 39
    if_then_else                   shift and go to state 40
    if_then                        shift and go to state 41
    while_loop                     shift and go to state 42
    array_creation                 shift and go to state 43
    array_access                   shift and go to state 44
    group                          shift and go to state 45
    lhs                            shift and go to state 56

state 66

    (44) binary_exp -> exp TIMES . exp
    (21) exp -> . variable
    (22) exp -> . literal
    (23) exp -> . binary_exp
    (24) exp -> . unary_exp
    (25) exp -> . function_call
    (26) exp -> . assignment
    (27) exp -> . variable_declaration
    (28) exp -> . if_then_else
    (29) exp -> . if_then
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs ASSIGN exp
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (68) if_then_else -> . IF exp THEN exp ELSE exp
    (69) if_then -> . IF exp THEN exp
    (70) while_loop -> . WHILE exp DO exp
    (71) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (72) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NULL            shift and go to state 49
    UNIT            shift and go to state 50
    STRING_LITERAL  shift and go to state 51
    MINUS           shift and go to state 52
    NOT             shift and go to state 53
    SET             shift and go to state 55
    LET             shift and go to state 31
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    NEW             shift and go to state 59
    LPAREN          shift and go to state 54

    exp                            shift and go to state 97
    variable                       shift and go to state 32
    literal                        shift and go to state 34
    binary_exp                     shift and go to state 35
    unary_exp                      shift and go to state 36
    function_call                  shift and go to state 37
    assignment                     shift and go to state 38
    variable_declaration           shift and go to state 39
    if_then_else                   shift and go to state 40
    if_then                        shift and go to state 41
    while_loop                     shift and go to state 42
    array_creation                 shift and go to state 43
    array_access                   shift and go to state 44
    group                          shift and go to state 45
    lhs                            shift and go to state 56

state 67

    (45) binary_exp -> exp DIVIDE . exp
    (21) exp -> . variable
    (22) exp -> . literal
    (23) exp -> . binary_exp
    (24) exp -> . unary_exp
    (25) exp -> . function_call
    (26) exp -> . assignment
    (27) exp -> . variable_declaration
    (28) exp -> . if_then_else
    (29) exp -> . if_then
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs ASSIGN exp
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (68) if_then_else -> . IF exp THEN exp ELSE exp
    (69) if_then -> . IF exp THEN exp
    (70) while_loop -> . WHILE exp DO exp
    (71) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (72) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NULL            shift and go to state 49
    UNIT            shift and go to state 50
    STRING_LITERAL  shift and go to state 51
    MINUS           shift and go to state 52
    NOT             shift and go to state 53
    SET             shift and go to state 55
    LET             shift and go to state 31
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    NEW             shift and go to state 59
    LPAREN          shift and go to state 54

    exp                            shift and go to state 98
    variable                       shift and go to state 32
    literal                        shift and go to state 34
    binary_exp                     shift and go to state 35
    unary_exp                      shift and go to state 36
    function_call                  shift and go to state 37
    assignment                     shift and go to state 38
    variable_declaration           shift and go to state 39
    if_then_else                   shift and go to state 40
    if_then                        shift and go to state 41
    while_loop                     shift and go to state 42
    array_creation                 shift and go to state 43
    array_access                   shift and go to state 44
    group                          shift and go to state 45
    lhs                            shift and go to state 56

state 68

    (46) binary_exp -> exp MOD . exp
    (21) exp -> . variable
    (22) exp -> . literal
    (23) exp -> . binary_exp
    (24) exp -> . unary_exp
    (25) exp -> . function_call
    (26) exp -> . assignment
    (27) exp -> . variable_declaration
    (28) exp -> . if_then_else
    (29) exp -> . if_then
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs ASSIGN exp
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (68) if_then_else -> . IF exp THEN exp ELSE exp
    (69) if_then -> . IF exp THEN exp
    (70) while_loop -> . WHILE exp DO exp
    (71) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (72) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NULL            shift and go to state 49
    UNIT            shift and go to state 50
    STRING_LITERAL  shift and go to state 51
    MINUS           shift and go to state 52
    NOT             shift and go to state 53
    SET             shift and go to state 55
    LET             shift and go to state 31
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    NEW             shift and go to state 59
    LPAREN          shift and go to state 54

    exp                            shift and go to state 99
    variable                       shift and go to state 32
    literal                        shift and go to state 34
    binary_exp                     shift and go to state 35
    unary_exp                      shift and go to state 36
    function_call                  shift and go to state 37
    assignment                     shift and go to state 38
    variable_declaration           shift and go to state 39
    if_then_else                   shift and go to state 40
    if_then                        shift and go to state 41
    while_loop                     shift and go to state 42
    array_creation                 shift and go to state 43
    array_access                   shift and go to state 44
    group                          shift and go to state 45
    lhs                            shift and go to state 56

state 69

    (47) binary_exp -> exp POWER . exp
    (21) exp -> . variable
    (22) exp -> . literal
    (23) exp -> . binary_exp
    (24) exp -> . unary_exp
    (25) exp -> . function_call
    (26) exp -> . assignment
    (27) exp -> . variable_declaration
    (28) exp -> . if_then_else
    (29) exp -> . if_then
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs ASSIGN exp
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (68) if_then_else -> . IF exp THEN exp ELSE exp
    (69) if_then -> . IF exp THEN exp
    (70) while_loop -> . WHILE exp DO exp
    (71) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (72) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NULL            shift and go to state 49
    UNIT            shift and go to state 50
    STRING_LITERAL  shift and go to state 51
    MINUS           shift and go to state 52
    NOT             shift and go to state 53
    SET             shift and go to state 55
    LET             shift and go to state 31
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    NEW             shift and go to state 59
    LPAREN          shift and go to state 54

    exp                            shift and go to state 100
    variable                       shift and go to state 32
    literal                        shift and go to state 34
    binary_exp                     shift and go to state 35
    unary_exp                      shift and go to state 36
    function_call                  shift and go to state 37
    assignment                     shift and go to state 38
    variable_declaration           shift and go to state 39
    if_then_else                   shift and go to state 40
    if_then                        shift and go to state 41
    while_loop                     shift and go to state 42
    array_creation                 shift and go to state 43
    array_access                   shift and go to state 44
    group                          shift and go to state 45
    lhs                            shift and go to state 56

state 70

    (48) binary_exp -> exp EQUALS . exp
    (21) exp -> . variable
    (22) exp -> . literal
    (23) exp -> . binary_exp
    (24) exp -> . unary_exp
    (25) exp -> . function_call
    (26) exp -> . assignment
    (27) exp -> . variable_declaration
    (28) exp -> . if_then_else
    (29) exp -> . if_then
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs ASSIGN exp
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (68) if_then_else -> . IF exp THEN exp ELSE exp
    (69) if_then -> . IF exp THEN exp
    (70) while_loop -> . WHILE exp DO exp
    (71) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (72) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NULL            shift and go to state 49
    UNIT            shift and go to state 50
    STRING_LITERAL  shift and go to state 51
    MINUS           shift and go to state 52
    NOT             shift and go to state 53
    SET             shift and go to state 55
    LET             shift and go to state 31
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    NEW             shift and go to state 59
    LPAREN          shift and go to state 54

    exp                            shift and go to state 101
    variable                       shift and go to state 32
    literal                        shift and go to state 34
    binary_exp                     shift and go to state 35
    unary_exp                      shift and go to state 36
    function_call                  shift and go to state 37
    assignment                     shift and go to state 38
    variable_declaration           shift and go to state 39
    if_then_else                   shift and go to state 40
    if_then                        shift and go to state 41
    while_loop                     shift and go to state 42
    array_creation                 shift and go to state 43
    array_access                   shift and go to state 44
    group                          shift and go to state 45
    lhs                            shift and go to state 56

state 71

    (49) binary_exp -> exp NOT_EQUALS . exp
    (21) exp -> . variable
    (22) exp -> . literal
    (23) exp -> . binary_exp
    (24) exp -> . unary_exp
    (25) exp -> . function_call
    (26) exp -> . assignment
    (27) exp -> . variable_declaration
    (28) exp -> . if_then_else
    (29) exp -> . if_then
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs ASSIGN exp
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (68) if_then_else -> . IF exp THEN exp ELSE exp
    (69) if_then -> . IF exp THEN exp
    (70) while_loop -> . WHILE exp DO exp
    (71) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (72) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NULL            shift and go to state 49
    UNIT            shift and go to state 50
    STRING_LITERAL  shift and go to state 51
    MINUS           shift and go to state 52
    NOT             shift and go to state 53
    SET             shift and go to state 55
    LET             shift and go to state 31
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    NEW             shift and go to state 59
    LPAREN          shift and go to state 54

    exp                            shift and go to state 102
    variable                       shift and go to state 32
    literal                        shift and go to state 34
    binary_exp                     shift and go to state 35
    unary_exp                      shift and go to state 36
    function_call                  shift and go to state 37
    assignment                     shift and go to state 38
    variable_declaration           shift and go to state 39
    if_then_else                   shift and go to state 40
    if_then                        shift and go to state 41
    while_loop                     shift and go to state 42
    array_creation                 shift and go to state 43
    array_access                   shift and go to state 44
    group                          shift and go to state 45
    lhs                            shift and go to state 56

state 72

    (50) binary_exp -> exp LESS . exp
    (21) exp -> . variable
    (22) exp -> . literal
    (23) exp -> . binary_exp
    (24) exp -> . unary_exp
    (25) exp -> . function_call
    (26) exp -> . assignment
    (27) exp -> . variable_declaration
    (28) exp -> . if_then_else
    (29) exp -> . if_then
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs ASSIGN exp
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (68) if_then_else -> . IF exp THEN exp ELSE exp
    (69) if_then -> . IF exp THEN exp
    (70) while_loop -> . WHILE exp DO exp
    (71) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (72) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NULL            shift and go to state 49
    UNIT            shift and go to state 50
    STRING_LITERAL  shift and go to state 51
    MINUS           shift and go to state 52
    NOT             shift and go to state 53
    SET             shift and go to state 55
    LET             shift and go to state 31
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    NEW             shift and go to state 59
    LPAREN          shift and go to state 54

    exp                            shift and go to state 103
    variable                       shift and go to state 32
    literal                        shift and go to state 34
    binary_exp                     shift and go to state 35
    unary_exp                      shift and go to state 36
    function_call                  shift and go to state 37
    assignment                     shift and go to state 38
    variable_declaration           shift and go to state 39
    if_then_else                   shift and go to state 40
    if_then                        shift and go to state 41
    while_loop                     shift and go to state 42
    array_creation                 shift and go to state 43
    array_access                   shift and go to state 44
    group                          shift and go to state 45
    lhs                            shift and go to state 56

state 73

    (51) binary_exp -> exp LESS_EQUAL . exp
    (21) exp -> . variable
    (22) exp -> . literal
    (23) exp -> . binary_exp
    (24) exp -> . unary_exp
    (25) exp -> . function_call
    (26) exp -> . assignment
    (27) exp -> . variable_declaration
    (28) exp -> . if_then_else
    (29) exp -> . if_then
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs ASSIGN exp
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (68) if_then_else -> . IF exp THEN exp ELSE exp
    (69) if_then -> . IF exp THEN exp
    (70) while_loop -> . WHILE exp DO exp
    (71) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (72) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NULL            shift and go to state 49
    UNIT            shift and go to state 50
    STRING_LITERAL  shift and go to state 51
    MINUS           shift and go to state 52
    NOT             shift and go to state 53
    SET             shift and go to state 55
    LET             shift and go to state 31
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    NEW             shift and go to state 59
    LPAREN          shift and go to state 54

    exp                            shift and go to state 104
    variable                       shift and go to state 32
    literal                        shift and go to state 34
    binary_exp                     shift and go to state 35
    unary_exp                      shift and go to state 36
    function_call                  shift and go to state 37
    assignment                     shift and go to state 38
    variable_declaration           shift and go to state 39
    if_then_else                   shift and go to state 40
    if_then                        shift and go to state 41
    while_loop                     shift and go to state 42
    array_creation                 shift and go to state 43
    array_access                   shift and go to state 44
    group                          shift and go to state 45
    lhs                            shift and go to state 56

state 74

    (52) binary_exp -> exp GREATER . exp
    (21) exp -> . variable
    (22) exp -> . literal
    (23) exp -> . binary_exp
    (24) exp -> . unary_exp
    (25) exp -> . function_call
    (26) exp -> . assignment
    (27) exp -> . variable_declaration
    (28) exp -> . if_then_else
    (29) exp -> . if_then
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs ASSIGN exp
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (68) if_then_else -> . IF exp THEN exp ELSE exp
    (69) if_then -> . IF exp THEN exp
    (70) while_loop -> . WHILE exp DO exp
    (71) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (72) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NULL            shift and go to state 49
    UNIT            shift and go to state 50
    STRING_LITERAL  shift and go to state 51
    MINUS           shift and go to state 52
    NOT             shift and go to state 53
    SET             shift and go to state 55
    LET             shift and go to state 31
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    NEW             shift and go to state 59
    LPAREN          shift and go to state 54

    exp                            shift and go to state 105
    variable                       shift and go to state 32
    literal                        shift and go to state 34
    binary_exp                     shift and go to state 35
    unary_exp                      shift and go to state 36
    function_call                  shift and go to state 37
    assignment                     shift and go to state 38
    variable_declaration           shift and go to state 39
    if_then_else                   shift and go to state 40
    if_then                        shift and go to state 41
    while_loop                     shift and go to state 42
    array_creation                 shift and go to state 43
    array_access                   shift and go to state 44
    group                          shift and go to state 45
    lhs                            shift and go to state 56

state 75

    (53) binary_exp -> exp GREATER_EQUAL . exp
    (21) exp -> . variable
    (22) exp -> . literal
    (23) exp -> . binary_exp
    (24) exp -> . unary_exp
    (25) exp -> . function_call
    (26) exp -> . assignment
    (27) exp -> . variable_declaration
    (28) exp -> . if_then_else
    (29) exp -> . if_then
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs ASSIGN exp
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (68) if_then_else -> . IF exp THEN exp ELSE exp
    (69) if_then -> . IF exp THEN exp
    (70) while_loop -> . WHILE exp DO exp
    (71) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (72) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NULL            shift and go to state 49
    UNIT            shift and go to state 50
    STRING_LITERAL  shift and go to state 51
    MINUS           shift and go to state 52
    NOT             shift and go to state 53
    SET             shift and go to state 55
    LET             shift and go to state 31
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    NEW             shift and go to state 59
    LPAREN          shift and go to state 54

    exp                            shift and go to state 106
    variable                       shift and go to state 32
    literal                        shift and go to state 34
    binary_exp                     shift and go to state 35
    unary_exp                      shift and go to state 36
    function_call                  shift and go to state 37
    assignment                     shift and go to state 38
    variable_declaration           shift and go to state 39
    if_then_else                   shift and go to state 40
    if_then                        shift and go to state 41
    while_loop                     shift and go to state 42
    array_creation                 shift and go to state 43
    array_access                   shift and go to state 44
    group                          shift and go to state 45
    lhs                            shift and go to state 56

state 76

    (54) binary_exp -> exp AND . exp
    (21) exp -> . variable
    (22) exp -> . literal
    (23) exp -> . binary_exp
    (24) exp -> . unary_exp
    (25) exp -> . function_call
    (26) exp -> . assignment
    (27) exp -> . variable_declaration
    (28) exp -> . if_then_else
    (29) exp -> . if_then
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs ASSIGN exp
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (68) if_then_else -> . IF exp THEN exp ELSE exp
    (69) if_then -> . IF exp THEN exp
    (70) while_loop -> . WHILE exp DO exp
    (71) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (72) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NULL            shift and go to state 49
    UNIT            shift and go to state 50
    STRING_LITERAL  shift and go to state 51
    MINUS           shift and go to state 52
    NOT             shift and go to state 53
    SET             shift and go to state 55
    LET             shift and go to state 31
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    NEW             shift and go to state 59
    LPAREN          shift and go to state 54

    exp                            shift and go to state 107
    variable                       shift and go to state 32
    literal                        shift and go to state 34
    binary_exp                     shift and go to state 35
    unary_exp                      shift and go to state 36
    function_call                  shift and go to state 37
    assignment                     shift and go to state 38
    variable_declaration           shift and go to state 39
    if_then_else                   shift and go to state 40
    if_then                        shift and go to state 41
    while_loop                     shift and go to state 42
    array_creation                 shift and go to state 43
    array_access                   shift and go to state 44
    group                          shift and go to state 45
    lhs                            shift and go to state 56

state 77

    (55) binary_exp -> exp OR . exp
    (21) exp -> . variable
    (22) exp -> . literal
    (23) exp -> . binary_exp
    (24) exp -> . unary_exp
    (25) exp -> . function_call
    (26) exp -> . assignment
    (27) exp -> . variable_declaration
    (28) exp -> . if_then_else
    (29) exp -> . if_then
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs ASSIGN exp
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (68) if_then_else -> . IF exp THEN exp ELSE exp
    (69) if_then -> . IF exp THEN exp
    (70) while_loop -> . WHILE exp DO exp
    (71) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (72) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NULL            shift and go to state 49
    UNIT            shift and go to state 50
    STRING_LITERAL  shift and go to state 51
    MINUS           shift and go to state 52
    NOT             shift and go to state 53
    SET             shift and go to state 55
    LET             shift and go to state 31
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    NEW             shift and go to state 59
    LPAREN          shift and go to state 54

    exp                            shift and go to state 108
    variable                       shift and go to state 32
    literal                        shift and go to state 34
    binary_exp                     shift and go to state 35
    unary_exp                      shift and go to state 36
    function_call                  shift and go to state 37
    assignment                     shift and go to state 38
    variable_declaration           shift and go to state 39
    if_then_else                   shift and go to state 40
    if_then                        shift and go to state 41
    while_loop                     shift and go to state 42
    array_creation                 shift and go to state 43
    array_access                   shift and go to state 44
    group                          shift and go to state 45
    lhs                            shift and go to state 56

state 78

    (56) binary_exp -> exp SEMICOLON . exp
    (21) exp -> . variable
    (22) exp -> . literal
    (23) exp -> . binary_exp
    (24) exp -> . unary_exp
    (25) exp -> . function_call
    (26) exp -> . assignment
    (27) exp -> . variable_declaration
    (28) exp -> . if_then_else
    (29) exp -> . if_then
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs ASSIGN exp
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (68) if_then_else -> . IF exp THEN exp ELSE exp
    (69) if_then -> . IF exp THEN exp
    (70) while_loop -> . WHILE exp DO exp
    (71) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (72) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NULL            shift and go to state 49
    UNIT            shift and go to state 50
    STRING_LITERAL  shift and go to state 51
    MINUS           shift and go to state 52
    NOT             shift and go to state 53
    SET             shift and go to state 55
    LET             shift and go to state 31
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    NEW             shift and go to state 59
    LPAREN          shift and go to state 54

    exp                            shift and go to state 109
    variable                       shift and go to state 32
    literal                        shift and go to state 34
    binary_exp                     shift and go to state 35
    unary_exp                      shift and go to state 36
    function_call                  shift and go to state 37
    assignment                     shift and go to state 38
    variable_declaration           shift and go to state 39
    if_then_else                   shift and go to state 40
    if_then                        shift and go to state 41
    while_loop                     shift and go to state 42
    array_creation                 shift and go to state 43
    array_access                   shift and go to state 44
    group                          shift and go to state 45
    lhs                            shift and go to state 56

state 79

    (57) unary_exp -> MINUS exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    PLUS            reduce using rule 57 (unary_exp -> MINUS exp .)
    MINUS           reduce using rule 57 (unary_exp -> MINUS exp .)
    TIMES           reduce using rule 57 (unary_exp -> MINUS exp .)
    DIVIDE          reduce using rule 57 (unary_exp -> MINUS exp .)
    MOD             reduce using rule 57 (unary_exp -> MINUS exp .)
    POWER           reduce using rule 57 (unary_exp -> MINUS exp .)
    EQUALS          reduce using rule 57 (unary_exp -> MINUS exp .)
    NOT_EQUALS      reduce using rule 57 (unary_exp -> MINUS exp .)
    LESS            reduce using rule 57 (unary_exp -> MINUS exp .)
    LESS_EQUAL      reduce using rule 57 (unary_exp -> MINUS exp .)
    GREATER         reduce using rule 57 (unary_exp -> MINUS exp .)
    GREATER_EQUAL   reduce using rule 57 (unary_exp -> MINUS exp .)
    AND             reduce using rule 57 (unary_exp -> MINUS exp .)
    OR              reduce using rule 57 (unary_exp -> MINUS exp .)
    SEMICOLON       reduce using rule 57 (unary_exp -> MINUS exp .)
    LET             reduce using rule 57 (unary_exp -> MINUS exp .)
    $end            reduce using rule 57 (unary_exp -> MINUS exp .)
    RPAREN          reduce using rule 57 (unary_exp -> MINUS exp .)
    THEN            reduce using rule 57 (unary_exp -> MINUS exp .)
    DO              reduce using rule 57 (unary_exp -> MINUS exp .)
    COMMA           reduce using rule 57 (unary_exp -> MINUS exp .)
    RBRACKET        reduce using rule 57 (unary_exp -> MINUS exp .)
    ELSE            reduce using rule 57 (unary_exp -> MINUS exp .)
    BAR             reduce using rule 57 (unary_exp -> MINUS exp .)

  ! PLUS            [ shift and go to state 64 ]
  ! MINUS           [ shift and go to state 65 ]
  ! TIMES           [ shift and go to state 66 ]
  ! DIVIDE          [ shift and go to state 67 ]
  ! MOD             [ shift and go to state 68 ]
  ! POWER           [ shift and go to state 69 ]
  ! EQUALS          [ shift and go to state 70 ]
  ! NOT_EQUALS      [ shift and go to state 71 ]
  ! LESS            [ shift and go to state 72 ]
  ! LESS_EQUAL      [ shift and go to state 73 ]
  ! GREATER         [ shift and go to state 74 ]
  ! GREATER_EQUAL   [ shift and go to state 75 ]
  ! AND             [ shift and go to state 76 ]
  ! OR              [ shift and go to state 77 ]
  ! SEMICOLON       [ shift and go to state 78 ]


state 80

    (58) unary_exp -> NOT exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    PLUS            reduce using rule 58 (unary_exp -> NOT exp .)
    MINUS           reduce using rule 58 (unary_exp -> NOT exp .)
    TIMES           reduce using rule 58 (unary_exp -> NOT exp .)
    DIVIDE          reduce using rule 58 (unary_exp -> NOT exp .)
    MOD             reduce using rule 58 (unary_exp -> NOT exp .)
    POWER           reduce using rule 58 (unary_exp -> NOT exp .)
    EQUALS          reduce using rule 58 (unary_exp -> NOT exp .)
    NOT_EQUALS      reduce using rule 58 (unary_exp -> NOT exp .)
    LESS            reduce using rule 58 (unary_exp -> NOT exp .)
    LESS_EQUAL      reduce using rule 58 (unary_exp -> NOT exp .)
    GREATER         reduce using rule 58 (unary_exp -> NOT exp .)
    GREATER_EQUAL   reduce using rule 58 (unary_exp -> NOT exp .)
    AND             reduce using rule 58 (unary_exp -> NOT exp .)
    OR              reduce using rule 58 (unary_exp -> NOT exp .)
    SEMICOLON       reduce using rule 58 (unary_exp -> NOT exp .)
    LET             reduce using rule 58 (unary_exp -> NOT exp .)
    $end            reduce using rule 58 (unary_exp -> NOT exp .)
    RPAREN          reduce using rule 58 (unary_exp -> NOT exp .)
    THEN            reduce using rule 58 (unary_exp -> NOT exp .)
    DO              reduce using rule 58 (unary_exp -> NOT exp .)
    COMMA           reduce using rule 58 (unary_exp -> NOT exp .)
    RBRACKET        reduce using rule 58 (unary_exp -> NOT exp .)
    ELSE            reduce using rule 58 (unary_exp -> NOT exp .)
    BAR             reduce using rule 58 (unary_exp -> NOT exp .)

  ! PLUS            [ shift and go to state 64 ]
  ! MINUS           [ shift and go to state 65 ]
  ! TIMES           [ shift and go to state 66 ]
  ! DIVIDE          [ shift and go to state 67 ]
  ! MOD             [ shift and go to state 68 ]
  ! POWER           [ shift and go to state 69 ]
  ! EQUALS          [ shift and go to state 70 ]
  ! NOT_EQUALS      [ shift and go to state 71 ]
  ! LESS            [ shift and go to state 72 ]
  ! LESS_EQUAL      [ shift and go to state 73 ]
  ! GREATER         [ shift and go to state 74 ]
  ! GREATER_EQUAL   [ shift and go to state 75 ]
  ! AND             [ shift and go to state 76 ]
  ! OR              [ shift and go to state 77 ]
  ! SEMICOLON       [ shift and go to state 78 ]


state 81

    (72) group -> LPAREN exp . RPAREN
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    RPAREN          shift and go to state 110
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69
    EQUALS          shift and go to state 70
    NOT_EQUALS      shift and go to state 71
    LESS            shift and go to state 72
    LESS_EQUAL      shift and go to state 73
    GREATER         shift and go to state 74
    GREATER_EQUAL   shift and go to state 75
    AND             shift and go to state 76
    OR              shift and go to state 77
    SEMICOLON       shift and go to state 78


state 82

    (63) assignment -> SET lhs . ASSIGN exp
    (66) array_access -> lhs . LBRACKET exp RBRACKET

    ASSIGN          shift and go to state 111
    LBRACKET        shift and go to state 85


state 83

    (64) lhs -> variable .

    ASSIGN          reduce using rule 64 (lhs -> variable .)
    LBRACKET        reduce using rule 64 (lhs -> variable .)


state 84

    (65) lhs -> array_access .

    ASSIGN          reduce using rule 65 (lhs -> array_access .)
    LBRACKET        reduce using rule 65 (lhs -> array_access .)


state 85

    (66) array_access -> lhs LBRACKET . exp RBRACKET
    (21) exp -> . variable
    (22) exp -> . literal
    (23) exp -> . binary_exp
    (24) exp -> . unary_exp
    (25) exp -> . function_call
    (26) exp -> . assignment
    (27) exp -> . variable_declaration
    (28) exp -> . if_then_else
    (29) exp -> . if_then
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs ASSIGN exp
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (68) if_then_else -> . IF exp THEN exp ELSE exp
    (69) if_then -> . IF exp THEN exp
    (70) while_loop -> . WHILE exp DO exp
    (71) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (72) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NULL            shift and go to state 49
    UNIT            shift and go to state 50
    STRING_LITERAL  shift and go to state 51
    MINUS           shift and go to state 52
    NOT             shift and go to state 53
    SET             shift and go to state 55
    LET             shift and go to state 31
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    NEW             shift and go to state 59
    LPAREN          shift and go to state 54

    lhs                            shift and go to state 56
    exp                            shift and go to state 112
    variable                       shift and go to state 32
    literal                        shift and go to state 34
    binary_exp                     shift and go to state 35
    unary_exp                      shift and go to state 36
    function_call                  shift and go to state 37
    assignment                     shift and go to state 38
    variable_declaration           shift and go to state 39
    if_then_else                   shift and go to state 40
    if_then                        shift and go to state 41
    while_loop                     shift and go to state 42
    array_creation                 shift and go to state 43
    array_access                   shift and go to state 44
    group                          shift and go to state 45

state 86

    (68) if_then_else -> IF exp . THEN exp ELSE exp
    (69) if_then -> IF exp . THEN exp
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    THEN            shift and go to state 113
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69
    EQUALS          shift and go to state 70
    NOT_EQUALS      shift and go to state 71
    LESS            shift and go to state 72
    LESS_EQUAL      shift and go to state 73
    GREATER         shift and go to state 74
    GREATER_EQUAL   shift and go to state 75
    AND             shift and go to state 76
    OR              shift and go to state 77
    SEMICOLON       shift and go to state 78


state 87

    (70) while_loop -> WHILE exp . DO exp
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    DO              shift and go to state 114
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69
    EQUALS          shift and go to state 70
    NOT_EQUALS      shift and go to state 71
    LESS            shift and go to state 72
    LESS_EQUAL      shift and go to state 73
    GREATER         shift and go to state 74
    GREATER_EQUAL   shift and go to state 75
    AND             shift and go to state 76
    OR              shift and go to state 77
    SEMICOLON       shift and go to state 78


state 88

    (71) array_creation -> NEW type . LBRACKET exp BAR exp RBRACKET
    (16) array_type -> type . LBRACKET RBRACKET

    LBRACKET        shift and go to state 115


state 89

    (18) function_type -> LPAREN . type function_type_tail RPAREN ARROW type
    (11) type -> . INT_TYPE
    (12) type -> . STRING_TYPE
    (13) type -> . UNIT_TYPE
    (14) type -> . BOOL_TYPE
    (15) type -> . array_type
    (16) array_type -> . type LBRACKET RBRACKET

    INT_TYPE        shift and go to state 17
    STRING_TYPE     shift and go to state 18
    UNIT_TYPE       shift and go to state 19
    BOOL_TYPE       shift and go to state 20

    type                           shift and go to state 116
    array_type                     shift and go to state 21

state 90

    (7) function_declaration -> LET ID LPAREN parameters RPAREN COLON function_type . ASSIGN exp

    ASSIGN          shift and go to state 117


state 91

    (17) function_type -> type . ARROW type
    (16) array_type -> type . LBRACKET RBRACKET

    ARROW           shift and go to state 118
    LBRACKET        shift and go to state 26


state 92

    (9) parameters_tail -> COMMA variable parameters_tail .

    RPAREN          reduce using rule 9 (parameters_tail -> COMMA variable parameters_tail .)


state 93

    (59) function_call -> variable LPAREN arguments . RPAREN

    RPAREN          shift and go to state 119


state 94

    (60) arguments -> exp . arguments_tail
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp
    (61) arguments_tail -> . COMMA exp arguments_tail
    (62) arguments_tail -> . empty
    (73) empty -> .

    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69
    EQUALS          shift and go to state 70
    NOT_EQUALS      shift and go to state 71
    LESS            shift and go to state 72
    LESS_EQUAL      shift and go to state 73
    GREATER         shift and go to state 74
    GREATER_EQUAL   shift and go to state 75
    AND             shift and go to state 76
    OR              shift and go to state 77
    SEMICOLON       shift and go to state 78
    COMMA           shift and go to state 121
    RPAREN          reduce using rule 73 (empty -> .)

    arguments_tail                 shift and go to state 120
    empty                          shift and go to state 122

state 95

    (42) binary_exp -> exp PLUS exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    PLUS            reduce using rule 42 (binary_exp -> exp PLUS exp .)
    MINUS           reduce using rule 42 (binary_exp -> exp PLUS exp .)
    EQUALS          reduce using rule 42 (binary_exp -> exp PLUS exp .)
    NOT_EQUALS      reduce using rule 42 (binary_exp -> exp PLUS exp .)
    LESS            reduce using rule 42 (binary_exp -> exp PLUS exp .)
    LESS_EQUAL      reduce using rule 42 (binary_exp -> exp PLUS exp .)
    GREATER         reduce using rule 42 (binary_exp -> exp PLUS exp .)
    GREATER_EQUAL   reduce using rule 42 (binary_exp -> exp PLUS exp .)
    AND             reduce using rule 42 (binary_exp -> exp PLUS exp .)
    OR              reduce using rule 42 (binary_exp -> exp PLUS exp .)
    SEMICOLON       reduce using rule 42 (binary_exp -> exp PLUS exp .)
    LET             reduce using rule 42 (binary_exp -> exp PLUS exp .)
    $end            reduce using rule 42 (binary_exp -> exp PLUS exp .)
    RPAREN          reduce using rule 42 (binary_exp -> exp PLUS exp .)
    THEN            reduce using rule 42 (binary_exp -> exp PLUS exp .)
    DO              reduce using rule 42 (binary_exp -> exp PLUS exp .)
    COMMA           reduce using rule 42 (binary_exp -> exp PLUS exp .)
    RBRACKET        reduce using rule 42 (binary_exp -> exp PLUS exp .)
    ELSE            reduce using rule 42 (binary_exp -> exp PLUS exp .)
    BAR             reduce using rule 42 (binary_exp -> exp PLUS exp .)
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! TIMES           [ reduce using rule 42 (binary_exp -> exp PLUS exp .) ]
  ! DIVIDE          [ reduce using rule 42 (binary_exp -> exp PLUS exp .) ]
  ! MOD             [ reduce using rule 42 (binary_exp -> exp PLUS exp .) ]
  ! POWER           [ reduce using rule 42 (binary_exp -> exp PLUS exp .) ]
  ! PLUS            [ shift and go to state 64 ]
  ! MINUS           [ shift and go to state 65 ]
  ! EQUALS          [ shift and go to state 70 ]
  ! NOT_EQUALS      [ shift and go to state 71 ]
  ! LESS            [ shift and go to state 72 ]
  ! LESS_EQUAL      [ shift and go to state 73 ]
  ! GREATER         [ shift and go to state 74 ]
  ! GREATER_EQUAL   [ shift and go to state 75 ]
  ! AND             [ shift and go to state 76 ]
  ! OR              [ shift and go to state 77 ]
  ! SEMICOLON       [ shift and go to state 78 ]


state 96

    (43) binary_exp -> exp MINUS exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    PLUS            reduce using rule 43 (binary_exp -> exp MINUS exp .)
    MINUS           reduce using rule 43 (binary_exp -> exp MINUS exp .)
    EQUALS          reduce using rule 43 (binary_exp -> exp MINUS exp .)
    NOT_EQUALS      reduce using rule 43 (binary_exp -> exp MINUS exp .)
    LESS            reduce using rule 43 (binary_exp -> exp MINUS exp .)
    LESS_EQUAL      reduce using rule 43 (binary_exp -> exp MINUS exp .)
    GREATER         reduce using rule 43 (binary_exp -> exp MINUS exp .)
    GREATER_EQUAL   reduce using rule 43 (binary_exp -> exp MINUS exp .)
    AND             reduce using rule 43 (binary_exp -> exp MINUS exp .)
    OR              reduce using rule 43 (binary_exp -> exp MINUS exp .)
    SEMICOLON       reduce using rule 43 (binary_exp -> exp MINUS exp .)
    LET             reduce using rule 43 (binary_exp -> exp MINUS exp .)
    $end            reduce using rule 43 (binary_exp -> exp MINUS exp .)
    RPAREN          reduce using rule 43 (binary_exp -> exp MINUS exp .)
    THEN            reduce using rule 43 (binary_exp -> exp MINUS exp .)
    DO              reduce using rule 43 (binary_exp -> exp MINUS exp .)
    COMMA           reduce using rule 43 (binary_exp -> exp MINUS exp .)
    RBRACKET        reduce using rule 43 (binary_exp -> exp MINUS exp .)
    ELSE            reduce using rule 43 (binary_exp -> exp MINUS exp .)
    BAR             reduce using rule 43 (binary_exp -> exp MINUS exp .)
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! TIMES           [ reduce using rule 43 (binary_exp -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 43 (binary_exp -> exp MINUS exp .) ]
  ! MOD             [ reduce using rule 43 (binary_exp -> exp MINUS exp .) ]
  ! POWER           [ reduce using rule 43 (binary_exp -> exp MINUS exp .) ]
  ! PLUS            [ shift and go to state 64 ]
  ! MINUS           [ shift and go to state 65 ]
  ! EQUALS          [ shift and go to state 70 ]
  ! NOT_EQUALS      [ shift and go to state 71 ]
  ! LESS            [ shift and go to state 72 ]
  ! LESS_EQUAL      [ shift and go to state 73 ]
  ! GREATER         [ shift and go to state 74 ]
  ! GREATER_EQUAL   [ shift and go to state 75 ]
  ! AND             [ shift and go to state 76 ]
  ! OR              [ shift and go to state 77 ]
  ! SEMICOLON       [ shift and go to state 78 ]


state 97

    (44) binary_exp -> exp TIMES exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    PLUS            reduce using rule 44 (binary_exp -> exp TIMES exp .)
    MINUS           reduce using rule 44 (binary_exp -> exp TIMES exp .)
    TIMES           reduce using rule 44 (binary_exp -> exp TIMES exp .)
    DIVIDE          reduce using rule 44 (binary_exp -> exp TIMES exp .)
    MOD             reduce using rule 44 (binary_exp -> exp TIMES exp .)
    EQUALS          reduce using rule 44 (binary_exp -> exp TIMES exp .)
    NOT_EQUALS      reduce using rule 44 (binary_exp -> exp TIMES exp .)
    LESS            reduce using rule 44 (binary_exp -> exp TIMES exp .)
    LESS_EQUAL      reduce using rule 44 (binary_exp -> exp TIMES exp .)
    GREATER         reduce using rule 44 (binary_exp -> exp TIMES exp .)
    GREATER_EQUAL   reduce using rule 44 (binary_exp -> exp TIMES exp .)
    AND             reduce using rule 44 (binary_exp -> exp TIMES exp .)
    OR              reduce using rule 44 (binary_exp -> exp TIMES exp .)
    SEMICOLON       reduce using rule 44 (binary_exp -> exp TIMES exp .)
    LET             reduce using rule 44 (binary_exp -> exp TIMES exp .)
    $end            reduce using rule 44 (binary_exp -> exp TIMES exp .)
    RPAREN          reduce using rule 44 (binary_exp -> exp TIMES exp .)
    THEN            reduce using rule 44 (binary_exp -> exp TIMES exp .)
    DO              reduce using rule 44 (binary_exp -> exp TIMES exp .)
    COMMA           reduce using rule 44 (binary_exp -> exp TIMES exp .)
    RBRACKET        reduce using rule 44 (binary_exp -> exp TIMES exp .)
    ELSE            reduce using rule 44 (binary_exp -> exp TIMES exp .)
    BAR             reduce using rule 44 (binary_exp -> exp TIMES exp .)
    POWER           shift and go to state 69

  ! POWER           [ reduce using rule 44 (binary_exp -> exp TIMES exp .) ]
  ! PLUS            [ shift and go to state 64 ]
  ! MINUS           [ shift and go to state 65 ]
  ! TIMES           [ shift and go to state 66 ]
  ! DIVIDE          [ shift and go to state 67 ]
  ! MOD             [ shift and go to state 68 ]
  ! EQUALS          [ shift and go to state 70 ]
  ! NOT_EQUALS      [ shift and go to state 71 ]
  ! LESS            [ shift and go to state 72 ]
  ! LESS_EQUAL      [ shift and go to state 73 ]
  ! GREATER         [ shift and go to state 74 ]
  ! GREATER_EQUAL   [ shift and go to state 75 ]
  ! AND             [ shift and go to state 76 ]
  ! OR              [ shift and go to state 77 ]
  ! SEMICOLON       [ shift and go to state 78 ]


state 98

    (45) binary_exp -> exp DIVIDE exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    PLUS            reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    MINUS           reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    TIMES           reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    DIVIDE          reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    MOD             reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    EQUALS          reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    NOT_EQUALS      reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    LESS            reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    LESS_EQUAL      reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    GREATER         reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    GREATER_EQUAL   reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    AND             reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    OR              reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    SEMICOLON       reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    LET             reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    $end            reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    RPAREN          reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    THEN            reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    DO              reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    COMMA           reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    RBRACKET        reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    ELSE            reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    BAR             reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    POWER           shift and go to state 69

  ! POWER           [ reduce using rule 45 (binary_exp -> exp DIVIDE exp .) ]
  ! PLUS            [ shift and go to state 64 ]
  ! MINUS           [ shift and go to state 65 ]
  ! TIMES           [ shift and go to state 66 ]
  ! DIVIDE          [ shift and go to state 67 ]
  ! MOD             [ shift and go to state 68 ]
  ! EQUALS          [ shift and go to state 70 ]
  ! NOT_EQUALS      [ shift and go to state 71 ]
  ! LESS            [ shift and go to state 72 ]
  ! LESS_EQUAL      [ shift and go to state 73 ]
  ! GREATER         [ shift and go to state 74 ]
  ! GREATER_EQUAL   [ shift and go to state 75 ]
  ! AND             [ shift and go to state 76 ]
  ! OR              [ shift and go to state 77 ]
  ! SEMICOLON       [ shift and go to state 78 ]


state 99

    (46) binary_exp -> exp MOD exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    PLUS            reduce using rule 46 (binary_exp -> exp MOD exp .)
    MINUS           reduce using rule 46 (binary_exp -> exp MOD exp .)
    TIMES           reduce using rule 46 (binary_exp -> exp MOD exp .)
    DIVIDE          reduce using rule 46 (binary_exp -> exp MOD exp .)
    MOD             reduce using rule 46 (binary_exp -> exp MOD exp .)
    EQUALS          reduce using rule 46 (binary_exp -> exp MOD exp .)
    NOT_EQUALS      reduce using rule 46 (binary_exp -> exp MOD exp .)
    LESS            reduce using rule 46 (binary_exp -> exp MOD exp .)
    LESS_EQUAL      reduce using rule 46 (binary_exp -> exp MOD exp .)
    GREATER         reduce using rule 46 (binary_exp -> exp MOD exp .)
    GREATER_EQUAL   reduce using rule 46 (binary_exp -> exp MOD exp .)
    AND             reduce using rule 46 (binary_exp -> exp MOD exp .)
    OR              reduce using rule 46 (binary_exp -> exp MOD exp .)
    SEMICOLON       reduce using rule 46 (binary_exp -> exp MOD exp .)
    LET             reduce using rule 46 (binary_exp -> exp MOD exp .)
    $end            reduce using rule 46 (binary_exp -> exp MOD exp .)
    RPAREN          reduce using rule 46 (binary_exp -> exp MOD exp .)
    THEN            reduce using rule 46 (binary_exp -> exp MOD exp .)
    DO              reduce using rule 46 (binary_exp -> exp MOD exp .)
    COMMA           reduce using rule 46 (binary_exp -> exp MOD exp .)
    RBRACKET        reduce using rule 46 (binary_exp -> exp MOD exp .)
    ELSE            reduce using rule 46 (binary_exp -> exp MOD exp .)
    BAR             reduce using rule 46 (binary_exp -> exp MOD exp .)
    POWER           shift and go to state 69

  ! POWER           [ reduce using rule 46 (binary_exp -> exp MOD exp .) ]
  ! PLUS            [ shift and go to state 64 ]
  ! MINUS           [ shift and go to state 65 ]
  ! TIMES           [ shift and go to state 66 ]
  ! DIVIDE          [ shift and go to state 67 ]
  ! MOD             [ shift and go to state 68 ]
  ! EQUALS          [ shift and go to state 70 ]
  ! NOT_EQUALS      [ shift and go to state 71 ]
  ! LESS            [ shift and go to state 72 ]
  ! LESS_EQUAL      [ shift and go to state 73 ]
  ! GREATER         [ shift and go to state 74 ]
  ! GREATER_EQUAL   [ shift and go to state 75 ]
  ! AND             [ shift and go to state 76 ]
  ! OR              [ shift and go to state 77 ]
  ! SEMICOLON       [ shift and go to state 78 ]


state 100

    (47) binary_exp -> exp POWER exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    PLUS            reduce using rule 47 (binary_exp -> exp POWER exp .)
    MINUS           reduce using rule 47 (binary_exp -> exp POWER exp .)
    TIMES           reduce using rule 47 (binary_exp -> exp POWER exp .)
    DIVIDE          reduce using rule 47 (binary_exp -> exp POWER exp .)
    MOD             reduce using rule 47 (binary_exp -> exp POWER exp .)
    EQUALS          reduce using rule 47 (binary_exp -> exp POWER exp .)
    NOT_EQUALS      reduce using rule 47 (binary_exp -> exp POWER exp .)
    LESS            reduce using rule 47 (binary_exp -> exp POWER exp .)
    LESS_EQUAL      reduce using rule 47 (binary_exp -> exp POWER exp .)
    GREATER         reduce using rule 47 (binary_exp -> exp POWER exp .)
    GREATER_EQUAL   reduce using rule 47 (binary_exp -> exp POWER exp .)
    AND             reduce using rule 47 (binary_exp -> exp POWER exp .)
    OR              reduce using rule 47 (binary_exp -> exp POWER exp .)
    SEMICOLON       reduce using rule 47 (binary_exp -> exp POWER exp .)
    LET             reduce using rule 47 (binary_exp -> exp POWER exp .)
    $end            reduce using rule 47 (binary_exp -> exp POWER exp .)
    RPAREN          reduce using rule 47 (binary_exp -> exp POWER exp .)
    THEN            reduce using rule 47 (binary_exp -> exp POWER exp .)
    DO              reduce using rule 47 (binary_exp -> exp POWER exp .)
    COMMA           reduce using rule 47 (binary_exp -> exp POWER exp .)
    RBRACKET        reduce using rule 47 (binary_exp -> exp POWER exp .)
    ELSE            reduce using rule 47 (binary_exp -> exp POWER exp .)
    BAR             reduce using rule 47 (binary_exp -> exp POWER exp .)
    POWER           shift and go to state 69

  ! POWER           [ reduce using rule 47 (binary_exp -> exp POWER exp .) ]
  ! PLUS            [ shift and go to state 64 ]
  ! MINUS           [ shift and go to state 65 ]
  ! TIMES           [ shift and go to state 66 ]
  ! DIVIDE          [ shift and go to state 67 ]
  ! MOD             [ shift and go to state 68 ]
  ! EQUALS          [ shift and go to state 70 ]
  ! NOT_EQUALS      [ shift and go to state 71 ]
  ! LESS            [ shift and go to state 72 ]
  ! LESS_EQUAL      [ shift and go to state 73 ]
  ! GREATER         [ shift and go to state 74 ]
  ! GREATER_EQUAL   [ shift and go to state 75 ]
  ! AND             [ shift and go to state 76 ]
  ! OR              [ shift and go to state 77 ]
  ! SEMICOLON       [ shift and go to state 78 ]


state 101

    (48) binary_exp -> exp EQUALS exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    EQUALS          reduce using rule 48 (binary_exp -> exp EQUALS exp .)
    NOT_EQUALS      reduce using rule 48 (binary_exp -> exp EQUALS exp .)
    AND             reduce using rule 48 (binary_exp -> exp EQUALS exp .)
    OR              reduce using rule 48 (binary_exp -> exp EQUALS exp .)
    SEMICOLON       reduce using rule 48 (binary_exp -> exp EQUALS exp .)
    LET             reduce using rule 48 (binary_exp -> exp EQUALS exp .)
    $end            reduce using rule 48 (binary_exp -> exp EQUALS exp .)
    RPAREN          reduce using rule 48 (binary_exp -> exp EQUALS exp .)
    THEN            reduce using rule 48 (binary_exp -> exp EQUALS exp .)
    DO              reduce using rule 48 (binary_exp -> exp EQUALS exp .)
    COMMA           reduce using rule 48 (binary_exp -> exp EQUALS exp .)
    RBRACKET        reduce using rule 48 (binary_exp -> exp EQUALS exp .)
    ELSE            reduce using rule 48 (binary_exp -> exp EQUALS exp .)
    BAR             reduce using rule 48 (binary_exp -> exp EQUALS exp .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69
    LESS            shift and go to state 72
    LESS_EQUAL      shift and go to state 73
    GREATER         shift and go to state 74
    GREATER_EQUAL   shift and go to state 75

  ! PLUS            [ reduce using rule 48 (binary_exp -> exp EQUALS exp .) ]
  ! MINUS           [ reduce using rule 48 (binary_exp -> exp EQUALS exp .) ]
  ! TIMES           [ reduce using rule 48 (binary_exp -> exp EQUALS exp .) ]
  ! DIVIDE          [ reduce using rule 48 (binary_exp -> exp EQUALS exp .) ]
  ! MOD             [ reduce using rule 48 (binary_exp -> exp EQUALS exp .) ]
  ! POWER           [ reduce using rule 48 (binary_exp -> exp EQUALS exp .) ]
  ! LESS            [ reduce using rule 48 (binary_exp -> exp EQUALS exp .) ]
  ! LESS_EQUAL      [ reduce using rule 48 (binary_exp -> exp EQUALS exp .) ]
  ! GREATER         [ reduce using rule 48 (binary_exp -> exp EQUALS exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 48 (binary_exp -> exp EQUALS exp .) ]
  ! EQUALS          [ shift and go to state 70 ]
  ! NOT_EQUALS      [ shift and go to state 71 ]
  ! AND             [ shift and go to state 76 ]
  ! OR              [ shift and go to state 77 ]
  ! SEMICOLON       [ shift and go to state 78 ]


state 102

    (49) binary_exp -> exp NOT_EQUALS exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    EQUALS          reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .)
    NOT_EQUALS      reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .)
    AND             reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .)
    OR              reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .)
    SEMICOLON       reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .)
    LET             reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .)
    $end            reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .)
    RPAREN          reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .)
    THEN            reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .)
    DO              reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .)
    COMMA           reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .)
    RBRACKET        reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .)
    ELSE            reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .)
    BAR             reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69
    LESS            shift and go to state 72
    LESS_EQUAL      shift and go to state 73
    GREATER         shift and go to state 74
    GREATER_EQUAL   shift and go to state 75

  ! PLUS            [ reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! MINUS           [ reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! TIMES           [ reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! DIVIDE          [ reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! MOD             [ reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! POWER           [ reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! LESS            [ reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! LESS_EQUAL      [ reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! GREATER         [ reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! EQUALS          [ shift and go to state 70 ]
  ! NOT_EQUALS      [ shift and go to state 71 ]
  ! AND             [ shift and go to state 76 ]
  ! OR              [ shift and go to state 77 ]
  ! SEMICOLON       [ shift and go to state 78 ]


state 103

    (50) binary_exp -> exp LESS exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    EQUALS          reduce using rule 50 (binary_exp -> exp LESS exp .)
    NOT_EQUALS      reduce using rule 50 (binary_exp -> exp LESS exp .)
    LESS            reduce using rule 50 (binary_exp -> exp LESS exp .)
    LESS_EQUAL      reduce using rule 50 (binary_exp -> exp LESS exp .)
    GREATER         reduce using rule 50 (binary_exp -> exp LESS exp .)
    GREATER_EQUAL   reduce using rule 50 (binary_exp -> exp LESS exp .)
    AND             reduce using rule 50 (binary_exp -> exp LESS exp .)
    OR              reduce using rule 50 (binary_exp -> exp LESS exp .)
    SEMICOLON       reduce using rule 50 (binary_exp -> exp LESS exp .)
    LET             reduce using rule 50 (binary_exp -> exp LESS exp .)
    $end            reduce using rule 50 (binary_exp -> exp LESS exp .)
    RPAREN          reduce using rule 50 (binary_exp -> exp LESS exp .)
    THEN            reduce using rule 50 (binary_exp -> exp LESS exp .)
    DO              reduce using rule 50 (binary_exp -> exp LESS exp .)
    COMMA           reduce using rule 50 (binary_exp -> exp LESS exp .)
    RBRACKET        reduce using rule 50 (binary_exp -> exp LESS exp .)
    ELSE            reduce using rule 50 (binary_exp -> exp LESS exp .)
    BAR             reduce using rule 50 (binary_exp -> exp LESS exp .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! PLUS            [ reduce using rule 50 (binary_exp -> exp LESS exp .) ]
  ! MINUS           [ reduce using rule 50 (binary_exp -> exp LESS exp .) ]
  ! TIMES           [ reduce using rule 50 (binary_exp -> exp LESS exp .) ]
  ! DIVIDE          [ reduce using rule 50 (binary_exp -> exp LESS exp .) ]
  ! MOD             [ reduce using rule 50 (binary_exp -> exp LESS exp .) ]
  ! POWER           [ reduce using rule 50 (binary_exp -> exp LESS exp .) ]
  ! EQUALS          [ shift and go to state 70 ]
  ! NOT_EQUALS      [ shift and go to state 71 ]
  ! LESS            [ shift and go to state 72 ]
  ! LESS_EQUAL      [ shift and go to state 73 ]
  ! GREATER         [ shift and go to state 74 ]
  ! GREATER_EQUAL   [ shift and go to state 75 ]
  ! AND             [ shift and go to state 76 ]
  ! OR              [ shift and go to state 77 ]
  ! SEMICOLON       [ shift and go to state 78 ]


state 104

    (51) binary_exp -> exp LESS_EQUAL exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    EQUALS          reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    NOT_EQUALS      reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    LESS            reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    LESS_EQUAL      reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    GREATER         reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    GREATER_EQUAL   reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    AND             reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    OR              reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    SEMICOLON       reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    LET             reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    $end            reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    RPAREN          reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    THEN            reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    DO              reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    COMMA           reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    RBRACKET        reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    ELSE            reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    BAR             reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! PLUS            [ reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .) ]
  ! MINUS           [ reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .) ]
  ! TIMES           [ reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .) ]
  ! DIVIDE          [ reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .) ]
  ! MOD             [ reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .) ]
  ! POWER           [ reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .) ]
  ! EQUALS          [ shift and go to state 70 ]
  ! NOT_EQUALS      [ shift and go to state 71 ]
  ! LESS            [ shift and go to state 72 ]
  ! LESS_EQUAL      [ shift and go to state 73 ]
  ! GREATER         [ shift and go to state 74 ]
  ! GREATER_EQUAL   [ shift and go to state 75 ]
  ! AND             [ shift and go to state 76 ]
  ! OR              [ shift and go to state 77 ]
  ! SEMICOLON       [ shift and go to state 78 ]


state 105

    (52) binary_exp -> exp GREATER exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    EQUALS          reduce using rule 52 (binary_exp -> exp GREATER exp .)
    NOT_EQUALS      reduce using rule 52 (binary_exp -> exp GREATER exp .)
    LESS            reduce using rule 52 (binary_exp -> exp GREATER exp .)
    LESS_EQUAL      reduce using rule 52 (binary_exp -> exp GREATER exp .)
    GREATER         reduce using rule 52 (binary_exp -> exp GREATER exp .)
    GREATER_EQUAL   reduce using rule 52 (binary_exp -> exp GREATER exp .)
    AND             reduce using rule 52 (binary_exp -> exp GREATER exp .)
    OR              reduce using rule 52 (binary_exp -> exp GREATER exp .)
    SEMICOLON       reduce using rule 52 (binary_exp -> exp GREATER exp .)
    LET             reduce using rule 52 (binary_exp -> exp GREATER exp .)
    $end            reduce using rule 52 (binary_exp -> exp GREATER exp .)
    RPAREN          reduce using rule 52 (binary_exp -> exp GREATER exp .)
    THEN            reduce using rule 52 (binary_exp -> exp GREATER exp .)
    DO              reduce using rule 52 (binary_exp -> exp GREATER exp .)
    COMMA           reduce using rule 52 (binary_exp -> exp GREATER exp .)
    RBRACKET        reduce using rule 52 (binary_exp -> exp GREATER exp .)
    ELSE            reduce using rule 52 (binary_exp -> exp GREATER exp .)
    BAR             reduce using rule 52 (binary_exp -> exp GREATER exp .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! PLUS            [ reduce using rule 52 (binary_exp -> exp GREATER exp .) ]
  ! MINUS           [ reduce using rule 52 (binary_exp -> exp GREATER exp .) ]
  ! TIMES           [ reduce using rule 52 (binary_exp -> exp GREATER exp .) ]
  ! DIVIDE          [ reduce using rule 52 (binary_exp -> exp GREATER exp .) ]
  ! MOD             [ reduce using rule 52 (binary_exp -> exp GREATER exp .) ]
  ! POWER           [ reduce using rule 52 (binary_exp -> exp GREATER exp .) ]
  ! EQUALS          [ shift and go to state 70 ]
  ! NOT_EQUALS      [ shift and go to state 71 ]
  ! LESS            [ shift and go to state 72 ]
  ! LESS_EQUAL      [ shift and go to state 73 ]
  ! GREATER         [ shift and go to state 74 ]
  ! GREATER_EQUAL   [ shift and go to state 75 ]
  ! AND             [ shift and go to state 76 ]
  ! OR              [ shift and go to state 77 ]
  ! SEMICOLON       [ shift and go to state 78 ]


state 106

    (53) binary_exp -> exp GREATER_EQUAL exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    EQUALS          reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    NOT_EQUALS      reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    LESS            reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    LESS_EQUAL      reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    GREATER         reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    GREATER_EQUAL   reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    AND             reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    OR              reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    SEMICOLON       reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    LET             reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    $end            reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    RPAREN          reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    THEN            reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    DO              reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    COMMA           reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    RBRACKET        reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    ELSE            reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    BAR             reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! PLUS            [ reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .) ]
  ! MINUS           [ reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .) ]
  ! TIMES           [ reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .) ]
  ! DIVIDE          [ reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .) ]
  ! MOD             [ reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .) ]
  ! POWER           [ reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .) ]
  ! EQUALS          [ shift and go to state 70 ]
  ! NOT_EQUALS      [ shift and go to state 71 ]
  ! LESS            [ shift and go to state 72 ]
  ! LESS_EQUAL      [ shift and go to state 73 ]
  ! GREATER         [ shift and go to state 74 ]
  ! GREATER_EQUAL   [ shift and go to state 75 ]
  ! AND             [ shift and go to state 76 ]
  ! OR              [ shift and go to state 77 ]
  ! SEMICOLON       [ shift and go to state 78 ]


state 107

    (54) binary_exp -> exp AND exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    AND             reduce using rule 54 (binary_exp -> exp AND exp .)
    OR              reduce using rule 54 (binary_exp -> exp AND exp .)
    SEMICOLON       reduce using rule 54 (binary_exp -> exp AND exp .)
    LET             reduce using rule 54 (binary_exp -> exp AND exp .)
    $end            reduce using rule 54 (binary_exp -> exp AND exp .)
    RPAREN          reduce using rule 54 (binary_exp -> exp AND exp .)
    THEN            reduce using rule 54 (binary_exp -> exp AND exp .)
    DO              reduce using rule 54 (binary_exp -> exp AND exp .)
    COMMA           reduce using rule 54 (binary_exp -> exp AND exp .)
    RBRACKET        reduce using rule 54 (binary_exp -> exp AND exp .)
    ELSE            reduce using rule 54 (binary_exp -> exp AND exp .)
    BAR             reduce using rule 54 (binary_exp -> exp AND exp .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69
    EQUALS          shift and go to state 70
    NOT_EQUALS      shift and go to state 71
    LESS            shift and go to state 72
    LESS_EQUAL      shift and go to state 73
    GREATER         shift and go to state 74
    GREATER_EQUAL   shift and go to state 75

  ! PLUS            [ reduce using rule 54 (binary_exp -> exp AND exp .) ]
  ! MINUS           [ reduce using rule 54 (binary_exp -> exp AND exp .) ]
  ! TIMES           [ reduce using rule 54 (binary_exp -> exp AND exp .) ]
  ! DIVIDE          [ reduce using rule 54 (binary_exp -> exp AND exp .) ]
  ! MOD             [ reduce using rule 54 (binary_exp -> exp AND exp .) ]
  ! POWER           [ reduce using rule 54 (binary_exp -> exp AND exp .) ]
  ! EQUALS          [ reduce using rule 54 (binary_exp -> exp AND exp .) ]
  ! NOT_EQUALS      [ reduce using rule 54 (binary_exp -> exp AND exp .) ]
  ! LESS            [ reduce using rule 54 (binary_exp -> exp AND exp .) ]
  ! LESS_EQUAL      [ reduce using rule 54 (binary_exp -> exp AND exp .) ]
  ! GREATER         [ reduce using rule 54 (binary_exp -> exp AND exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 54 (binary_exp -> exp AND exp .) ]
  ! AND             [ shift and go to state 76 ]
  ! OR              [ shift and go to state 77 ]
  ! SEMICOLON       [ shift and go to state 78 ]


state 108

    (55) binary_exp -> exp OR exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    OR              reduce using rule 55 (binary_exp -> exp OR exp .)
    SEMICOLON       reduce using rule 55 (binary_exp -> exp OR exp .)
    LET             reduce using rule 55 (binary_exp -> exp OR exp .)
    $end            reduce using rule 55 (binary_exp -> exp OR exp .)
    RPAREN          reduce using rule 55 (binary_exp -> exp OR exp .)
    THEN            reduce using rule 55 (binary_exp -> exp OR exp .)
    DO              reduce using rule 55 (binary_exp -> exp OR exp .)
    COMMA           reduce using rule 55 (binary_exp -> exp OR exp .)
    RBRACKET        reduce using rule 55 (binary_exp -> exp OR exp .)
    ELSE            reduce using rule 55 (binary_exp -> exp OR exp .)
    BAR             reduce using rule 55 (binary_exp -> exp OR exp .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69
    EQUALS          shift and go to state 70
    NOT_EQUALS      shift and go to state 71
    LESS            shift and go to state 72
    LESS_EQUAL      shift and go to state 73
    GREATER         shift and go to state 74
    GREATER_EQUAL   shift and go to state 75
    AND             shift and go to state 76

  ! PLUS            [ reduce using rule 55 (binary_exp -> exp OR exp .) ]
  ! MINUS           [ reduce using rule 55 (binary_exp -> exp OR exp .) ]
  ! TIMES           [ reduce using rule 55 (binary_exp -> exp OR exp .) ]
  ! DIVIDE          [ reduce using rule 55 (binary_exp -> exp OR exp .) ]
  ! MOD             [ reduce using rule 55 (binary_exp -> exp OR exp .) ]
  ! POWER           [ reduce using rule 55 (binary_exp -> exp OR exp .) ]
  ! EQUALS          [ reduce using rule 55 (binary_exp -> exp OR exp .) ]
  ! NOT_EQUALS      [ reduce using rule 55 (binary_exp -> exp OR exp .) ]
  ! LESS            [ reduce using rule 55 (binary_exp -> exp OR exp .) ]
  ! LESS_EQUAL      [ reduce using rule 55 (binary_exp -> exp OR exp .) ]
  ! GREATER         [ reduce using rule 55 (binary_exp -> exp OR exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 55 (binary_exp -> exp OR exp .) ]
  ! AND             [ reduce using rule 55 (binary_exp -> exp OR exp .) ]
  ! OR              [ shift and go to state 77 ]
  ! SEMICOLON       [ shift and go to state 78 ]


state 109

    (56) binary_exp -> exp SEMICOLON exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    LET             reduce using rule 56 (binary_exp -> exp SEMICOLON exp .)
    $end            reduce using rule 56 (binary_exp -> exp SEMICOLON exp .)
    RPAREN          reduce using rule 56 (binary_exp -> exp SEMICOLON exp .)
    THEN            reduce using rule 56 (binary_exp -> exp SEMICOLON exp .)
    DO              reduce using rule 56 (binary_exp -> exp SEMICOLON exp .)
    COMMA           reduce using rule 56 (binary_exp -> exp SEMICOLON exp .)
    RBRACKET        reduce using rule 56 (binary_exp -> exp SEMICOLON exp .)
    ELSE            reduce using rule 56 (binary_exp -> exp SEMICOLON exp .)
    BAR             reduce using rule 56 (binary_exp -> exp SEMICOLON exp .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69
    EQUALS          shift and go to state 70
    NOT_EQUALS      shift and go to state 71
    LESS            shift and go to state 72
    LESS_EQUAL      shift and go to state 73
    GREATER         shift and go to state 74
    GREATER_EQUAL   shift and go to state 75
    AND             shift and go to state 76
    OR              shift and go to state 77
    SEMICOLON       shift and go to state 78

  ! PLUS            [ reduce using rule 56 (binary_exp -> exp SEMICOLON exp .) ]
  ! MINUS           [ reduce using rule 56 (binary_exp -> exp SEMICOLON exp .) ]
  ! TIMES           [ reduce using rule 56 (binary_exp -> exp SEMICOLON exp .) ]
  ! DIVIDE          [ reduce using rule 56 (binary_exp -> exp SEMICOLON exp .) ]
  ! MOD             [ reduce using rule 56 (binary_exp -> exp SEMICOLON exp .) ]
  ! POWER           [ reduce using rule 56 (binary_exp -> exp SEMICOLON exp .) ]
  ! EQUALS          [ reduce using rule 56 (binary_exp -> exp SEMICOLON exp .) ]
  ! NOT_EQUALS      [ reduce using rule 56 (binary_exp -> exp SEMICOLON exp .) ]
  ! LESS            [ reduce using rule 56 (binary_exp -> exp SEMICOLON exp .) ]
  ! LESS_EQUAL      [ reduce using rule 56 (binary_exp -> exp SEMICOLON exp .) ]
  ! GREATER         [ reduce using rule 56 (binary_exp -> exp SEMICOLON exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 56 (binary_exp -> exp SEMICOLON exp .) ]
  ! AND             [ reduce using rule 56 (binary_exp -> exp SEMICOLON exp .) ]
  ! OR              [ reduce using rule 56 (binary_exp -> exp SEMICOLON exp .) ]
  ! SEMICOLON       [ reduce using rule 56 (binary_exp -> exp SEMICOLON exp .) ]


state 110

    (72) group -> LPAREN exp RPAREN .

    PLUS            reduce using rule 72 (group -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 72 (group -> LPAREN exp RPAREN .)
    TIMES           reduce using rule 72 (group -> LPAREN exp RPAREN .)
    DIVIDE          reduce using rule 72 (group -> LPAREN exp RPAREN .)
    MOD             reduce using rule 72 (group -> LPAREN exp RPAREN .)
    POWER           reduce using rule 72 (group -> LPAREN exp RPAREN .)
    EQUALS          reduce using rule 72 (group -> LPAREN exp RPAREN .)
    NOT_EQUALS      reduce using rule 72 (group -> LPAREN exp RPAREN .)
    LESS            reduce using rule 72 (group -> LPAREN exp RPAREN .)
    LESS_EQUAL      reduce using rule 72 (group -> LPAREN exp RPAREN .)
    GREATER         reduce using rule 72 (group -> LPAREN exp RPAREN .)
    GREATER_EQUAL   reduce using rule 72 (group -> LPAREN exp RPAREN .)
    AND             reduce using rule 72 (group -> LPAREN exp RPAREN .)
    OR              reduce using rule 72 (group -> LPAREN exp RPAREN .)
    SEMICOLON       reduce using rule 72 (group -> LPAREN exp RPAREN .)
    LET             reduce using rule 72 (group -> LPAREN exp RPAREN .)
    $end            reduce using rule 72 (group -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 72 (group -> LPAREN exp RPAREN .)
    THEN            reduce using rule 72 (group -> LPAREN exp RPAREN .)
    DO              reduce using rule 72 (group -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 72 (group -> LPAREN exp RPAREN .)
    RBRACKET        reduce using rule 72 (group -> LPAREN exp RPAREN .)
    ELSE            reduce using rule 72 (group -> LPAREN exp RPAREN .)
    BAR             reduce using rule 72 (group -> LPAREN exp RPAREN .)


state 111

    (63) assignment -> SET lhs ASSIGN . exp
    (21) exp -> . variable
    (22) exp -> . literal
    (23) exp -> . binary_exp
    (24) exp -> . unary_exp
    (25) exp -> . function_call
    (26) exp -> . assignment
    (27) exp -> . variable_declaration
    (28) exp -> . if_then_else
    (29) exp -> . if_then
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs ASSIGN exp
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (68) if_then_else -> . IF exp THEN exp ELSE exp
    (69) if_then -> . IF exp THEN exp
    (70) while_loop -> . WHILE exp DO exp
    (71) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (72) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NULL            shift and go to state 49
    UNIT            shift and go to state 50
    STRING_LITERAL  shift and go to state 51
    MINUS           shift and go to state 52
    NOT             shift and go to state 53
    SET             shift and go to state 55
    LET             shift and go to state 31
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    NEW             shift and go to state 59
    LPAREN          shift and go to state 54

    lhs                            shift and go to state 56
    exp                            shift and go to state 123
    variable                       shift and go to state 32
    literal                        shift and go to state 34
    binary_exp                     shift and go to state 35
    unary_exp                      shift and go to state 36
    function_call                  shift and go to state 37
    assignment                     shift and go to state 38
    variable_declaration           shift and go to state 39
    if_then_else                   shift and go to state 40
    if_then                        shift and go to state 41
    while_loop                     shift and go to state 42
    array_creation                 shift and go to state 43
    array_access                   shift and go to state 44
    group                          shift and go to state 45

state 112

    (66) array_access -> lhs LBRACKET exp . RBRACKET
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    RBRACKET        shift and go to state 124
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69
    EQUALS          shift and go to state 70
    NOT_EQUALS      shift and go to state 71
    LESS            shift and go to state 72
    LESS_EQUAL      shift and go to state 73
    GREATER         shift and go to state 74
    GREATER_EQUAL   shift and go to state 75
    AND             shift and go to state 76
    OR              shift and go to state 77
    SEMICOLON       shift and go to state 78


state 113

    (68) if_then_else -> IF exp THEN . exp ELSE exp
    (69) if_then -> IF exp THEN . exp
    (21) exp -> . variable
    (22) exp -> . literal
    (23) exp -> . binary_exp
    (24) exp -> . unary_exp
    (25) exp -> . function_call
    (26) exp -> . assignment
    (27) exp -> . variable_declaration
    (28) exp -> . if_then_else
    (29) exp -> . if_then
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs ASSIGN exp
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (68) if_then_else -> . IF exp THEN exp ELSE exp
    (69) if_then -> . IF exp THEN exp
    (70) while_loop -> . WHILE exp DO exp
    (71) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (72) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NULL            shift and go to state 49
    UNIT            shift and go to state 50
    STRING_LITERAL  shift and go to state 51
    MINUS           shift and go to state 52
    NOT             shift and go to state 53
    SET             shift and go to state 55
    LET             shift and go to state 31
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    NEW             shift and go to state 59
    LPAREN          shift and go to state 54

    exp                            shift and go to state 125
    variable                       shift and go to state 32
    literal                        shift and go to state 34
    binary_exp                     shift and go to state 35
    unary_exp                      shift and go to state 36
    function_call                  shift and go to state 37
    assignment                     shift and go to state 38
    variable_declaration           shift and go to state 39
    if_then_else                   shift and go to state 40
    if_then                        shift and go to state 41
    while_loop                     shift and go to state 42
    array_creation                 shift and go to state 43
    array_access                   shift and go to state 44
    group                          shift and go to state 45
    lhs                            shift and go to state 56

state 114

    (70) while_loop -> WHILE exp DO . exp
    (21) exp -> . variable
    (22) exp -> . literal
    (23) exp -> . binary_exp
    (24) exp -> . unary_exp
    (25) exp -> . function_call
    (26) exp -> . assignment
    (27) exp -> . variable_declaration
    (28) exp -> . if_then_else
    (29) exp -> . if_then
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs ASSIGN exp
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (68) if_then_else -> . IF exp THEN exp ELSE exp
    (69) if_then -> . IF exp THEN exp
    (70) while_loop -> . WHILE exp DO exp
    (71) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (72) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NULL            shift and go to state 49
    UNIT            shift and go to state 50
    STRING_LITERAL  shift and go to state 51
    MINUS           shift and go to state 52
    NOT             shift and go to state 53
    SET             shift and go to state 55
    LET             shift and go to state 31
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    NEW             shift and go to state 59
    LPAREN          shift and go to state 54

    exp                            shift and go to state 126
    variable                       shift and go to state 32
    literal                        shift and go to state 34
    binary_exp                     shift and go to state 35
    unary_exp                      shift and go to state 36
    function_call                  shift and go to state 37
    assignment                     shift and go to state 38
    variable_declaration           shift and go to state 39
    if_then_else                   shift and go to state 40
    if_then                        shift and go to state 41
    while_loop                     shift and go to state 42
    array_creation                 shift and go to state 43
    array_access                   shift and go to state 44
    group                          shift and go to state 45
    lhs                            shift and go to state 56

state 115

    (71) array_creation -> NEW type LBRACKET . exp BAR exp RBRACKET
    (16) array_type -> type LBRACKET . RBRACKET
    (21) exp -> . variable
    (22) exp -> . literal
    (23) exp -> . binary_exp
    (24) exp -> . unary_exp
    (25) exp -> . function_call
    (26) exp -> . assignment
    (27) exp -> . variable_declaration
    (28) exp -> . if_then_else
    (29) exp -> . if_then
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs ASSIGN exp
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (68) if_then_else -> . IF exp THEN exp ELSE exp
    (69) if_then -> . IF exp THEN exp
    (70) while_loop -> . WHILE exp DO exp
    (71) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (72) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    RBRACKET        shift and go to state 60
    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NULL            shift and go to state 49
    UNIT            shift and go to state 50
    STRING_LITERAL  shift and go to state 51
    MINUS           shift and go to state 52
    NOT             shift and go to state 53
    SET             shift and go to state 55
    LET             shift and go to state 31
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    NEW             shift and go to state 59
    LPAREN          shift and go to state 54

    exp                            shift and go to state 127
    variable                       shift and go to state 32
    literal                        shift and go to state 34
    binary_exp                     shift and go to state 35
    unary_exp                      shift and go to state 36
    function_call                  shift and go to state 37
    assignment                     shift and go to state 38
    variable_declaration           shift and go to state 39
    if_then_else                   shift and go to state 40
    if_then                        shift and go to state 41
    while_loop                     shift and go to state 42
    array_creation                 shift and go to state 43
    array_access                   shift and go to state 44
    group                          shift and go to state 45
    lhs                            shift and go to state 56

state 116

    (18) function_type -> LPAREN type . function_type_tail RPAREN ARROW type
    (16) array_type -> type . LBRACKET RBRACKET
    (19) function_type_tail -> . COMMA type function_type_tail
    (20) function_type_tail -> . empty
    (73) empty -> .

    LBRACKET        shift and go to state 26
    COMMA           shift and go to state 129
    RPAREN          reduce using rule 73 (empty -> .)

    function_type_tail             shift and go to state 128
    empty                          shift and go to state 130

state 117

    (7) function_declaration -> LET ID LPAREN parameters RPAREN COLON function_type ASSIGN . exp
    (21) exp -> . variable
    (22) exp -> . literal
    (23) exp -> . binary_exp
    (24) exp -> . unary_exp
    (25) exp -> . function_call
    (26) exp -> . assignment
    (27) exp -> . variable_declaration
    (28) exp -> . if_then_else
    (29) exp -> . if_then
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs ASSIGN exp
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (68) if_then_else -> . IF exp THEN exp ELSE exp
    (69) if_then -> . IF exp THEN exp
    (70) while_loop -> . WHILE exp DO exp
    (71) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (72) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NULL            shift and go to state 49
    UNIT            shift and go to state 50
    STRING_LITERAL  shift and go to state 51
    MINUS           shift and go to state 52
    NOT             shift and go to state 53
    SET             shift and go to state 55
    LET             shift and go to state 31
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    NEW             shift and go to state 59
    LPAREN          shift and go to state 54

    exp                            shift and go to state 131
    variable                       shift and go to state 32
    literal                        shift and go to state 34
    binary_exp                     shift and go to state 35
    unary_exp                      shift and go to state 36
    function_call                  shift and go to state 37
    assignment                     shift and go to state 38
    variable_declaration           shift and go to state 39
    if_then_else                   shift and go to state 40
    if_then                        shift and go to state 41
    while_loop                     shift and go to state 42
    array_creation                 shift and go to state 43
    array_access                   shift and go to state 44
    group                          shift and go to state 45
    lhs                            shift and go to state 56

state 118

    (17) function_type -> type ARROW . type
    (11) type -> . INT_TYPE
    (12) type -> . STRING_TYPE
    (13) type -> . UNIT_TYPE
    (14) type -> . BOOL_TYPE
    (15) type -> . array_type
    (16) array_type -> . type LBRACKET RBRACKET

    INT_TYPE        shift and go to state 17
    STRING_TYPE     shift and go to state 18
    UNIT_TYPE       shift and go to state 19
    BOOL_TYPE       shift and go to state 20

    type                           shift and go to state 132
    array_type                     shift and go to state 21

state 119

    (59) function_call -> variable LPAREN arguments RPAREN .

    PLUS            reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    MINUS           reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    TIMES           reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    DIVIDE          reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    MOD             reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    POWER           reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    EQUALS          reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    NOT_EQUALS      reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    LESS            reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    LESS_EQUAL      reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    GREATER         reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    GREATER_EQUAL   reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    AND             reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    OR              reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    SEMICOLON       reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    LET             reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    $end            reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    THEN            reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    DO              reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    COMMA           reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    RBRACKET        reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    ELSE            reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    BAR             reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)


state 120

    (60) arguments -> exp arguments_tail .

    RPAREN          reduce using rule 60 (arguments -> exp arguments_tail .)


state 121

    (61) arguments_tail -> COMMA . exp arguments_tail
    (21) exp -> . variable
    (22) exp -> . literal
    (23) exp -> . binary_exp
    (24) exp -> . unary_exp
    (25) exp -> . function_call
    (26) exp -> . assignment
    (27) exp -> . variable_declaration
    (28) exp -> . if_then_else
    (29) exp -> . if_then
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs ASSIGN exp
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (68) if_then_else -> . IF exp THEN exp ELSE exp
    (69) if_then -> . IF exp THEN exp
    (70) while_loop -> . WHILE exp DO exp
    (71) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (72) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NULL            shift and go to state 49
    UNIT            shift and go to state 50
    STRING_LITERAL  shift and go to state 51
    MINUS           shift and go to state 52
    NOT             shift and go to state 53
    SET             shift and go to state 55
    LET             shift and go to state 31
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    NEW             shift and go to state 59
    LPAREN          shift and go to state 54

    exp                            shift and go to state 133
    variable                       shift and go to state 32
    literal                        shift and go to state 34
    binary_exp                     shift and go to state 35
    unary_exp                      shift and go to state 36
    function_call                  shift and go to state 37
    assignment                     shift and go to state 38
    variable_declaration           shift and go to state 39
    if_then_else                   shift and go to state 40
    if_then                        shift and go to state 41
    while_loop                     shift and go to state 42
    array_creation                 shift and go to state 43
    array_access                   shift and go to state 44
    group                          shift and go to state 45
    lhs                            shift and go to state 56

state 122

    (62) arguments_tail -> empty .

    RPAREN          reduce using rule 62 (arguments_tail -> empty .)


state 123

    (63) assignment -> SET lhs ASSIGN exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    SEMICOLON       reduce using rule 63 (assignment -> SET lhs ASSIGN exp .)
    LET             reduce using rule 63 (assignment -> SET lhs ASSIGN exp .)
    $end            reduce using rule 63 (assignment -> SET lhs ASSIGN exp .)
    RPAREN          reduce using rule 63 (assignment -> SET lhs ASSIGN exp .)
    THEN            reduce using rule 63 (assignment -> SET lhs ASSIGN exp .)
    DO              reduce using rule 63 (assignment -> SET lhs ASSIGN exp .)
    COMMA           reduce using rule 63 (assignment -> SET lhs ASSIGN exp .)
    RBRACKET        reduce using rule 63 (assignment -> SET lhs ASSIGN exp .)
    ELSE            reduce using rule 63 (assignment -> SET lhs ASSIGN exp .)
    BAR             reduce using rule 63 (assignment -> SET lhs ASSIGN exp .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69
    EQUALS          shift and go to state 70
    NOT_EQUALS      shift and go to state 71
    LESS            shift and go to state 72
    LESS_EQUAL      shift and go to state 73
    GREATER         shift and go to state 74
    GREATER_EQUAL   shift and go to state 75
    AND             shift and go to state 76
    OR              shift and go to state 77

  ! PLUS            [ reduce using rule 63 (assignment -> SET lhs ASSIGN exp .) ]
  ! MINUS           [ reduce using rule 63 (assignment -> SET lhs ASSIGN exp .) ]
  ! TIMES           [ reduce using rule 63 (assignment -> SET lhs ASSIGN exp .) ]
  ! DIVIDE          [ reduce using rule 63 (assignment -> SET lhs ASSIGN exp .) ]
  ! MOD             [ reduce using rule 63 (assignment -> SET lhs ASSIGN exp .) ]
  ! POWER           [ reduce using rule 63 (assignment -> SET lhs ASSIGN exp .) ]
  ! EQUALS          [ reduce using rule 63 (assignment -> SET lhs ASSIGN exp .) ]
  ! NOT_EQUALS      [ reduce using rule 63 (assignment -> SET lhs ASSIGN exp .) ]
  ! LESS            [ reduce using rule 63 (assignment -> SET lhs ASSIGN exp .) ]
  ! LESS_EQUAL      [ reduce using rule 63 (assignment -> SET lhs ASSIGN exp .) ]
  ! GREATER         [ reduce using rule 63 (assignment -> SET lhs ASSIGN exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 63 (assignment -> SET lhs ASSIGN exp .) ]
  ! AND             [ reduce using rule 63 (assignment -> SET lhs ASSIGN exp .) ]
  ! OR              [ reduce using rule 63 (assignment -> SET lhs ASSIGN exp .) ]
  ! SEMICOLON       [ shift and go to state 78 ]


state 124

    (66) array_access -> lhs LBRACKET exp RBRACKET .

    PLUS            reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    MINUS           reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    TIMES           reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    DIVIDE          reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    MOD             reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    POWER           reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    EQUALS          reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    NOT_EQUALS      reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    LESS            reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    LESS_EQUAL      reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    GREATER         reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    GREATER_EQUAL   reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    AND             reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    OR              reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    SEMICOLON       reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    LET             reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    $end            reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    THEN            reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    DO              reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    COMMA           reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    RBRACKET        reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    ELSE            reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    BAR             reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    LBRACKET        reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    ASSIGN          reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)


state 125

    (68) if_then_else -> IF exp THEN exp . ELSE exp
    (69) if_then -> IF exp THEN exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    ELSE            shift and go to state 134
    SEMICOLON       reduce using rule 69 (if_then -> IF exp THEN exp .)
    LET             reduce using rule 69 (if_then -> IF exp THEN exp .)
    $end            reduce using rule 69 (if_then -> IF exp THEN exp .)
    RPAREN          reduce using rule 69 (if_then -> IF exp THEN exp .)
    THEN            reduce using rule 69 (if_then -> IF exp THEN exp .)
    DO              reduce using rule 69 (if_then -> IF exp THEN exp .)
    COMMA           reduce using rule 69 (if_then -> IF exp THEN exp .)
    RBRACKET        reduce using rule 69 (if_then -> IF exp THEN exp .)
    BAR             reduce using rule 69 (if_then -> IF exp THEN exp .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69
    EQUALS          shift and go to state 70
    NOT_EQUALS      shift and go to state 71
    LESS            shift and go to state 72
    LESS_EQUAL      shift and go to state 73
    GREATER         shift and go to state 74
    GREATER_EQUAL   shift and go to state 75
    AND             shift and go to state 76
    OR              shift and go to state 77

  ! PLUS            [ reduce using rule 69 (if_then -> IF exp THEN exp .) ]
  ! MINUS           [ reduce using rule 69 (if_then -> IF exp THEN exp .) ]
  ! TIMES           [ reduce using rule 69 (if_then -> IF exp THEN exp .) ]
  ! DIVIDE          [ reduce using rule 69 (if_then -> IF exp THEN exp .) ]
  ! MOD             [ reduce using rule 69 (if_then -> IF exp THEN exp .) ]
  ! POWER           [ reduce using rule 69 (if_then -> IF exp THEN exp .) ]
  ! EQUALS          [ reduce using rule 69 (if_then -> IF exp THEN exp .) ]
  ! NOT_EQUALS      [ reduce using rule 69 (if_then -> IF exp THEN exp .) ]
  ! LESS            [ reduce using rule 69 (if_then -> IF exp THEN exp .) ]
  ! LESS_EQUAL      [ reduce using rule 69 (if_then -> IF exp THEN exp .) ]
  ! GREATER         [ reduce using rule 69 (if_then -> IF exp THEN exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 69 (if_then -> IF exp THEN exp .) ]
  ! AND             [ reduce using rule 69 (if_then -> IF exp THEN exp .) ]
  ! OR              [ reduce using rule 69 (if_then -> IF exp THEN exp .) ]
  ! ELSE            [ reduce using rule 69 (if_then -> IF exp THEN exp .) ]
  ! SEMICOLON       [ shift and go to state 78 ]


state 126

    (70) while_loop -> WHILE exp DO exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    SEMICOLON       reduce using rule 70 (while_loop -> WHILE exp DO exp .)
    LET             reduce using rule 70 (while_loop -> WHILE exp DO exp .)
    $end            reduce using rule 70 (while_loop -> WHILE exp DO exp .)
    RPAREN          reduce using rule 70 (while_loop -> WHILE exp DO exp .)
    THEN            reduce using rule 70 (while_loop -> WHILE exp DO exp .)
    DO              reduce using rule 70 (while_loop -> WHILE exp DO exp .)
    COMMA           reduce using rule 70 (while_loop -> WHILE exp DO exp .)
    RBRACKET        reduce using rule 70 (while_loop -> WHILE exp DO exp .)
    ELSE            reduce using rule 70 (while_loop -> WHILE exp DO exp .)
    BAR             reduce using rule 70 (while_loop -> WHILE exp DO exp .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69
    EQUALS          shift and go to state 70
    NOT_EQUALS      shift and go to state 71
    LESS            shift and go to state 72
    LESS_EQUAL      shift and go to state 73
    GREATER         shift and go to state 74
    GREATER_EQUAL   shift and go to state 75
    AND             shift and go to state 76
    OR              shift and go to state 77

  ! PLUS            [ reduce using rule 70 (while_loop -> WHILE exp DO exp .) ]
  ! MINUS           [ reduce using rule 70 (while_loop -> WHILE exp DO exp .) ]
  ! TIMES           [ reduce using rule 70 (while_loop -> WHILE exp DO exp .) ]
  ! DIVIDE          [ reduce using rule 70 (while_loop -> WHILE exp DO exp .) ]
  ! MOD             [ reduce using rule 70 (while_loop -> WHILE exp DO exp .) ]
  ! POWER           [ reduce using rule 70 (while_loop -> WHILE exp DO exp .) ]
  ! EQUALS          [ reduce using rule 70 (while_loop -> WHILE exp DO exp .) ]
  ! NOT_EQUALS      [ reduce using rule 70 (while_loop -> WHILE exp DO exp .) ]
  ! LESS            [ reduce using rule 70 (while_loop -> WHILE exp DO exp .) ]
  ! LESS_EQUAL      [ reduce using rule 70 (while_loop -> WHILE exp DO exp .) ]
  ! GREATER         [ reduce using rule 70 (while_loop -> WHILE exp DO exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 70 (while_loop -> WHILE exp DO exp .) ]
  ! AND             [ reduce using rule 70 (while_loop -> WHILE exp DO exp .) ]
  ! OR              [ reduce using rule 70 (while_loop -> WHILE exp DO exp .) ]
  ! SEMICOLON       [ shift and go to state 78 ]


state 127

    (71) array_creation -> NEW type LBRACKET exp . BAR exp RBRACKET
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    BAR             shift and go to state 135
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69
    EQUALS          shift and go to state 70
    NOT_EQUALS      shift and go to state 71
    LESS            shift and go to state 72
    LESS_EQUAL      shift and go to state 73
    GREATER         shift and go to state 74
    GREATER_EQUAL   shift and go to state 75
    AND             shift and go to state 76
    OR              shift and go to state 77
    SEMICOLON       shift and go to state 78


state 128

    (18) function_type -> LPAREN type function_type_tail . RPAREN ARROW type

    RPAREN          shift and go to state 136


state 129

    (19) function_type_tail -> COMMA . type function_type_tail
    (11) type -> . INT_TYPE
    (12) type -> . STRING_TYPE
    (13) type -> . UNIT_TYPE
    (14) type -> . BOOL_TYPE
    (15) type -> . array_type
    (16) array_type -> . type LBRACKET RBRACKET

    INT_TYPE        shift and go to state 17
    STRING_TYPE     shift and go to state 18
    UNIT_TYPE       shift and go to state 19
    BOOL_TYPE       shift and go to state 20

    type                           shift and go to state 137
    array_type                     shift and go to state 21

state 130

    (20) function_type_tail -> empty .

    RPAREN          reduce using rule 20 (function_type_tail -> empty .)


state 131

    (7) function_declaration -> LET ID LPAREN parameters RPAREN COLON function_type ASSIGN exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    LET             reduce using rule 7 (function_declaration -> LET ID LPAREN parameters RPAREN COLON function_type ASSIGN exp .)
    $end            reduce using rule 7 (function_declaration -> LET ID LPAREN parameters RPAREN COLON function_type ASSIGN exp .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69
    EQUALS          shift and go to state 70
    NOT_EQUALS      shift and go to state 71
    LESS            shift and go to state 72
    LESS_EQUAL      shift and go to state 73
    GREATER         shift and go to state 74
    GREATER_EQUAL   shift and go to state 75
    AND             shift and go to state 76
    OR              shift and go to state 77
    SEMICOLON       shift and go to state 78


state 132

    (17) function_type -> type ARROW type .
    (16) array_type -> type . LBRACKET RBRACKET

    ASSIGN          reduce using rule 17 (function_type -> type ARROW type .)
    LBRACKET        shift and go to state 26


state 133

    (61) arguments_tail -> COMMA exp . arguments_tail
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp
    (61) arguments_tail -> . COMMA exp arguments_tail
    (62) arguments_tail -> . empty
    (73) empty -> .

    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69
    EQUALS          shift and go to state 70
    NOT_EQUALS      shift and go to state 71
    LESS            shift and go to state 72
    LESS_EQUAL      shift and go to state 73
    GREATER         shift and go to state 74
    GREATER_EQUAL   shift and go to state 75
    AND             shift and go to state 76
    OR              shift and go to state 77
    SEMICOLON       shift and go to state 78
    COMMA           shift and go to state 121
    RPAREN          reduce using rule 73 (empty -> .)

    arguments_tail                 shift and go to state 138
    empty                          shift and go to state 122

state 134

    (68) if_then_else -> IF exp THEN exp ELSE . exp
    (21) exp -> . variable
    (22) exp -> . literal
    (23) exp -> . binary_exp
    (24) exp -> . unary_exp
    (25) exp -> . function_call
    (26) exp -> . assignment
    (27) exp -> . variable_declaration
    (28) exp -> . if_then_else
    (29) exp -> . if_then
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs ASSIGN exp
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (68) if_then_else -> . IF exp THEN exp ELSE exp
    (69) if_then -> . IF exp THEN exp
    (70) while_loop -> . WHILE exp DO exp
    (71) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (72) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NULL            shift and go to state 49
    UNIT            shift and go to state 50
    STRING_LITERAL  shift and go to state 51
    MINUS           shift and go to state 52
    NOT             shift and go to state 53
    SET             shift and go to state 55
    LET             shift and go to state 31
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    NEW             shift and go to state 59
    LPAREN          shift and go to state 54

    exp                            shift and go to state 139
    variable                       shift and go to state 32
    literal                        shift and go to state 34
    binary_exp                     shift and go to state 35
    unary_exp                      shift and go to state 36
    function_call                  shift and go to state 37
    assignment                     shift and go to state 38
    variable_declaration           shift and go to state 39
    if_then_else                   shift and go to state 40
    if_then                        shift and go to state 41
    while_loop                     shift and go to state 42
    array_creation                 shift and go to state 43
    array_access                   shift and go to state 44
    group                          shift and go to state 45
    lhs                            shift and go to state 56

state 135

    (71) array_creation -> NEW type LBRACKET exp BAR . exp RBRACKET
    (21) exp -> . variable
    (22) exp -> . literal
    (23) exp -> . binary_exp
    (24) exp -> . unary_exp
    (25) exp -> . function_call
    (26) exp -> . assignment
    (27) exp -> . variable_declaration
    (28) exp -> . if_then_else
    (29) exp -> . if_then
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs ASSIGN exp
    (67) variable_declaration -> . LET variable COLON type ASSIGN exp
    (68) if_then_else -> . IF exp THEN exp ELSE exp
    (69) if_then -> . IF exp THEN exp
    (70) while_loop -> . WHILE exp DO exp
    (71) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (72) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NULL            shift and go to state 49
    UNIT            shift and go to state 50
    STRING_LITERAL  shift and go to state 51
    MINUS           shift and go to state 52
    NOT             shift and go to state 53
    SET             shift and go to state 55
    LET             shift and go to state 31
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    NEW             shift and go to state 59
    LPAREN          shift and go to state 54

    exp                            shift and go to state 140
    variable                       shift and go to state 32
    literal                        shift and go to state 34
    binary_exp                     shift and go to state 35
    unary_exp                      shift and go to state 36
    function_call                  shift and go to state 37
    assignment                     shift and go to state 38
    variable_declaration           shift and go to state 39
    if_then_else                   shift and go to state 40
    if_then                        shift and go to state 41
    while_loop                     shift and go to state 42
    array_creation                 shift and go to state 43
    array_access                   shift and go to state 44
    group                          shift and go to state 45
    lhs                            shift and go to state 56

state 136

    (18) function_type -> LPAREN type function_type_tail RPAREN . ARROW type

    ARROW           shift and go to state 141


state 137

    (19) function_type_tail -> COMMA type . function_type_tail
    (16) array_type -> type . LBRACKET RBRACKET
    (19) function_type_tail -> . COMMA type function_type_tail
    (20) function_type_tail -> . empty
    (73) empty -> .

    LBRACKET        shift and go to state 26
    COMMA           shift and go to state 129
    RPAREN          reduce using rule 73 (empty -> .)

    function_type_tail             shift and go to state 142
    empty                          shift and go to state 130

state 138

    (61) arguments_tail -> COMMA exp arguments_tail .

    RPAREN          reduce using rule 61 (arguments_tail -> COMMA exp arguments_tail .)


state 139

    (68) if_then_else -> IF exp THEN exp ELSE exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    SEMICOLON       reduce using rule 68 (if_then_else -> IF exp THEN exp ELSE exp .)
    LET             reduce using rule 68 (if_then_else -> IF exp THEN exp ELSE exp .)
    $end            reduce using rule 68 (if_then_else -> IF exp THEN exp ELSE exp .)
    RPAREN          reduce using rule 68 (if_then_else -> IF exp THEN exp ELSE exp .)
    THEN            reduce using rule 68 (if_then_else -> IF exp THEN exp ELSE exp .)
    DO              reduce using rule 68 (if_then_else -> IF exp THEN exp ELSE exp .)
    COMMA           reduce using rule 68 (if_then_else -> IF exp THEN exp ELSE exp .)
    RBRACKET        reduce using rule 68 (if_then_else -> IF exp THEN exp ELSE exp .)
    ELSE            reduce using rule 68 (if_then_else -> IF exp THEN exp ELSE exp .)
    BAR             reduce using rule 68 (if_then_else -> IF exp THEN exp ELSE exp .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69
    EQUALS          shift and go to state 70
    NOT_EQUALS      shift and go to state 71
    LESS            shift and go to state 72
    LESS_EQUAL      shift and go to state 73
    GREATER         shift and go to state 74
    GREATER_EQUAL   shift and go to state 75
    AND             shift and go to state 76
    OR              shift and go to state 77

  ! PLUS            [ reduce using rule 68 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! MINUS           [ reduce using rule 68 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! TIMES           [ reduce using rule 68 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! DIVIDE          [ reduce using rule 68 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! MOD             [ reduce using rule 68 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! POWER           [ reduce using rule 68 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! EQUALS          [ reduce using rule 68 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! NOT_EQUALS      [ reduce using rule 68 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! LESS            [ reduce using rule 68 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! LESS_EQUAL      [ reduce using rule 68 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! GREATER         [ reduce using rule 68 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 68 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! AND             [ reduce using rule 68 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! OR              [ reduce using rule 68 (if_then_else -> IF exp THEN exp ELSE exp .) ]
  ! SEMICOLON       [ shift and go to state 78 ]


state 140

    (71) array_creation -> NEW type LBRACKET exp BAR exp . RBRACKET
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    RBRACKET        shift and go to state 143
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69
    EQUALS          shift and go to state 70
    NOT_EQUALS      shift and go to state 71
    LESS            shift and go to state 72
    LESS_EQUAL      shift and go to state 73
    GREATER         shift and go to state 74
    GREATER_EQUAL   shift and go to state 75
    AND             shift and go to state 76
    OR              shift and go to state 77
    SEMICOLON       shift and go to state 78


state 141

    (18) function_type -> LPAREN type function_type_tail RPAREN ARROW . type
    (11) type -> . INT_TYPE
    (12) type -> . STRING_TYPE
    (13) type -> . UNIT_TYPE
    (14) type -> . BOOL_TYPE
    (15) type -> . array_type
    (16) array_type -> . type LBRACKET RBRACKET

    INT_TYPE        shift and go to state 17
    STRING_TYPE     shift and go to state 18
    UNIT_TYPE       shift and go to state 19
    BOOL_TYPE       shift and go to state 20

    type                           shift and go to state 144
    array_type                     shift and go to state 21

state 142

    (19) function_type_tail -> COMMA type function_type_tail .

    RPAREN          reduce using rule 19 (function_type_tail -> COMMA type function_type_tail .)


state 143

    (71) array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .

    PLUS            reduce using rule 71 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    MINUS           reduce using rule 71 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    TIMES           reduce using rule 71 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    DIVIDE          reduce using rule 71 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    MOD             reduce using rule 71 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    POWER           reduce using rule 71 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    EQUALS          reduce using rule 71 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    NOT_EQUALS      reduce using rule 71 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    LESS            reduce using rule 71 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    LESS_EQUAL      reduce using rule 71 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    GREATER         reduce using rule 71 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    GREATER_EQUAL   reduce using rule 71 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    AND             reduce using rule 71 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    OR              reduce using rule 71 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    SEMICOLON       reduce using rule 71 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    LET             reduce using rule 71 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    $end            reduce using rule 71 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    RPAREN          reduce using rule 71 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    THEN            reduce using rule 71 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    DO              reduce using rule 71 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    COMMA           reduce using rule 71 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    RBRACKET        reduce using rule 71 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    ELSE            reduce using rule 71 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    BAR             reduce using rule 71 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)


state 144

    (18) function_type -> LPAREN type function_type_tail RPAREN ARROW type .
    (16) array_type -> type . LBRACKET RBRACKET

    ASSIGN          reduce using rule 18 (function_type -> LPAREN type function_type_tail RPAREN ARROW type .)
    LBRACKET        shift and go to state 26

