Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> declarations
Rule 2     declarations -> declaration declarations_tail
Rule 3     declarations_tail -> declaration declarations_tail
Rule 4     declarations_tail -> empty
Rule 5     declaration -> variable_declaration
Rule 6     declaration -> function_declaration
Rule 7     function_declaration -> LET ID LPAREN parameters RPAREN COLON function_type EQUALS exp
Rule 8     parameters -> variable parameters_tail
Rule 9     parameters_tail -> COMMA variable parameters_tail
Rule 10    parameters_tail -> empty
Rule 11    type -> base_type array_suffix
Rule 12    base_type -> INT_TYPE
Rule 13    base_type -> BOOL_TYPE
Rule 14    base_type -> UNIT_TYPE
Rule 15    base_type -> STRING_TYPE
Rule 16    array_suffix -> LBRACKET RBRACKET array_suffix
Rule 17    array_suffix -> empty
Rule 18    function_type -> type ARROW type
Rule 19    function_type -> LPAREN type function_type_tail RPAREN ARROW type
Rule 20    function_type_tail -> COMMA type function_type_tail
Rule 21    function_type_tail -> empty
Rule 22    exp -> variable
Rule 23    exp -> literal
Rule 24    exp -> binary_exp
Rule 25    exp -> unary_exp
Rule 26    exp -> function_call
Rule 27    exp -> assignment
Rule 28    exp -> variable_declaration
Rule 29    exp -> conditional
Rule 30    exp -> while_loop
Rule 31    exp -> array_creation
Rule 32    exp -> array_access
Rule 33    exp -> group
Rule 34    variable -> ID
Rule 35    variable -> UNDERSCORE
Rule 36    literal -> INT_LITERAL
Rule 37    literal -> TRUE
Rule 38    literal -> FALSE
Rule 39    literal -> NULL
Rule 40    literal -> UNIT
Rule 41    literal -> STRING_LITERAL
Rule 42    binary_exp -> exp PLUS exp
Rule 43    binary_exp -> exp MINUS exp
Rule 44    binary_exp -> exp TIMES exp
Rule 45    binary_exp -> exp DIVIDE exp
Rule 46    binary_exp -> exp MOD exp
Rule 47    binary_exp -> exp POWER exp
Rule 48    binary_exp -> exp EQUALS exp
Rule 49    binary_exp -> exp NOT_EQUALS exp
Rule 50    binary_exp -> exp LESS exp
Rule 51    binary_exp -> exp LESS_EQUAL exp
Rule 52    binary_exp -> exp GREATER exp
Rule 53    binary_exp -> exp GREATER_EQUAL exp
Rule 54    binary_exp -> exp AND exp
Rule 55    binary_exp -> exp OR exp
Rule 56    binary_exp -> exp SEMICOLON exp
Rule 57    unary_exp -> MINUS exp
Rule 58    unary_exp -> NOT exp
Rule 59    function_call -> variable LPAREN arguments RPAREN
Rule 60    arguments -> exp arguments_tail
Rule 61    arguments_tail -> COMMA exp arguments_tail
Rule 62    arguments_tail -> empty
Rule 63    assignment -> SET lhs EQUALS exp
Rule 64    lhs -> variable
Rule 65    lhs -> array_access
Rule 66    array_access -> lhs LBRACKET exp RBRACKET
Rule 67    variable_declaration -> LET variable COLON type EQUALS exp
Rule 68    conditional -> IF exp THEN exp conditional_else
Rule 69    conditional_else -> ELSE exp
Rule 70    conditional_else -> empty
Rule 71    while_loop -> WHILE exp DO exp
Rule 72    array_creation -> NEW type LBRACKET exp BAR exp RBRACKET
Rule 73    group -> LPAREN exp RPAREN
Rule 74    empty -> <empty>

Terminals, with rules where they appear

AND                  : 54
ARROW                : 18 19
BAR                  : 72
BOOL_TYPE            : 13
COLON                : 7 67
COMMA                : 9 20 61
DIVIDE               : 45
DO                   : 71
ELSE                 : 69
EQUALS               : 7 48 63 67
FALSE                : 38
GREATER              : 52
GREATER_EQUAL        : 53
ID                   : 7 34
IF                   : 68
INT_LITERAL          : 36
INT_TYPE             : 12
LBRACKET             : 16 66 72
LESS                 : 50
LESS_EQUAL           : 51
LET                  : 7 67
LPAREN               : 7 19 59 73
MINUS                : 43 57
MOD                  : 46
NEW                  : 72
NOT                  : 58
NOT_EQUALS           : 49
NULL                 : 39
OR                   : 55
PLUS                 : 42
POWER                : 47
RBRACKET             : 16 66 72
RPAREN               : 7 19 59 73
SEMICOLON            : 56
SET                  : 63
STRING_LITERAL       : 41
STRING_TYPE          : 15
THEN                 : 68
TIMES                : 44
TRUE                 : 37
UNDERSCORE           : 35
UNIT                 : 40
UNIT_TYPE            : 14
WHILE                : 71
error                : 

Nonterminals, with rules where they appear

arguments            : 59
arguments_tail       : 60 61
array_access         : 32 65
array_creation       : 31
array_suffix         : 11 16
assignment           : 27
base_type            : 11
binary_exp           : 24
conditional          : 29
conditional_else     : 68
declaration          : 2 3
declarations         : 1
declarations_tail    : 2 3
empty                : 4 10 17 21 62 70
exp                  : 7 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 58 60 61 63 66 67 68 68 69 71 71 72 72 73
function_call        : 26
function_declaration : 6
function_type        : 7
function_type_tail   : 19 20
group                : 33
lhs                  : 63 66
literal              : 23
parameters           : 7
parameters_tail      : 8 9
program              : 0
type                 : 18 18 19 19 20 67 72
unary_exp            : 25
variable             : 8 9 22 59 64 67
variable_declaration : 5 28
while_loop           : 30

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declarations
    (2) declarations -> . declaration declarations_tail
    (5) declaration -> . variable_declaration
    (6) declaration -> . function_declaration
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (7) function_declaration -> . LET ID LPAREN parameters RPAREN COLON function_type EQUALS exp

    LET             shift and go to state 6

    program                        shift and go to state 1
    declarations                   shift and go to state 2
    declaration                    shift and go to state 3
    variable_declaration           shift and go to state 4
    function_declaration           shift and go to state 5

state 1

    (0) S' -> program .



state 2

    (1) program -> declarations .

    $end            reduce using rule 1 (program -> declarations .)


state 3

    (2) declarations -> declaration . declarations_tail
    (3) declarations_tail -> . declaration declarations_tail
    (4) declarations_tail -> . empty
    (5) declaration -> . variable_declaration
    (6) declaration -> . function_declaration
    (74) empty -> .
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (7) function_declaration -> . LET ID LPAREN parameters RPAREN COLON function_type EQUALS exp

    $end            reduce using rule 74 (empty -> .)
    LET             shift and go to state 6

    declaration                    shift and go to state 7
    declarations_tail              shift and go to state 8
    empty                          shift and go to state 9
    variable_declaration           shift and go to state 4
    function_declaration           shift and go to state 5

state 4

    (5) declaration -> variable_declaration .

    LET             reduce using rule 5 (declaration -> variable_declaration .)
    $end            reduce using rule 5 (declaration -> variable_declaration .)


state 5

    (6) declaration -> function_declaration .

    LET             reduce using rule 6 (declaration -> function_declaration .)
    $end            reduce using rule 6 (declaration -> function_declaration .)


state 6

    (67) variable_declaration -> LET . variable COLON type EQUALS exp
    (7) function_declaration -> LET . ID LPAREN parameters RPAREN COLON function_type EQUALS exp
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE

    ID              shift and go to state 11
    UNDERSCORE      shift and go to state 12

    variable                       shift and go to state 10

state 7

    (3) declarations_tail -> declaration . declarations_tail
    (3) declarations_tail -> . declaration declarations_tail
    (4) declarations_tail -> . empty
    (5) declaration -> . variable_declaration
    (6) declaration -> . function_declaration
    (74) empty -> .
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (7) function_declaration -> . LET ID LPAREN parameters RPAREN COLON function_type EQUALS exp

    $end            reduce using rule 74 (empty -> .)
    LET             shift and go to state 6

    declaration                    shift and go to state 7
    declarations_tail              shift and go to state 13
    empty                          shift and go to state 9
    variable_declaration           shift and go to state 4
    function_declaration           shift and go to state 5

state 8

    (2) declarations -> declaration declarations_tail .

    $end            reduce using rule 2 (declarations -> declaration declarations_tail .)


state 9

    (4) declarations_tail -> empty .

    $end            reduce using rule 4 (declarations_tail -> empty .)


state 10

    (67) variable_declaration -> LET variable . COLON type EQUALS exp

    COLON           shift and go to state 14


state 11

    (7) function_declaration -> LET ID . LPAREN parameters RPAREN COLON function_type EQUALS exp
    (34) variable -> ID .

    LPAREN          shift and go to state 15
    COLON           reduce using rule 34 (variable -> ID .)


state 12

    (35) variable -> UNDERSCORE .

    COLON           reduce using rule 35 (variable -> UNDERSCORE .)
    COMMA           reduce using rule 35 (variable -> UNDERSCORE .)
    RPAREN          reduce using rule 35 (variable -> UNDERSCORE .)
    LPAREN          reduce using rule 35 (variable -> UNDERSCORE .)
    PLUS            reduce using rule 35 (variable -> UNDERSCORE .)
    MINUS           reduce using rule 35 (variable -> UNDERSCORE .)
    TIMES           reduce using rule 35 (variable -> UNDERSCORE .)
    DIVIDE          reduce using rule 35 (variable -> UNDERSCORE .)
    MOD             reduce using rule 35 (variable -> UNDERSCORE .)
    POWER           reduce using rule 35 (variable -> UNDERSCORE .)
    EQUALS          reduce using rule 35 (variable -> UNDERSCORE .)
    NOT_EQUALS      reduce using rule 35 (variable -> UNDERSCORE .)
    LESS            reduce using rule 35 (variable -> UNDERSCORE .)
    LESS_EQUAL      reduce using rule 35 (variable -> UNDERSCORE .)
    GREATER         reduce using rule 35 (variable -> UNDERSCORE .)
    GREATER_EQUAL   reduce using rule 35 (variable -> UNDERSCORE .)
    AND             reduce using rule 35 (variable -> UNDERSCORE .)
    OR              reduce using rule 35 (variable -> UNDERSCORE .)
    SEMICOLON       reduce using rule 35 (variable -> UNDERSCORE .)
    LET             reduce using rule 35 (variable -> UNDERSCORE .)
    $end            reduce using rule 35 (variable -> UNDERSCORE .)
    THEN            reduce using rule 35 (variable -> UNDERSCORE .)
    DO              reduce using rule 35 (variable -> UNDERSCORE .)
    RBRACKET        reduce using rule 35 (variable -> UNDERSCORE .)
    ELSE            reduce using rule 35 (variable -> UNDERSCORE .)
    BAR             reduce using rule 35 (variable -> UNDERSCORE .)
    LBRACKET        reduce using rule 35 (variable -> UNDERSCORE .)


state 13

    (3) declarations_tail -> declaration declarations_tail .

    $end            reduce using rule 3 (declarations_tail -> declaration declarations_tail .)


state 14

    (67) variable_declaration -> LET variable COLON . type EQUALS exp
    (11) type -> . base_type array_suffix
    (12) base_type -> . INT_TYPE
    (13) base_type -> . BOOL_TYPE
    (14) base_type -> . UNIT_TYPE
    (15) base_type -> . STRING_TYPE

    INT_TYPE        shift and go to state 18
    BOOL_TYPE       shift and go to state 19
    UNIT_TYPE       shift and go to state 20
    STRING_TYPE     shift and go to state 21

    type                           shift and go to state 16
    base_type                      shift and go to state 17

state 15

    (7) function_declaration -> LET ID LPAREN . parameters RPAREN COLON function_type EQUALS exp
    (8) parameters -> . variable parameters_tail
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12

    parameters                     shift and go to state 23
    variable                       shift and go to state 24

state 16

    (67) variable_declaration -> LET variable COLON type . EQUALS exp

    EQUALS          shift and go to state 25


state 17

    (11) type -> base_type . array_suffix
    (16) array_suffix -> . LBRACKET RBRACKET array_suffix
    (17) array_suffix -> . empty
    (74) empty -> .

  ! shift/reduce conflict for LBRACKET resolved as shift
    LBRACKET        shift and go to state 27
    EQUALS          reduce using rule 74 (empty -> .)
    ARROW           reduce using rule 74 (empty -> .)
    COMMA           reduce using rule 74 (empty -> .)
    RPAREN          reduce using rule 74 (empty -> .)

  ! LBRACKET        [ reduce using rule 74 (empty -> .) ]

    array_suffix                   shift and go to state 26
    empty                          shift and go to state 28

state 18

    (12) base_type -> INT_TYPE .

    LBRACKET        reduce using rule 12 (base_type -> INT_TYPE .)
    EQUALS          reduce using rule 12 (base_type -> INT_TYPE .)
    ARROW           reduce using rule 12 (base_type -> INT_TYPE .)
    COMMA           reduce using rule 12 (base_type -> INT_TYPE .)
    RPAREN          reduce using rule 12 (base_type -> INT_TYPE .)


state 19

    (13) base_type -> BOOL_TYPE .

    LBRACKET        reduce using rule 13 (base_type -> BOOL_TYPE .)
    EQUALS          reduce using rule 13 (base_type -> BOOL_TYPE .)
    ARROW           reduce using rule 13 (base_type -> BOOL_TYPE .)
    COMMA           reduce using rule 13 (base_type -> BOOL_TYPE .)
    RPAREN          reduce using rule 13 (base_type -> BOOL_TYPE .)


state 20

    (14) base_type -> UNIT_TYPE .

    LBRACKET        reduce using rule 14 (base_type -> UNIT_TYPE .)
    EQUALS          reduce using rule 14 (base_type -> UNIT_TYPE .)
    ARROW           reduce using rule 14 (base_type -> UNIT_TYPE .)
    COMMA           reduce using rule 14 (base_type -> UNIT_TYPE .)
    RPAREN          reduce using rule 14 (base_type -> UNIT_TYPE .)


state 21

    (15) base_type -> STRING_TYPE .

    LBRACKET        reduce using rule 15 (base_type -> STRING_TYPE .)
    EQUALS          reduce using rule 15 (base_type -> STRING_TYPE .)
    ARROW           reduce using rule 15 (base_type -> STRING_TYPE .)
    COMMA           reduce using rule 15 (base_type -> STRING_TYPE .)
    RPAREN          reduce using rule 15 (base_type -> STRING_TYPE .)


state 22

    (34) variable -> ID .

    COMMA           reduce using rule 34 (variable -> ID .)
    RPAREN          reduce using rule 34 (variable -> ID .)
    LPAREN          reduce using rule 34 (variable -> ID .)
    PLUS            reduce using rule 34 (variable -> ID .)
    MINUS           reduce using rule 34 (variable -> ID .)
    TIMES           reduce using rule 34 (variable -> ID .)
    DIVIDE          reduce using rule 34 (variable -> ID .)
    MOD             reduce using rule 34 (variable -> ID .)
    POWER           reduce using rule 34 (variable -> ID .)
    EQUALS          reduce using rule 34 (variable -> ID .)
    NOT_EQUALS      reduce using rule 34 (variable -> ID .)
    LESS            reduce using rule 34 (variable -> ID .)
    LESS_EQUAL      reduce using rule 34 (variable -> ID .)
    GREATER         reduce using rule 34 (variable -> ID .)
    GREATER_EQUAL   reduce using rule 34 (variable -> ID .)
    AND             reduce using rule 34 (variable -> ID .)
    OR              reduce using rule 34 (variable -> ID .)
    SEMICOLON       reduce using rule 34 (variable -> ID .)
    LET             reduce using rule 34 (variable -> ID .)
    $end            reduce using rule 34 (variable -> ID .)
    THEN            reduce using rule 34 (variable -> ID .)
    DO              reduce using rule 34 (variable -> ID .)
    RBRACKET        reduce using rule 34 (variable -> ID .)
    ELSE            reduce using rule 34 (variable -> ID .)
    BAR             reduce using rule 34 (variable -> ID .)
    LBRACKET        reduce using rule 34 (variable -> ID .)
    COLON           reduce using rule 34 (variable -> ID .)


state 23

    (7) function_declaration -> LET ID LPAREN parameters . RPAREN COLON function_type EQUALS exp

    RPAREN          shift and go to state 29


state 24

    (8) parameters -> variable . parameters_tail
    (9) parameters_tail -> . COMMA variable parameters_tail
    (10) parameters_tail -> . empty
    (74) empty -> .

    COMMA           shift and go to state 31
    RPAREN          reduce using rule 74 (empty -> .)

    parameters_tail                shift and go to state 30
    empty                          shift and go to state 32

state 25

    (67) variable_declaration -> LET variable COLON type EQUALS . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . conditional
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs EQUALS exp
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (68) conditional -> . IF exp THEN exp conditional_else
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 33
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    variable                       shift and go to state 34
    exp                            shift and go to state 35
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    conditional                    shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 26

    (11) type -> base_type array_suffix .

    EQUALS          reduce using rule 11 (type -> base_type array_suffix .)
    LBRACKET        reduce using rule 11 (type -> base_type array_suffix .)
    ARROW           reduce using rule 11 (type -> base_type array_suffix .)
    COMMA           reduce using rule 11 (type -> base_type array_suffix .)
    RPAREN          reduce using rule 11 (type -> base_type array_suffix .)


state 27

    (16) array_suffix -> LBRACKET . RBRACKET array_suffix

    RBRACKET        shift and go to state 61


state 28

    (17) array_suffix -> empty .

    EQUALS          reduce using rule 17 (array_suffix -> empty .)
    LBRACKET        reduce using rule 17 (array_suffix -> empty .)
    ARROW           reduce using rule 17 (array_suffix -> empty .)
    COMMA           reduce using rule 17 (array_suffix -> empty .)
    RPAREN          reduce using rule 17 (array_suffix -> empty .)


state 29

    (7) function_declaration -> LET ID LPAREN parameters RPAREN . COLON function_type EQUALS exp

    COLON           shift and go to state 62


state 30

    (8) parameters -> variable parameters_tail .

    RPAREN          reduce using rule 8 (parameters -> variable parameters_tail .)


state 31

    (9) parameters_tail -> COMMA . variable parameters_tail
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12

    variable                       shift and go to state 63

state 32

    (10) parameters_tail -> empty .

    RPAREN          reduce using rule 10 (parameters_tail -> empty .)


state 33

    (67) variable_declaration -> LET . variable COLON type EQUALS exp
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12

    variable                       shift and go to state 10

state 34

    (22) exp -> variable .
    (59) function_call -> variable . LPAREN arguments RPAREN
    (64) lhs -> variable .

    PLUS            reduce using rule 22 (exp -> variable .)
    MINUS           reduce using rule 22 (exp -> variable .)
    TIMES           reduce using rule 22 (exp -> variable .)
    DIVIDE          reduce using rule 22 (exp -> variable .)
    MOD             reduce using rule 22 (exp -> variable .)
    POWER           reduce using rule 22 (exp -> variable .)
    EQUALS          reduce using rule 22 (exp -> variable .)
    NOT_EQUALS      reduce using rule 22 (exp -> variable .)
    LESS            reduce using rule 22 (exp -> variable .)
    LESS_EQUAL      reduce using rule 22 (exp -> variable .)
    GREATER         reduce using rule 22 (exp -> variable .)
    GREATER_EQUAL   reduce using rule 22 (exp -> variable .)
    AND             reduce using rule 22 (exp -> variable .)
    OR              reduce using rule 22 (exp -> variable .)
    SEMICOLON       reduce using rule 22 (exp -> variable .)
    LET             reduce using rule 22 (exp -> variable .)
    $end            reduce using rule 22 (exp -> variable .)
    RPAREN          reduce using rule 22 (exp -> variable .)
    THEN            reduce using rule 22 (exp -> variable .)
    DO              reduce using rule 22 (exp -> variable .)
    COMMA           reduce using rule 22 (exp -> variable .)
    RBRACKET        reduce using rule 22 (exp -> variable .)
    ELSE            reduce using rule 22 (exp -> variable .)
    BAR             reduce using rule 22 (exp -> variable .)
    LPAREN          shift and go to state 64
    LBRACKET        reduce using rule 64 (lhs -> variable .)


state 35

    (67) variable_declaration -> LET variable COLON type EQUALS exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    LET             reduce using rule 67 (variable_declaration -> LET variable COLON type EQUALS exp .)
    $end            reduce using rule 67 (variable_declaration -> LET variable COLON type EQUALS exp .)
    EQUALS          reduce using rule 67 (variable_declaration -> LET variable COLON type EQUALS exp .)
    NOT_EQUALS      reduce using rule 67 (variable_declaration -> LET variable COLON type EQUALS exp .)
    AND             reduce using rule 67 (variable_declaration -> LET variable COLON type EQUALS exp .)
    OR              reduce using rule 67 (variable_declaration -> LET variable COLON type EQUALS exp .)
    SEMICOLON       reduce using rule 67 (variable_declaration -> LET variable COLON type EQUALS exp .)
    RPAREN          reduce using rule 67 (variable_declaration -> LET variable COLON type EQUALS exp .)
    THEN            reduce using rule 67 (variable_declaration -> LET variable COLON type EQUALS exp .)
    DO              reduce using rule 67 (variable_declaration -> LET variable COLON type EQUALS exp .)
    COMMA           reduce using rule 67 (variable_declaration -> LET variable COLON type EQUALS exp .)
    RBRACKET        reduce using rule 67 (variable_declaration -> LET variable COLON type EQUALS exp .)
    ELSE            reduce using rule 67 (variable_declaration -> LET variable COLON type EQUALS exp .)
    BAR             reduce using rule 67 (variable_declaration -> LET variable COLON type EQUALS exp .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POWER           shift and go to state 71
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76

  ! PLUS            [ reduce using rule 67 (variable_declaration -> LET variable COLON type EQUALS exp .) ]
  ! MINUS           [ reduce using rule 67 (variable_declaration -> LET variable COLON type EQUALS exp .) ]
  ! TIMES           [ reduce using rule 67 (variable_declaration -> LET variable COLON type EQUALS exp .) ]
  ! DIVIDE          [ reduce using rule 67 (variable_declaration -> LET variable COLON type EQUALS exp .) ]
  ! MOD             [ reduce using rule 67 (variable_declaration -> LET variable COLON type EQUALS exp .) ]
  ! POWER           [ reduce using rule 67 (variable_declaration -> LET variable COLON type EQUALS exp .) ]
  ! LESS            [ reduce using rule 67 (variable_declaration -> LET variable COLON type EQUALS exp .) ]
  ! LESS_EQUAL      [ reduce using rule 67 (variable_declaration -> LET variable COLON type EQUALS exp .) ]
  ! GREATER         [ reduce using rule 67 (variable_declaration -> LET variable COLON type EQUALS exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 67 (variable_declaration -> LET variable COLON type EQUALS exp .) ]
  ! EQUALS          [ shift and go to state 65 ]
  ! NOT_EQUALS      [ shift and go to state 72 ]
  ! AND             [ shift and go to state 77 ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 36

    (23) exp -> literal .

    PLUS            reduce using rule 23 (exp -> literal .)
    MINUS           reduce using rule 23 (exp -> literal .)
    TIMES           reduce using rule 23 (exp -> literal .)
    DIVIDE          reduce using rule 23 (exp -> literal .)
    MOD             reduce using rule 23 (exp -> literal .)
    POWER           reduce using rule 23 (exp -> literal .)
    EQUALS          reduce using rule 23 (exp -> literal .)
    NOT_EQUALS      reduce using rule 23 (exp -> literal .)
    LESS            reduce using rule 23 (exp -> literal .)
    LESS_EQUAL      reduce using rule 23 (exp -> literal .)
    GREATER         reduce using rule 23 (exp -> literal .)
    GREATER_EQUAL   reduce using rule 23 (exp -> literal .)
    AND             reduce using rule 23 (exp -> literal .)
    OR              reduce using rule 23 (exp -> literal .)
    SEMICOLON       reduce using rule 23 (exp -> literal .)
    LET             reduce using rule 23 (exp -> literal .)
    $end            reduce using rule 23 (exp -> literal .)
    RPAREN          reduce using rule 23 (exp -> literal .)
    THEN            reduce using rule 23 (exp -> literal .)
    DO              reduce using rule 23 (exp -> literal .)
    COMMA           reduce using rule 23 (exp -> literal .)
    RBRACKET        reduce using rule 23 (exp -> literal .)
    ELSE            reduce using rule 23 (exp -> literal .)
    BAR             reduce using rule 23 (exp -> literal .)


state 37

    (24) exp -> binary_exp .

    PLUS            reduce using rule 24 (exp -> binary_exp .)
    MINUS           reduce using rule 24 (exp -> binary_exp .)
    TIMES           reduce using rule 24 (exp -> binary_exp .)
    DIVIDE          reduce using rule 24 (exp -> binary_exp .)
    MOD             reduce using rule 24 (exp -> binary_exp .)
    POWER           reduce using rule 24 (exp -> binary_exp .)
    EQUALS          reduce using rule 24 (exp -> binary_exp .)
    NOT_EQUALS      reduce using rule 24 (exp -> binary_exp .)
    LESS            reduce using rule 24 (exp -> binary_exp .)
    LESS_EQUAL      reduce using rule 24 (exp -> binary_exp .)
    GREATER         reduce using rule 24 (exp -> binary_exp .)
    GREATER_EQUAL   reduce using rule 24 (exp -> binary_exp .)
    AND             reduce using rule 24 (exp -> binary_exp .)
    OR              reduce using rule 24 (exp -> binary_exp .)
    SEMICOLON       reduce using rule 24 (exp -> binary_exp .)
    LET             reduce using rule 24 (exp -> binary_exp .)
    $end            reduce using rule 24 (exp -> binary_exp .)
    RPAREN          reduce using rule 24 (exp -> binary_exp .)
    THEN            reduce using rule 24 (exp -> binary_exp .)
    DO              reduce using rule 24 (exp -> binary_exp .)
    COMMA           reduce using rule 24 (exp -> binary_exp .)
    RBRACKET        reduce using rule 24 (exp -> binary_exp .)
    ELSE            reduce using rule 24 (exp -> binary_exp .)
    BAR             reduce using rule 24 (exp -> binary_exp .)


state 38

    (25) exp -> unary_exp .

    PLUS            reduce using rule 25 (exp -> unary_exp .)
    MINUS           reduce using rule 25 (exp -> unary_exp .)
    TIMES           reduce using rule 25 (exp -> unary_exp .)
    DIVIDE          reduce using rule 25 (exp -> unary_exp .)
    MOD             reduce using rule 25 (exp -> unary_exp .)
    POWER           reduce using rule 25 (exp -> unary_exp .)
    EQUALS          reduce using rule 25 (exp -> unary_exp .)
    NOT_EQUALS      reduce using rule 25 (exp -> unary_exp .)
    LESS            reduce using rule 25 (exp -> unary_exp .)
    LESS_EQUAL      reduce using rule 25 (exp -> unary_exp .)
    GREATER         reduce using rule 25 (exp -> unary_exp .)
    GREATER_EQUAL   reduce using rule 25 (exp -> unary_exp .)
    AND             reduce using rule 25 (exp -> unary_exp .)
    OR              reduce using rule 25 (exp -> unary_exp .)
    SEMICOLON       reduce using rule 25 (exp -> unary_exp .)
    LET             reduce using rule 25 (exp -> unary_exp .)
    $end            reduce using rule 25 (exp -> unary_exp .)
    RPAREN          reduce using rule 25 (exp -> unary_exp .)
    THEN            reduce using rule 25 (exp -> unary_exp .)
    DO              reduce using rule 25 (exp -> unary_exp .)
    COMMA           reduce using rule 25 (exp -> unary_exp .)
    RBRACKET        reduce using rule 25 (exp -> unary_exp .)
    ELSE            reduce using rule 25 (exp -> unary_exp .)
    BAR             reduce using rule 25 (exp -> unary_exp .)


state 39

    (26) exp -> function_call .

    PLUS            reduce using rule 26 (exp -> function_call .)
    MINUS           reduce using rule 26 (exp -> function_call .)
    TIMES           reduce using rule 26 (exp -> function_call .)
    DIVIDE          reduce using rule 26 (exp -> function_call .)
    MOD             reduce using rule 26 (exp -> function_call .)
    POWER           reduce using rule 26 (exp -> function_call .)
    EQUALS          reduce using rule 26 (exp -> function_call .)
    NOT_EQUALS      reduce using rule 26 (exp -> function_call .)
    LESS            reduce using rule 26 (exp -> function_call .)
    LESS_EQUAL      reduce using rule 26 (exp -> function_call .)
    GREATER         reduce using rule 26 (exp -> function_call .)
    GREATER_EQUAL   reduce using rule 26 (exp -> function_call .)
    AND             reduce using rule 26 (exp -> function_call .)
    OR              reduce using rule 26 (exp -> function_call .)
    SEMICOLON       reduce using rule 26 (exp -> function_call .)
    LET             reduce using rule 26 (exp -> function_call .)
    $end            reduce using rule 26 (exp -> function_call .)
    RPAREN          reduce using rule 26 (exp -> function_call .)
    THEN            reduce using rule 26 (exp -> function_call .)
    DO              reduce using rule 26 (exp -> function_call .)
    COMMA           reduce using rule 26 (exp -> function_call .)
    RBRACKET        reduce using rule 26 (exp -> function_call .)
    ELSE            reduce using rule 26 (exp -> function_call .)
    BAR             reduce using rule 26 (exp -> function_call .)


state 40

    (27) exp -> assignment .

    PLUS            reduce using rule 27 (exp -> assignment .)
    MINUS           reduce using rule 27 (exp -> assignment .)
    TIMES           reduce using rule 27 (exp -> assignment .)
    DIVIDE          reduce using rule 27 (exp -> assignment .)
    MOD             reduce using rule 27 (exp -> assignment .)
    POWER           reduce using rule 27 (exp -> assignment .)
    EQUALS          reduce using rule 27 (exp -> assignment .)
    NOT_EQUALS      reduce using rule 27 (exp -> assignment .)
    LESS            reduce using rule 27 (exp -> assignment .)
    LESS_EQUAL      reduce using rule 27 (exp -> assignment .)
    GREATER         reduce using rule 27 (exp -> assignment .)
    GREATER_EQUAL   reduce using rule 27 (exp -> assignment .)
    AND             reduce using rule 27 (exp -> assignment .)
    OR              reduce using rule 27 (exp -> assignment .)
    SEMICOLON       reduce using rule 27 (exp -> assignment .)
    LET             reduce using rule 27 (exp -> assignment .)
    $end            reduce using rule 27 (exp -> assignment .)
    RPAREN          reduce using rule 27 (exp -> assignment .)
    THEN            reduce using rule 27 (exp -> assignment .)
    DO              reduce using rule 27 (exp -> assignment .)
    COMMA           reduce using rule 27 (exp -> assignment .)
    RBRACKET        reduce using rule 27 (exp -> assignment .)
    ELSE            reduce using rule 27 (exp -> assignment .)
    BAR             reduce using rule 27 (exp -> assignment .)


state 41

    (28) exp -> variable_declaration .

    PLUS            reduce using rule 28 (exp -> variable_declaration .)
    MINUS           reduce using rule 28 (exp -> variable_declaration .)
    TIMES           reduce using rule 28 (exp -> variable_declaration .)
    DIVIDE          reduce using rule 28 (exp -> variable_declaration .)
    MOD             reduce using rule 28 (exp -> variable_declaration .)
    POWER           reduce using rule 28 (exp -> variable_declaration .)
    EQUALS          reduce using rule 28 (exp -> variable_declaration .)
    NOT_EQUALS      reduce using rule 28 (exp -> variable_declaration .)
    LESS            reduce using rule 28 (exp -> variable_declaration .)
    LESS_EQUAL      reduce using rule 28 (exp -> variable_declaration .)
    GREATER         reduce using rule 28 (exp -> variable_declaration .)
    GREATER_EQUAL   reduce using rule 28 (exp -> variable_declaration .)
    AND             reduce using rule 28 (exp -> variable_declaration .)
    OR              reduce using rule 28 (exp -> variable_declaration .)
    SEMICOLON       reduce using rule 28 (exp -> variable_declaration .)
    LET             reduce using rule 28 (exp -> variable_declaration .)
    $end            reduce using rule 28 (exp -> variable_declaration .)
    RPAREN          reduce using rule 28 (exp -> variable_declaration .)
    THEN            reduce using rule 28 (exp -> variable_declaration .)
    DO              reduce using rule 28 (exp -> variable_declaration .)
    COMMA           reduce using rule 28 (exp -> variable_declaration .)
    RBRACKET        reduce using rule 28 (exp -> variable_declaration .)
    ELSE            reduce using rule 28 (exp -> variable_declaration .)
    BAR             reduce using rule 28 (exp -> variable_declaration .)


state 42

    (29) exp -> conditional .

    PLUS            reduce using rule 29 (exp -> conditional .)
    MINUS           reduce using rule 29 (exp -> conditional .)
    TIMES           reduce using rule 29 (exp -> conditional .)
    DIVIDE          reduce using rule 29 (exp -> conditional .)
    MOD             reduce using rule 29 (exp -> conditional .)
    POWER           reduce using rule 29 (exp -> conditional .)
    EQUALS          reduce using rule 29 (exp -> conditional .)
    NOT_EQUALS      reduce using rule 29 (exp -> conditional .)
    LESS            reduce using rule 29 (exp -> conditional .)
    LESS_EQUAL      reduce using rule 29 (exp -> conditional .)
    GREATER         reduce using rule 29 (exp -> conditional .)
    GREATER_EQUAL   reduce using rule 29 (exp -> conditional .)
    AND             reduce using rule 29 (exp -> conditional .)
    OR              reduce using rule 29 (exp -> conditional .)
    SEMICOLON       reduce using rule 29 (exp -> conditional .)
    LET             reduce using rule 29 (exp -> conditional .)
    $end            reduce using rule 29 (exp -> conditional .)
    RPAREN          reduce using rule 29 (exp -> conditional .)
    THEN            reduce using rule 29 (exp -> conditional .)
    DO              reduce using rule 29 (exp -> conditional .)
    COMMA           reduce using rule 29 (exp -> conditional .)
    RBRACKET        reduce using rule 29 (exp -> conditional .)
    ELSE            reduce using rule 29 (exp -> conditional .)
    BAR             reduce using rule 29 (exp -> conditional .)


state 43

    (30) exp -> while_loop .

    PLUS            reduce using rule 30 (exp -> while_loop .)
    MINUS           reduce using rule 30 (exp -> while_loop .)
    TIMES           reduce using rule 30 (exp -> while_loop .)
    DIVIDE          reduce using rule 30 (exp -> while_loop .)
    MOD             reduce using rule 30 (exp -> while_loop .)
    POWER           reduce using rule 30 (exp -> while_loop .)
    EQUALS          reduce using rule 30 (exp -> while_loop .)
    NOT_EQUALS      reduce using rule 30 (exp -> while_loop .)
    LESS            reduce using rule 30 (exp -> while_loop .)
    LESS_EQUAL      reduce using rule 30 (exp -> while_loop .)
    GREATER         reduce using rule 30 (exp -> while_loop .)
    GREATER_EQUAL   reduce using rule 30 (exp -> while_loop .)
    AND             reduce using rule 30 (exp -> while_loop .)
    OR              reduce using rule 30 (exp -> while_loop .)
    SEMICOLON       reduce using rule 30 (exp -> while_loop .)
    LET             reduce using rule 30 (exp -> while_loop .)
    $end            reduce using rule 30 (exp -> while_loop .)
    RPAREN          reduce using rule 30 (exp -> while_loop .)
    THEN            reduce using rule 30 (exp -> while_loop .)
    DO              reduce using rule 30 (exp -> while_loop .)
    COMMA           reduce using rule 30 (exp -> while_loop .)
    RBRACKET        reduce using rule 30 (exp -> while_loop .)
    ELSE            reduce using rule 30 (exp -> while_loop .)
    BAR             reduce using rule 30 (exp -> while_loop .)


state 44

    (31) exp -> array_creation .

    PLUS            reduce using rule 31 (exp -> array_creation .)
    MINUS           reduce using rule 31 (exp -> array_creation .)
    TIMES           reduce using rule 31 (exp -> array_creation .)
    DIVIDE          reduce using rule 31 (exp -> array_creation .)
    MOD             reduce using rule 31 (exp -> array_creation .)
    POWER           reduce using rule 31 (exp -> array_creation .)
    EQUALS          reduce using rule 31 (exp -> array_creation .)
    NOT_EQUALS      reduce using rule 31 (exp -> array_creation .)
    LESS            reduce using rule 31 (exp -> array_creation .)
    LESS_EQUAL      reduce using rule 31 (exp -> array_creation .)
    GREATER         reduce using rule 31 (exp -> array_creation .)
    GREATER_EQUAL   reduce using rule 31 (exp -> array_creation .)
    AND             reduce using rule 31 (exp -> array_creation .)
    OR              reduce using rule 31 (exp -> array_creation .)
    SEMICOLON       reduce using rule 31 (exp -> array_creation .)
    LET             reduce using rule 31 (exp -> array_creation .)
    $end            reduce using rule 31 (exp -> array_creation .)
    RPAREN          reduce using rule 31 (exp -> array_creation .)
    THEN            reduce using rule 31 (exp -> array_creation .)
    DO              reduce using rule 31 (exp -> array_creation .)
    COMMA           reduce using rule 31 (exp -> array_creation .)
    RBRACKET        reduce using rule 31 (exp -> array_creation .)
    ELSE            reduce using rule 31 (exp -> array_creation .)
    BAR             reduce using rule 31 (exp -> array_creation .)


state 45

    (32) exp -> array_access .
    (65) lhs -> array_access .

    PLUS            reduce using rule 32 (exp -> array_access .)
    MINUS           reduce using rule 32 (exp -> array_access .)
    TIMES           reduce using rule 32 (exp -> array_access .)
    DIVIDE          reduce using rule 32 (exp -> array_access .)
    MOD             reduce using rule 32 (exp -> array_access .)
    POWER           reduce using rule 32 (exp -> array_access .)
    EQUALS          reduce using rule 32 (exp -> array_access .)
    NOT_EQUALS      reduce using rule 32 (exp -> array_access .)
    LESS            reduce using rule 32 (exp -> array_access .)
    LESS_EQUAL      reduce using rule 32 (exp -> array_access .)
    GREATER         reduce using rule 32 (exp -> array_access .)
    GREATER_EQUAL   reduce using rule 32 (exp -> array_access .)
    AND             reduce using rule 32 (exp -> array_access .)
    OR              reduce using rule 32 (exp -> array_access .)
    SEMICOLON       reduce using rule 32 (exp -> array_access .)
    LET             reduce using rule 32 (exp -> array_access .)
    $end            reduce using rule 32 (exp -> array_access .)
    RPAREN          reduce using rule 32 (exp -> array_access .)
    THEN            reduce using rule 32 (exp -> array_access .)
    DO              reduce using rule 32 (exp -> array_access .)
    COMMA           reduce using rule 32 (exp -> array_access .)
    RBRACKET        reduce using rule 32 (exp -> array_access .)
    ELSE            reduce using rule 32 (exp -> array_access .)
    BAR             reduce using rule 32 (exp -> array_access .)
    LBRACKET        reduce using rule 65 (lhs -> array_access .)


state 46

    (33) exp -> group .

    PLUS            reduce using rule 33 (exp -> group .)
    MINUS           reduce using rule 33 (exp -> group .)
    TIMES           reduce using rule 33 (exp -> group .)
    DIVIDE          reduce using rule 33 (exp -> group .)
    MOD             reduce using rule 33 (exp -> group .)
    POWER           reduce using rule 33 (exp -> group .)
    EQUALS          reduce using rule 33 (exp -> group .)
    NOT_EQUALS      reduce using rule 33 (exp -> group .)
    LESS            reduce using rule 33 (exp -> group .)
    LESS_EQUAL      reduce using rule 33 (exp -> group .)
    GREATER         reduce using rule 33 (exp -> group .)
    GREATER_EQUAL   reduce using rule 33 (exp -> group .)
    AND             reduce using rule 33 (exp -> group .)
    OR              reduce using rule 33 (exp -> group .)
    SEMICOLON       reduce using rule 33 (exp -> group .)
    LET             reduce using rule 33 (exp -> group .)
    $end            reduce using rule 33 (exp -> group .)
    RPAREN          reduce using rule 33 (exp -> group .)
    THEN            reduce using rule 33 (exp -> group .)
    DO              reduce using rule 33 (exp -> group .)
    COMMA           reduce using rule 33 (exp -> group .)
    RBRACKET        reduce using rule 33 (exp -> group .)
    ELSE            reduce using rule 33 (exp -> group .)
    BAR             reduce using rule 33 (exp -> group .)


state 47

    (36) literal -> INT_LITERAL .

    PLUS            reduce using rule 36 (literal -> INT_LITERAL .)
    MINUS           reduce using rule 36 (literal -> INT_LITERAL .)
    TIMES           reduce using rule 36 (literal -> INT_LITERAL .)
    DIVIDE          reduce using rule 36 (literal -> INT_LITERAL .)
    MOD             reduce using rule 36 (literal -> INT_LITERAL .)
    POWER           reduce using rule 36 (literal -> INT_LITERAL .)
    EQUALS          reduce using rule 36 (literal -> INT_LITERAL .)
    NOT_EQUALS      reduce using rule 36 (literal -> INT_LITERAL .)
    LESS            reduce using rule 36 (literal -> INT_LITERAL .)
    LESS_EQUAL      reduce using rule 36 (literal -> INT_LITERAL .)
    GREATER         reduce using rule 36 (literal -> INT_LITERAL .)
    GREATER_EQUAL   reduce using rule 36 (literal -> INT_LITERAL .)
    AND             reduce using rule 36 (literal -> INT_LITERAL .)
    OR              reduce using rule 36 (literal -> INT_LITERAL .)
    SEMICOLON       reduce using rule 36 (literal -> INT_LITERAL .)
    LET             reduce using rule 36 (literal -> INT_LITERAL .)
    $end            reduce using rule 36 (literal -> INT_LITERAL .)
    RPAREN          reduce using rule 36 (literal -> INT_LITERAL .)
    THEN            reduce using rule 36 (literal -> INT_LITERAL .)
    DO              reduce using rule 36 (literal -> INT_LITERAL .)
    COMMA           reduce using rule 36 (literal -> INT_LITERAL .)
    RBRACKET        reduce using rule 36 (literal -> INT_LITERAL .)
    ELSE            reduce using rule 36 (literal -> INT_LITERAL .)
    BAR             reduce using rule 36 (literal -> INT_LITERAL .)


state 48

    (37) literal -> TRUE .

    PLUS            reduce using rule 37 (literal -> TRUE .)
    MINUS           reduce using rule 37 (literal -> TRUE .)
    TIMES           reduce using rule 37 (literal -> TRUE .)
    DIVIDE          reduce using rule 37 (literal -> TRUE .)
    MOD             reduce using rule 37 (literal -> TRUE .)
    POWER           reduce using rule 37 (literal -> TRUE .)
    EQUALS          reduce using rule 37 (literal -> TRUE .)
    NOT_EQUALS      reduce using rule 37 (literal -> TRUE .)
    LESS            reduce using rule 37 (literal -> TRUE .)
    LESS_EQUAL      reduce using rule 37 (literal -> TRUE .)
    GREATER         reduce using rule 37 (literal -> TRUE .)
    GREATER_EQUAL   reduce using rule 37 (literal -> TRUE .)
    AND             reduce using rule 37 (literal -> TRUE .)
    OR              reduce using rule 37 (literal -> TRUE .)
    SEMICOLON       reduce using rule 37 (literal -> TRUE .)
    LET             reduce using rule 37 (literal -> TRUE .)
    $end            reduce using rule 37 (literal -> TRUE .)
    RPAREN          reduce using rule 37 (literal -> TRUE .)
    THEN            reduce using rule 37 (literal -> TRUE .)
    DO              reduce using rule 37 (literal -> TRUE .)
    COMMA           reduce using rule 37 (literal -> TRUE .)
    RBRACKET        reduce using rule 37 (literal -> TRUE .)
    ELSE            reduce using rule 37 (literal -> TRUE .)
    BAR             reduce using rule 37 (literal -> TRUE .)


state 49

    (38) literal -> FALSE .

    PLUS            reduce using rule 38 (literal -> FALSE .)
    MINUS           reduce using rule 38 (literal -> FALSE .)
    TIMES           reduce using rule 38 (literal -> FALSE .)
    DIVIDE          reduce using rule 38 (literal -> FALSE .)
    MOD             reduce using rule 38 (literal -> FALSE .)
    POWER           reduce using rule 38 (literal -> FALSE .)
    EQUALS          reduce using rule 38 (literal -> FALSE .)
    NOT_EQUALS      reduce using rule 38 (literal -> FALSE .)
    LESS            reduce using rule 38 (literal -> FALSE .)
    LESS_EQUAL      reduce using rule 38 (literal -> FALSE .)
    GREATER         reduce using rule 38 (literal -> FALSE .)
    GREATER_EQUAL   reduce using rule 38 (literal -> FALSE .)
    AND             reduce using rule 38 (literal -> FALSE .)
    OR              reduce using rule 38 (literal -> FALSE .)
    SEMICOLON       reduce using rule 38 (literal -> FALSE .)
    LET             reduce using rule 38 (literal -> FALSE .)
    $end            reduce using rule 38 (literal -> FALSE .)
    RPAREN          reduce using rule 38 (literal -> FALSE .)
    THEN            reduce using rule 38 (literal -> FALSE .)
    DO              reduce using rule 38 (literal -> FALSE .)
    COMMA           reduce using rule 38 (literal -> FALSE .)
    RBRACKET        reduce using rule 38 (literal -> FALSE .)
    ELSE            reduce using rule 38 (literal -> FALSE .)
    BAR             reduce using rule 38 (literal -> FALSE .)


state 50

    (39) literal -> NULL .

    PLUS            reduce using rule 39 (literal -> NULL .)
    MINUS           reduce using rule 39 (literal -> NULL .)
    TIMES           reduce using rule 39 (literal -> NULL .)
    DIVIDE          reduce using rule 39 (literal -> NULL .)
    MOD             reduce using rule 39 (literal -> NULL .)
    POWER           reduce using rule 39 (literal -> NULL .)
    EQUALS          reduce using rule 39 (literal -> NULL .)
    NOT_EQUALS      reduce using rule 39 (literal -> NULL .)
    LESS            reduce using rule 39 (literal -> NULL .)
    LESS_EQUAL      reduce using rule 39 (literal -> NULL .)
    GREATER         reduce using rule 39 (literal -> NULL .)
    GREATER_EQUAL   reduce using rule 39 (literal -> NULL .)
    AND             reduce using rule 39 (literal -> NULL .)
    OR              reduce using rule 39 (literal -> NULL .)
    SEMICOLON       reduce using rule 39 (literal -> NULL .)
    LET             reduce using rule 39 (literal -> NULL .)
    $end            reduce using rule 39 (literal -> NULL .)
    RPAREN          reduce using rule 39 (literal -> NULL .)
    THEN            reduce using rule 39 (literal -> NULL .)
    DO              reduce using rule 39 (literal -> NULL .)
    COMMA           reduce using rule 39 (literal -> NULL .)
    RBRACKET        reduce using rule 39 (literal -> NULL .)
    ELSE            reduce using rule 39 (literal -> NULL .)
    BAR             reduce using rule 39 (literal -> NULL .)


state 51

    (40) literal -> UNIT .

    PLUS            reduce using rule 40 (literal -> UNIT .)
    MINUS           reduce using rule 40 (literal -> UNIT .)
    TIMES           reduce using rule 40 (literal -> UNIT .)
    DIVIDE          reduce using rule 40 (literal -> UNIT .)
    MOD             reduce using rule 40 (literal -> UNIT .)
    POWER           reduce using rule 40 (literal -> UNIT .)
    EQUALS          reduce using rule 40 (literal -> UNIT .)
    NOT_EQUALS      reduce using rule 40 (literal -> UNIT .)
    LESS            reduce using rule 40 (literal -> UNIT .)
    LESS_EQUAL      reduce using rule 40 (literal -> UNIT .)
    GREATER         reduce using rule 40 (literal -> UNIT .)
    GREATER_EQUAL   reduce using rule 40 (literal -> UNIT .)
    AND             reduce using rule 40 (literal -> UNIT .)
    OR              reduce using rule 40 (literal -> UNIT .)
    SEMICOLON       reduce using rule 40 (literal -> UNIT .)
    LET             reduce using rule 40 (literal -> UNIT .)
    $end            reduce using rule 40 (literal -> UNIT .)
    RPAREN          reduce using rule 40 (literal -> UNIT .)
    THEN            reduce using rule 40 (literal -> UNIT .)
    DO              reduce using rule 40 (literal -> UNIT .)
    COMMA           reduce using rule 40 (literal -> UNIT .)
    RBRACKET        reduce using rule 40 (literal -> UNIT .)
    ELSE            reduce using rule 40 (literal -> UNIT .)
    BAR             reduce using rule 40 (literal -> UNIT .)


state 52

    (41) literal -> STRING_LITERAL .

    PLUS            reduce using rule 41 (literal -> STRING_LITERAL .)
    MINUS           reduce using rule 41 (literal -> STRING_LITERAL .)
    TIMES           reduce using rule 41 (literal -> STRING_LITERAL .)
    DIVIDE          reduce using rule 41 (literal -> STRING_LITERAL .)
    MOD             reduce using rule 41 (literal -> STRING_LITERAL .)
    POWER           reduce using rule 41 (literal -> STRING_LITERAL .)
    EQUALS          reduce using rule 41 (literal -> STRING_LITERAL .)
    NOT_EQUALS      reduce using rule 41 (literal -> STRING_LITERAL .)
    LESS            reduce using rule 41 (literal -> STRING_LITERAL .)
    LESS_EQUAL      reduce using rule 41 (literal -> STRING_LITERAL .)
    GREATER         reduce using rule 41 (literal -> STRING_LITERAL .)
    GREATER_EQUAL   reduce using rule 41 (literal -> STRING_LITERAL .)
    AND             reduce using rule 41 (literal -> STRING_LITERAL .)
    OR              reduce using rule 41 (literal -> STRING_LITERAL .)
    SEMICOLON       reduce using rule 41 (literal -> STRING_LITERAL .)
    LET             reduce using rule 41 (literal -> STRING_LITERAL .)
    $end            reduce using rule 41 (literal -> STRING_LITERAL .)
    RPAREN          reduce using rule 41 (literal -> STRING_LITERAL .)
    THEN            reduce using rule 41 (literal -> STRING_LITERAL .)
    DO              reduce using rule 41 (literal -> STRING_LITERAL .)
    COMMA           reduce using rule 41 (literal -> STRING_LITERAL .)
    RBRACKET        reduce using rule 41 (literal -> STRING_LITERAL .)
    ELSE            reduce using rule 41 (literal -> STRING_LITERAL .)
    BAR             reduce using rule 41 (literal -> STRING_LITERAL .)


state 53

    (57) unary_exp -> MINUS . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . conditional
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs EQUALS exp
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (68) conditional -> . IF exp THEN exp conditional_else
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 33
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 80
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    conditional                    shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 54

    (58) unary_exp -> NOT . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . conditional
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs EQUALS exp
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (68) conditional -> . IF exp THEN exp conditional_else
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 33
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 81
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    conditional                    shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 55

    (73) group -> LPAREN . exp RPAREN
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . conditional
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs EQUALS exp
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (68) conditional -> . IF exp THEN exp conditional_else
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 33
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 82
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    conditional                    shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 56

    (63) assignment -> SET . lhs EQUALS exp
    (64) lhs -> . variable
    (65) lhs -> . array_access
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (66) array_access -> . lhs LBRACKET exp RBRACKET

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12

    lhs                            shift and go to state 83
    variable                       shift and go to state 84
    array_access                   shift and go to state 85

state 57

    (66) array_access -> lhs . LBRACKET exp RBRACKET

    LBRACKET        shift and go to state 86


state 58

    (68) conditional -> IF . exp THEN exp conditional_else
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . conditional
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs EQUALS exp
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (68) conditional -> . IF exp THEN exp conditional_else
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 33
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 87
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    conditional                    shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 59

    (71) while_loop -> WHILE . exp DO exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . conditional
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs EQUALS exp
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (68) conditional -> . IF exp THEN exp conditional_else
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 33
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 88
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    conditional                    shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 60

    (72) array_creation -> NEW . type LBRACKET exp BAR exp RBRACKET
    (11) type -> . base_type array_suffix
    (12) base_type -> . INT_TYPE
    (13) base_type -> . BOOL_TYPE
    (14) base_type -> . UNIT_TYPE
    (15) base_type -> . STRING_TYPE

    INT_TYPE        shift and go to state 18
    BOOL_TYPE       shift and go to state 19
    UNIT_TYPE       shift and go to state 20
    STRING_TYPE     shift and go to state 21

    type                           shift and go to state 89
    base_type                      shift and go to state 17

state 61

    (16) array_suffix -> LBRACKET RBRACKET . array_suffix
    (16) array_suffix -> . LBRACKET RBRACKET array_suffix
    (17) array_suffix -> . empty
    (74) empty -> .

  ! shift/reduce conflict for LBRACKET resolved as shift
    LBRACKET        shift and go to state 27
    EQUALS          reduce using rule 74 (empty -> .)
    ARROW           reduce using rule 74 (empty -> .)
    COMMA           reduce using rule 74 (empty -> .)
    RPAREN          reduce using rule 74 (empty -> .)

  ! LBRACKET        [ reduce using rule 74 (empty -> .) ]

    array_suffix                   shift and go to state 90
    empty                          shift and go to state 28

state 62

    (7) function_declaration -> LET ID LPAREN parameters RPAREN COLON . function_type EQUALS exp
    (18) function_type -> . type ARROW type
    (19) function_type -> . LPAREN type function_type_tail RPAREN ARROW type
    (11) type -> . base_type array_suffix
    (12) base_type -> . INT_TYPE
    (13) base_type -> . BOOL_TYPE
    (14) base_type -> . UNIT_TYPE
    (15) base_type -> . STRING_TYPE

    LPAREN          shift and go to state 91
    INT_TYPE        shift and go to state 18
    BOOL_TYPE       shift and go to state 19
    UNIT_TYPE       shift and go to state 20
    STRING_TYPE     shift and go to state 21

    function_type                  shift and go to state 92
    type                           shift and go to state 93
    base_type                      shift and go to state 17

state 63

    (9) parameters_tail -> COMMA variable . parameters_tail
    (9) parameters_tail -> . COMMA variable parameters_tail
    (10) parameters_tail -> . empty
    (74) empty -> .

    COMMA           shift and go to state 31
    RPAREN          reduce using rule 74 (empty -> .)

    parameters_tail                shift and go to state 94
    empty                          shift and go to state 32

state 64

    (59) function_call -> variable LPAREN . arguments RPAREN
    (60) arguments -> . exp arguments_tail
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . conditional
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs EQUALS exp
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (68) conditional -> . IF exp THEN exp conditional_else
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 33
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    variable                       shift and go to state 34
    arguments                      shift and go to state 95
    exp                            shift and go to state 96
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    conditional                    shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 65

    (48) binary_exp -> exp EQUALS . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . conditional
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs EQUALS exp
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (68) conditional -> . IF exp THEN exp conditional_else
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 33
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 97
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    conditional                    shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 66

    (42) binary_exp -> exp PLUS . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . conditional
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs EQUALS exp
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (68) conditional -> . IF exp THEN exp conditional_else
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 33
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 98
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    conditional                    shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 67

    (43) binary_exp -> exp MINUS . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . conditional
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs EQUALS exp
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (68) conditional -> . IF exp THEN exp conditional_else
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 33
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 99
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    conditional                    shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 68

    (44) binary_exp -> exp TIMES . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . conditional
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs EQUALS exp
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (68) conditional -> . IF exp THEN exp conditional_else
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 33
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 100
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    conditional                    shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 69

    (45) binary_exp -> exp DIVIDE . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . conditional
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs EQUALS exp
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (68) conditional -> . IF exp THEN exp conditional_else
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 33
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 101
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    conditional                    shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 70

    (46) binary_exp -> exp MOD . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . conditional
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs EQUALS exp
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (68) conditional -> . IF exp THEN exp conditional_else
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 33
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 102
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    conditional                    shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 71

    (47) binary_exp -> exp POWER . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . conditional
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs EQUALS exp
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (68) conditional -> . IF exp THEN exp conditional_else
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 33
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 103
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    conditional                    shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 72

    (49) binary_exp -> exp NOT_EQUALS . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . conditional
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs EQUALS exp
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (68) conditional -> . IF exp THEN exp conditional_else
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 33
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 104
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    conditional                    shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 73

    (50) binary_exp -> exp LESS . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . conditional
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs EQUALS exp
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (68) conditional -> . IF exp THEN exp conditional_else
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 33
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 105
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    conditional                    shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 74

    (51) binary_exp -> exp LESS_EQUAL . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . conditional
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs EQUALS exp
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (68) conditional -> . IF exp THEN exp conditional_else
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 33
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 106
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    conditional                    shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 75

    (52) binary_exp -> exp GREATER . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . conditional
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs EQUALS exp
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (68) conditional -> . IF exp THEN exp conditional_else
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 33
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 107
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    conditional                    shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 76

    (53) binary_exp -> exp GREATER_EQUAL . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . conditional
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs EQUALS exp
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (68) conditional -> . IF exp THEN exp conditional_else
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 33
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 108
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    conditional                    shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 77

    (54) binary_exp -> exp AND . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . conditional
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs EQUALS exp
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (68) conditional -> . IF exp THEN exp conditional_else
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 33
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 109
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    conditional                    shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 78

    (55) binary_exp -> exp OR . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . conditional
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs EQUALS exp
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (68) conditional -> . IF exp THEN exp conditional_else
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 33
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 110
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    conditional                    shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 79

    (56) binary_exp -> exp SEMICOLON . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . conditional
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs EQUALS exp
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (68) conditional -> . IF exp THEN exp conditional_else
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 33
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 111
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    conditional                    shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 80

    (57) unary_exp -> MINUS exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    PLUS            reduce using rule 57 (unary_exp -> MINUS exp .)
    MINUS           reduce using rule 57 (unary_exp -> MINUS exp .)
    TIMES           reduce using rule 57 (unary_exp -> MINUS exp .)
    DIVIDE          reduce using rule 57 (unary_exp -> MINUS exp .)
    MOD             reduce using rule 57 (unary_exp -> MINUS exp .)
    POWER           reduce using rule 57 (unary_exp -> MINUS exp .)
    EQUALS          reduce using rule 57 (unary_exp -> MINUS exp .)
    NOT_EQUALS      reduce using rule 57 (unary_exp -> MINUS exp .)
    LESS            reduce using rule 57 (unary_exp -> MINUS exp .)
    LESS_EQUAL      reduce using rule 57 (unary_exp -> MINUS exp .)
    GREATER         reduce using rule 57 (unary_exp -> MINUS exp .)
    GREATER_EQUAL   reduce using rule 57 (unary_exp -> MINUS exp .)
    AND             reduce using rule 57 (unary_exp -> MINUS exp .)
    OR              reduce using rule 57 (unary_exp -> MINUS exp .)
    SEMICOLON       reduce using rule 57 (unary_exp -> MINUS exp .)
    LET             reduce using rule 57 (unary_exp -> MINUS exp .)
    $end            reduce using rule 57 (unary_exp -> MINUS exp .)
    RPAREN          reduce using rule 57 (unary_exp -> MINUS exp .)
    THEN            reduce using rule 57 (unary_exp -> MINUS exp .)
    DO              reduce using rule 57 (unary_exp -> MINUS exp .)
    COMMA           reduce using rule 57 (unary_exp -> MINUS exp .)
    RBRACKET        reduce using rule 57 (unary_exp -> MINUS exp .)
    ELSE            reduce using rule 57 (unary_exp -> MINUS exp .)
    BAR             reduce using rule 57 (unary_exp -> MINUS exp .)

  ! PLUS            [ shift and go to state 66 ]
  ! MINUS           [ shift and go to state 67 ]
  ! TIMES           [ shift and go to state 68 ]
  ! DIVIDE          [ shift and go to state 69 ]
  ! MOD             [ shift and go to state 70 ]
  ! POWER           [ shift and go to state 71 ]
  ! EQUALS          [ shift and go to state 65 ]
  ! NOT_EQUALS      [ shift and go to state 72 ]
  ! LESS            [ shift and go to state 73 ]
  ! LESS_EQUAL      [ shift and go to state 74 ]
  ! GREATER         [ shift and go to state 75 ]
  ! GREATER_EQUAL   [ shift and go to state 76 ]
  ! AND             [ shift and go to state 77 ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 81

    (58) unary_exp -> NOT exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    PLUS            reduce using rule 58 (unary_exp -> NOT exp .)
    MINUS           reduce using rule 58 (unary_exp -> NOT exp .)
    TIMES           reduce using rule 58 (unary_exp -> NOT exp .)
    DIVIDE          reduce using rule 58 (unary_exp -> NOT exp .)
    MOD             reduce using rule 58 (unary_exp -> NOT exp .)
    POWER           reduce using rule 58 (unary_exp -> NOT exp .)
    EQUALS          reduce using rule 58 (unary_exp -> NOT exp .)
    NOT_EQUALS      reduce using rule 58 (unary_exp -> NOT exp .)
    LESS            reduce using rule 58 (unary_exp -> NOT exp .)
    LESS_EQUAL      reduce using rule 58 (unary_exp -> NOT exp .)
    GREATER         reduce using rule 58 (unary_exp -> NOT exp .)
    GREATER_EQUAL   reduce using rule 58 (unary_exp -> NOT exp .)
    AND             reduce using rule 58 (unary_exp -> NOT exp .)
    OR              reduce using rule 58 (unary_exp -> NOT exp .)
    SEMICOLON       reduce using rule 58 (unary_exp -> NOT exp .)
    LET             reduce using rule 58 (unary_exp -> NOT exp .)
    $end            reduce using rule 58 (unary_exp -> NOT exp .)
    RPAREN          reduce using rule 58 (unary_exp -> NOT exp .)
    THEN            reduce using rule 58 (unary_exp -> NOT exp .)
    DO              reduce using rule 58 (unary_exp -> NOT exp .)
    COMMA           reduce using rule 58 (unary_exp -> NOT exp .)
    RBRACKET        reduce using rule 58 (unary_exp -> NOT exp .)
    ELSE            reduce using rule 58 (unary_exp -> NOT exp .)
    BAR             reduce using rule 58 (unary_exp -> NOT exp .)

  ! PLUS            [ shift and go to state 66 ]
  ! MINUS           [ shift and go to state 67 ]
  ! TIMES           [ shift and go to state 68 ]
  ! DIVIDE          [ shift and go to state 69 ]
  ! MOD             [ shift and go to state 70 ]
  ! POWER           [ shift and go to state 71 ]
  ! EQUALS          [ shift and go to state 65 ]
  ! NOT_EQUALS      [ shift and go to state 72 ]
  ! LESS            [ shift and go to state 73 ]
  ! LESS_EQUAL      [ shift and go to state 74 ]
  ! GREATER         [ shift and go to state 75 ]
  ! GREATER_EQUAL   [ shift and go to state 76 ]
  ! AND             [ shift and go to state 77 ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 82

    (73) group -> LPAREN exp . RPAREN
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    RPAREN          shift and go to state 112
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POWER           shift and go to state 71
    EQUALS          shift and go to state 65
    NOT_EQUALS      shift and go to state 72
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    SEMICOLON       shift and go to state 79


state 83

    (63) assignment -> SET lhs . EQUALS exp
    (66) array_access -> lhs . LBRACKET exp RBRACKET

    EQUALS          shift and go to state 113
    LBRACKET        shift and go to state 86


state 84

    (64) lhs -> variable .

    EQUALS          reduce using rule 64 (lhs -> variable .)
    LBRACKET        reduce using rule 64 (lhs -> variable .)


state 85

    (65) lhs -> array_access .

    EQUALS          reduce using rule 65 (lhs -> array_access .)
    LBRACKET        reduce using rule 65 (lhs -> array_access .)


state 86

    (66) array_access -> lhs LBRACKET . exp RBRACKET
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . conditional
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs EQUALS exp
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (68) conditional -> . IF exp THEN exp conditional_else
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 33
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    lhs                            shift and go to state 57
    exp                            shift and go to state 114
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    conditional                    shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46

state 87

    (68) conditional -> IF exp . THEN exp conditional_else
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    THEN            shift and go to state 115
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POWER           shift and go to state 71
    EQUALS          shift and go to state 65
    NOT_EQUALS      shift and go to state 72
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    SEMICOLON       shift and go to state 79


state 88

    (71) while_loop -> WHILE exp . DO exp
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    DO              shift and go to state 116
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POWER           shift and go to state 71
    EQUALS          shift and go to state 65
    NOT_EQUALS      shift and go to state 72
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    SEMICOLON       shift and go to state 79


state 89

    (72) array_creation -> NEW type . LBRACKET exp BAR exp RBRACKET

    LBRACKET        shift and go to state 117


state 90

    (16) array_suffix -> LBRACKET RBRACKET array_suffix .

    EQUALS          reduce using rule 16 (array_suffix -> LBRACKET RBRACKET array_suffix .)
    LBRACKET        reduce using rule 16 (array_suffix -> LBRACKET RBRACKET array_suffix .)
    ARROW           reduce using rule 16 (array_suffix -> LBRACKET RBRACKET array_suffix .)
    COMMA           reduce using rule 16 (array_suffix -> LBRACKET RBRACKET array_suffix .)
    RPAREN          reduce using rule 16 (array_suffix -> LBRACKET RBRACKET array_suffix .)


state 91

    (19) function_type -> LPAREN . type function_type_tail RPAREN ARROW type
    (11) type -> . base_type array_suffix
    (12) base_type -> . INT_TYPE
    (13) base_type -> . BOOL_TYPE
    (14) base_type -> . UNIT_TYPE
    (15) base_type -> . STRING_TYPE

    INT_TYPE        shift and go to state 18
    BOOL_TYPE       shift and go to state 19
    UNIT_TYPE       shift and go to state 20
    STRING_TYPE     shift and go to state 21

    type                           shift and go to state 118
    base_type                      shift and go to state 17

state 92

    (7) function_declaration -> LET ID LPAREN parameters RPAREN COLON function_type . EQUALS exp

    EQUALS          shift and go to state 119


state 93

    (18) function_type -> type . ARROW type

    ARROW           shift and go to state 120


state 94

    (9) parameters_tail -> COMMA variable parameters_tail .

    RPAREN          reduce using rule 9 (parameters_tail -> COMMA variable parameters_tail .)


state 95

    (59) function_call -> variable LPAREN arguments . RPAREN

    RPAREN          shift and go to state 121


state 96

    (60) arguments -> exp . arguments_tail
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp
    (61) arguments_tail -> . COMMA exp arguments_tail
    (62) arguments_tail -> . empty
    (74) empty -> .

    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POWER           shift and go to state 71
    EQUALS          shift and go to state 65
    NOT_EQUALS      shift and go to state 72
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    SEMICOLON       shift and go to state 79
    COMMA           shift and go to state 123
    RPAREN          reduce using rule 74 (empty -> .)

    arguments_tail                 shift and go to state 122
    empty                          shift and go to state 124

state 97

    (48) binary_exp -> exp EQUALS exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    EQUALS          reduce using rule 48 (binary_exp -> exp EQUALS exp .)
    NOT_EQUALS      reduce using rule 48 (binary_exp -> exp EQUALS exp .)
    AND             reduce using rule 48 (binary_exp -> exp EQUALS exp .)
    OR              reduce using rule 48 (binary_exp -> exp EQUALS exp .)
    SEMICOLON       reduce using rule 48 (binary_exp -> exp EQUALS exp .)
    LET             reduce using rule 48 (binary_exp -> exp EQUALS exp .)
    $end            reduce using rule 48 (binary_exp -> exp EQUALS exp .)
    RPAREN          reduce using rule 48 (binary_exp -> exp EQUALS exp .)
    THEN            reduce using rule 48 (binary_exp -> exp EQUALS exp .)
    DO              reduce using rule 48 (binary_exp -> exp EQUALS exp .)
    COMMA           reduce using rule 48 (binary_exp -> exp EQUALS exp .)
    RBRACKET        reduce using rule 48 (binary_exp -> exp EQUALS exp .)
    ELSE            reduce using rule 48 (binary_exp -> exp EQUALS exp .)
    BAR             reduce using rule 48 (binary_exp -> exp EQUALS exp .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POWER           shift and go to state 71
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76

  ! PLUS            [ reduce using rule 48 (binary_exp -> exp EQUALS exp .) ]
  ! MINUS           [ reduce using rule 48 (binary_exp -> exp EQUALS exp .) ]
  ! TIMES           [ reduce using rule 48 (binary_exp -> exp EQUALS exp .) ]
  ! DIVIDE          [ reduce using rule 48 (binary_exp -> exp EQUALS exp .) ]
  ! MOD             [ reduce using rule 48 (binary_exp -> exp EQUALS exp .) ]
  ! POWER           [ reduce using rule 48 (binary_exp -> exp EQUALS exp .) ]
  ! LESS            [ reduce using rule 48 (binary_exp -> exp EQUALS exp .) ]
  ! LESS_EQUAL      [ reduce using rule 48 (binary_exp -> exp EQUALS exp .) ]
  ! GREATER         [ reduce using rule 48 (binary_exp -> exp EQUALS exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 48 (binary_exp -> exp EQUALS exp .) ]
  ! EQUALS          [ shift and go to state 65 ]
  ! NOT_EQUALS      [ shift and go to state 72 ]
  ! AND             [ shift and go to state 77 ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 98

    (42) binary_exp -> exp PLUS exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    PLUS            reduce using rule 42 (binary_exp -> exp PLUS exp .)
    MINUS           reduce using rule 42 (binary_exp -> exp PLUS exp .)
    EQUALS          reduce using rule 42 (binary_exp -> exp PLUS exp .)
    NOT_EQUALS      reduce using rule 42 (binary_exp -> exp PLUS exp .)
    LESS            reduce using rule 42 (binary_exp -> exp PLUS exp .)
    LESS_EQUAL      reduce using rule 42 (binary_exp -> exp PLUS exp .)
    GREATER         reduce using rule 42 (binary_exp -> exp PLUS exp .)
    GREATER_EQUAL   reduce using rule 42 (binary_exp -> exp PLUS exp .)
    AND             reduce using rule 42 (binary_exp -> exp PLUS exp .)
    OR              reduce using rule 42 (binary_exp -> exp PLUS exp .)
    SEMICOLON       reduce using rule 42 (binary_exp -> exp PLUS exp .)
    LET             reduce using rule 42 (binary_exp -> exp PLUS exp .)
    $end            reduce using rule 42 (binary_exp -> exp PLUS exp .)
    RPAREN          reduce using rule 42 (binary_exp -> exp PLUS exp .)
    THEN            reduce using rule 42 (binary_exp -> exp PLUS exp .)
    DO              reduce using rule 42 (binary_exp -> exp PLUS exp .)
    COMMA           reduce using rule 42 (binary_exp -> exp PLUS exp .)
    RBRACKET        reduce using rule 42 (binary_exp -> exp PLUS exp .)
    ELSE            reduce using rule 42 (binary_exp -> exp PLUS exp .)
    BAR             reduce using rule 42 (binary_exp -> exp PLUS exp .)
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POWER           shift and go to state 71

  ! TIMES           [ reduce using rule 42 (binary_exp -> exp PLUS exp .) ]
  ! DIVIDE          [ reduce using rule 42 (binary_exp -> exp PLUS exp .) ]
  ! MOD             [ reduce using rule 42 (binary_exp -> exp PLUS exp .) ]
  ! POWER           [ reduce using rule 42 (binary_exp -> exp PLUS exp .) ]
  ! PLUS            [ shift and go to state 66 ]
  ! MINUS           [ shift and go to state 67 ]
  ! EQUALS          [ shift and go to state 65 ]
  ! NOT_EQUALS      [ shift and go to state 72 ]
  ! LESS            [ shift and go to state 73 ]
  ! LESS_EQUAL      [ shift and go to state 74 ]
  ! GREATER         [ shift and go to state 75 ]
  ! GREATER_EQUAL   [ shift and go to state 76 ]
  ! AND             [ shift and go to state 77 ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 99

    (43) binary_exp -> exp MINUS exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    PLUS            reduce using rule 43 (binary_exp -> exp MINUS exp .)
    MINUS           reduce using rule 43 (binary_exp -> exp MINUS exp .)
    EQUALS          reduce using rule 43 (binary_exp -> exp MINUS exp .)
    NOT_EQUALS      reduce using rule 43 (binary_exp -> exp MINUS exp .)
    LESS            reduce using rule 43 (binary_exp -> exp MINUS exp .)
    LESS_EQUAL      reduce using rule 43 (binary_exp -> exp MINUS exp .)
    GREATER         reduce using rule 43 (binary_exp -> exp MINUS exp .)
    GREATER_EQUAL   reduce using rule 43 (binary_exp -> exp MINUS exp .)
    AND             reduce using rule 43 (binary_exp -> exp MINUS exp .)
    OR              reduce using rule 43 (binary_exp -> exp MINUS exp .)
    SEMICOLON       reduce using rule 43 (binary_exp -> exp MINUS exp .)
    LET             reduce using rule 43 (binary_exp -> exp MINUS exp .)
    $end            reduce using rule 43 (binary_exp -> exp MINUS exp .)
    RPAREN          reduce using rule 43 (binary_exp -> exp MINUS exp .)
    THEN            reduce using rule 43 (binary_exp -> exp MINUS exp .)
    DO              reduce using rule 43 (binary_exp -> exp MINUS exp .)
    COMMA           reduce using rule 43 (binary_exp -> exp MINUS exp .)
    RBRACKET        reduce using rule 43 (binary_exp -> exp MINUS exp .)
    ELSE            reduce using rule 43 (binary_exp -> exp MINUS exp .)
    BAR             reduce using rule 43 (binary_exp -> exp MINUS exp .)
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POWER           shift and go to state 71

  ! TIMES           [ reduce using rule 43 (binary_exp -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 43 (binary_exp -> exp MINUS exp .) ]
  ! MOD             [ reduce using rule 43 (binary_exp -> exp MINUS exp .) ]
  ! POWER           [ reduce using rule 43 (binary_exp -> exp MINUS exp .) ]
  ! PLUS            [ shift and go to state 66 ]
  ! MINUS           [ shift and go to state 67 ]
  ! EQUALS          [ shift and go to state 65 ]
  ! NOT_EQUALS      [ shift and go to state 72 ]
  ! LESS            [ shift and go to state 73 ]
  ! LESS_EQUAL      [ shift and go to state 74 ]
  ! GREATER         [ shift and go to state 75 ]
  ! GREATER_EQUAL   [ shift and go to state 76 ]
  ! AND             [ shift and go to state 77 ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 100

    (44) binary_exp -> exp TIMES exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    PLUS            reduce using rule 44 (binary_exp -> exp TIMES exp .)
    MINUS           reduce using rule 44 (binary_exp -> exp TIMES exp .)
    TIMES           reduce using rule 44 (binary_exp -> exp TIMES exp .)
    DIVIDE          reduce using rule 44 (binary_exp -> exp TIMES exp .)
    MOD             reduce using rule 44 (binary_exp -> exp TIMES exp .)
    EQUALS          reduce using rule 44 (binary_exp -> exp TIMES exp .)
    NOT_EQUALS      reduce using rule 44 (binary_exp -> exp TIMES exp .)
    LESS            reduce using rule 44 (binary_exp -> exp TIMES exp .)
    LESS_EQUAL      reduce using rule 44 (binary_exp -> exp TIMES exp .)
    GREATER         reduce using rule 44 (binary_exp -> exp TIMES exp .)
    GREATER_EQUAL   reduce using rule 44 (binary_exp -> exp TIMES exp .)
    AND             reduce using rule 44 (binary_exp -> exp TIMES exp .)
    OR              reduce using rule 44 (binary_exp -> exp TIMES exp .)
    SEMICOLON       reduce using rule 44 (binary_exp -> exp TIMES exp .)
    LET             reduce using rule 44 (binary_exp -> exp TIMES exp .)
    $end            reduce using rule 44 (binary_exp -> exp TIMES exp .)
    RPAREN          reduce using rule 44 (binary_exp -> exp TIMES exp .)
    THEN            reduce using rule 44 (binary_exp -> exp TIMES exp .)
    DO              reduce using rule 44 (binary_exp -> exp TIMES exp .)
    COMMA           reduce using rule 44 (binary_exp -> exp TIMES exp .)
    RBRACKET        reduce using rule 44 (binary_exp -> exp TIMES exp .)
    ELSE            reduce using rule 44 (binary_exp -> exp TIMES exp .)
    BAR             reduce using rule 44 (binary_exp -> exp TIMES exp .)
    POWER           shift and go to state 71

  ! POWER           [ reduce using rule 44 (binary_exp -> exp TIMES exp .) ]
  ! PLUS            [ shift and go to state 66 ]
  ! MINUS           [ shift and go to state 67 ]
  ! TIMES           [ shift and go to state 68 ]
  ! DIVIDE          [ shift and go to state 69 ]
  ! MOD             [ shift and go to state 70 ]
  ! EQUALS          [ shift and go to state 65 ]
  ! NOT_EQUALS      [ shift and go to state 72 ]
  ! LESS            [ shift and go to state 73 ]
  ! LESS_EQUAL      [ shift and go to state 74 ]
  ! GREATER         [ shift and go to state 75 ]
  ! GREATER_EQUAL   [ shift and go to state 76 ]
  ! AND             [ shift and go to state 77 ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 101

    (45) binary_exp -> exp DIVIDE exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    PLUS            reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    MINUS           reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    TIMES           reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    DIVIDE          reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    MOD             reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    EQUALS          reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    NOT_EQUALS      reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    LESS            reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    LESS_EQUAL      reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    GREATER         reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    GREATER_EQUAL   reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    AND             reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    OR              reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    SEMICOLON       reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    LET             reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    $end            reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    RPAREN          reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    THEN            reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    DO              reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    COMMA           reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    RBRACKET        reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    ELSE            reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    BAR             reduce using rule 45 (binary_exp -> exp DIVIDE exp .)
    POWER           shift and go to state 71

  ! POWER           [ reduce using rule 45 (binary_exp -> exp DIVIDE exp .) ]
  ! PLUS            [ shift and go to state 66 ]
  ! MINUS           [ shift and go to state 67 ]
  ! TIMES           [ shift and go to state 68 ]
  ! DIVIDE          [ shift and go to state 69 ]
  ! MOD             [ shift and go to state 70 ]
  ! EQUALS          [ shift and go to state 65 ]
  ! NOT_EQUALS      [ shift and go to state 72 ]
  ! LESS            [ shift and go to state 73 ]
  ! LESS_EQUAL      [ shift and go to state 74 ]
  ! GREATER         [ shift and go to state 75 ]
  ! GREATER_EQUAL   [ shift and go to state 76 ]
  ! AND             [ shift and go to state 77 ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 102

    (46) binary_exp -> exp MOD exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    PLUS            reduce using rule 46 (binary_exp -> exp MOD exp .)
    MINUS           reduce using rule 46 (binary_exp -> exp MOD exp .)
    TIMES           reduce using rule 46 (binary_exp -> exp MOD exp .)
    DIVIDE          reduce using rule 46 (binary_exp -> exp MOD exp .)
    MOD             reduce using rule 46 (binary_exp -> exp MOD exp .)
    EQUALS          reduce using rule 46 (binary_exp -> exp MOD exp .)
    NOT_EQUALS      reduce using rule 46 (binary_exp -> exp MOD exp .)
    LESS            reduce using rule 46 (binary_exp -> exp MOD exp .)
    LESS_EQUAL      reduce using rule 46 (binary_exp -> exp MOD exp .)
    GREATER         reduce using rule 46 (binary_exp -> exp MOD exp .)
    GREATER_EQUAL   reduce using rule 46 (binary_exp -> exp MOD exp .)
    AND             reduce using rule 46 (binary_exp -> exp MOD exp .)
    OR              reduce using rule 46 (binary_exp -> exp MOD exp .)
    SEMICOLON       reduce using rule 46 (binary_exp -> exp MOD exp .)
    LET             reduce using rule 46 (binary_exp -> exp MOD exp .)
    $end            reduce using rule 46 (binary_exp -> exp MOD exp .)
    RPAREN          reduce using rule 46 (binary_exp -> exp MOD exp .)
    THEN            reduce using rule 46 (binary_exp -> exp MOD exp .)
    DO              reduce using rule 46 (binary_exp -> exp MOD exp .)
    COMMA           reduce using rule 46 (binary_exp -> exp MOD exp .)
    RBRACKET        reduce using rule 46 (binary_exp -> exp MOD exp .)
    ELSE            reduce using rule 46 (binary_exp -> exp MOD exp .)
    BAR             reduce using rule 46 (binary_exp -> exp MOD exp .)
    POWER           shift and go to state 71

  ! POWER           [ reduce using rule 46 (binary_exp -> exp MOD exp .) ]
  ! PLUS            [ shift and go to state 66 ]
  ! MINUS           [ shift and go to state 67 ]
  ! TIMES           [ shift and go to state 68 ]
  ! DIVIDE          [ shift and go to state 69 ]
  ! MOD             [ shift and go to state 70 ]
  ! EQUALS          [ shift and go to state 65 ]
  ! NOT_EQUALS      [ shift and go to state 72 ]
  ! LESS            [ shift and go to state 73 ]
  ! LESS_EQUAL      [ shift and go to state 74 ]
  ! GREATER         [ shift and go to state 75 ]
  ! GREATER_EQUAL   [ shift and go to state 76 ]
  ! AND             [ shift and go to state 77 ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 103

    (47) binary_exp -> exp POWER exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    PLUS            reduce using rule 47 (binary_exp -> exp POWER exp .)
    MINUS           reduce using rule 47 (binary_exp -> exp POWER exp .)
    TIMES           reduce using rule 47 (binary_exp -> exp POWER exp .)
    DIVIDE          reduce using rule 47 (binary_exp -> exp POWER exp .)
    MOD             reduce using rule 47 (binary_exp -> exp POWER exp .)
    EQUALS          reduce using rule 47 (binary_exp -> exp POWER exp .)
    NOT_EQUALS      reduce using rule 47 (binary_exp -> exp POWER exp .)
    LESS            reduce using rule 47 (binary_exp -> exp POWER exp .)
    LESS_EQUAL      reduce using rule 47 (binary_exp -> exp POWER exp .)
    GREATER         reduce using rule 47 (binary_exp -> exp POWER exp .)
    GREATER_EQUAL   reduce using rule 47 (binary_exp -> exp POWER exp .)
    AND             reduce using rule 47 (binary_exp -> exp POWER exp .)
    OR              reduce using rule 47 (binary_exp -> exp POWER exp .)
    SEMICOLON       reduce using rule 47 (binary_exp -> exp POWER exp .)
    LET             reduce using rule 47 (binary_exp -> exp POWER exp .)
    $end            reduce using rule 47 (binary_exp -> exp POWER exp .)
    RPAREN          reduce using rule 47 (binary_exp -> exp POWER exp .)
    THEN            reduce using rule 47 (binary_exp -> exp POWER exp .)
    DO              reduce using rule 47 (binary_exp -> exp POWER exp .)
    COMMA           reduce using rule 47 (binary_exp -> exp POWER exp .)
    RBRACKET        reduce using rule 47 (binary_exp -> exp POWER exp .)
    ELSE            reduce using rule 47 (binary_exp -> exp POWER exp .)
    BAR             reduce using rule 47 (binary_exp -> exp POWER exp .)
    POWER           shift and go to state 71

  ! POWER           [ reduce using rule 47 (binary_exp -> exp POWER exp .) ]
  ! PLUS            [ shift and go to state 66 ]
  ! MINUS           [ shift and go to state 67 ]
  ! TIMES           [ shift and go to state 68 ]
  ! DIVIDE          [ shift and go to state 69 ]
  ! MOD             [ shift and go to state 70 ]
  ! EQUALS          [ shift and go to state 65 ]
  ! NOT_EQUALS      [ shift and go to state 72 ]
  ! LESS            [ shift and go to state 73 ]
  ! LESS_EQUAL      [ shift and go to state 74 ]
  ! GREATER         [ shift and go to state 75 ]
  ! GREATER_EQUAL   [ shift and go to state 76 ]
  ! AND             [ shift and go to state 77 ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 104

    (49) binary_exp -> exp NOT_EQUALS exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    EQUALS          reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .)
    NOT_EQUALS      reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .)
    AND             reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .)
    OR              reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .)
    SEMICOLON       reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .)
    LET             reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .)
    $end            reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .)
    RPAREN          reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .)
    THEN            reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .)
    DO              reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .)
    COMMA           reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .)
    RBRACKET        reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .)
    ELSE            reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .)
    BAR             reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POWER           shift and go to state 71
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76

  ! PLUS            [ reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! MINUS           [ reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! TIMES           [ reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! DIVIDE          [ reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! MOD             [ reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! POWER           [ reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! LESS            [ reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! LESS_EQUAL      [ reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! GREATER         [ reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 49 (binary_exp -> exp NOT_EQUALS exp .) ]
  ! EQUALS          [ shift and go to state 65 ]
  ! NOT_EQUALS      [ shift and go to state 72 ]
  ! AND             [ shift and go to state 77 ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 105

    (50) binary_exp -> exp LESS exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    EQUALS          reduce using rule 50 (binary_exp -> exp LESS exp .)
    NOT_EQUALS      reduce using rule 50 (binary_exp -> exp LESS exp .)
    LESS            reduce using rule 50 (binary_exp -> exp LESS exp .)
    LESS_EQUAL      reduce using rule 50 (binary_exp -> exp LESS exp .)
    GREATER         reduce using rule 50 (binary_exp -> exp LESS exp .)
    GREATER_EQUAL   reduce using rule 50 (binary_exp -> exp LESS exp .)
    AND             reduce using rule 50 (binary_exp -> exp LESS exp .)
    OR              reduce using rule 50 (binary_exp -> exp LESS exp .)
    SEMICOLON       reduce using rule 50 (binary_exp -> exp LESS exp .)
    LET             reduce using rule 50 (binary_exp -> exp LESS exp .)
    $end            reduce using rule 50 (binary_exp -> exp LESS exp .)
    RPAREN          reduce using rule 50 (binary_exp -> exp LESS exp .)
    THEN            reduce using rule 50 (binary_exp -> exp LESS exp .)
    DO              reduce using rule 50 (binary_exp -> exp LESS exp .)
    COMMA           reduce using rule 50 (binary_exp -> exp LESS exp .)
    RBRACKET        reduce using rule 50 (binary_exp -> exp LESS exp .)
    ELSE            reduce using rule 50 (binary_exp -> exp LESS exp .)
    BAR             reduce using rule 50 (binary_exp -> exp LESS exp .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POWER           shift and go to state 71

  ! PLUS            [ reduce using rule 50 (binary_exp -> exp LESS exp .) ]
  ! MINUS           [ reduce using rule 50 (binary_exp -> exp LESS exp .) ]
  ! TIMES           [ reduce using rule 50 (binary_exp -> exp LESS exp .) ]
  ! DIVIDE          [ reduce using rule 50 (binary_exp -> exp LESS exp .) ]
  ! MOD             [ reduce using rule 50 (binary_exp -> exp LESS exp .) ]
  ! POWER           [ reduce using rule 50 (binary_exp -> exp LESS exp .) ]
  ! EQUALS          [ shift and go to state 65 ]
  ! NOT_EQUALS      [ shift and go to state 72 ]
  ! LESS            [ shift and go to state 73 ]
  ! LESS_EQUAL      [ shift and go to state 74 ]
  ! GREATER         [ shift and go to state 75 ]
  ! GREATER_EQUAL   [ shift and go to state 76 ]
  ! AND             [ shift and go to state 77 ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 106

    (51) binary_exp -> exp LESS_EQUAL exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    EQUALS          reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    NOT_EQUALS      reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    LESS            reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    LESS_EQUAL      reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    GREATER         reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    GREATER_EQUAL   reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    AND             reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    OR              reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    SEMICOLON       reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    LET             reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    $end            reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    RPAREN          reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    THEN            reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    DO              reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    COMMA           reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    RBRACKET        reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    ELSE            reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    BAR             reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POWER           shift and go to state 71

  ! PLUS            [ reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .) ]
  ! MINUS           [ reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .) ]
  ! TIMES           [ reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .) ]
  ! DIVIDE          [ reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .) ]
  ! MOD             [ reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .) ]
  ! POWER           [ reduce using rule 51 (binary_exp -> exp LESS_EQUAL exp .) ]
  ! EQUALS          [ shift and go to state 65 ]
  ! NOT_EQUALS      [ shift and go to state 72 ]
  ! LESS            [ shift and go to state 73 ]
  ! LESS_EQUAL      [ shift and go to state 74 ]
  ! GREATER         [ shift and go to state 75 ]
  ! GREATER_EQUAL   [ shift and go to state 76 ]
  ! AND             [ shift and go to state 77 ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 107

    (52) binary_exp -> exp GREATER exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    EQUALS          reduce using rule 52 (binary_exp -> exp GREATER exp .)
    NOT_EQUALS      reduce using rule 52 (binary_exp -> exp GREATER exp .)
    LESS            reduce using rule 52 (binary_exp -> exp GREATER exp .)
    LESS_EQUAL      reduce using rule 52 (binary_exp -> exp GREATER exp .)
    GREATER         reduce using rule 52 (binary_exp -> exp GREATER exp .)
    GREATER_EQUAL   reduce using rule 52 (binary_exp -> exp GREATER exp .)
    AND             reduce using rule 52 (binary_exp -> exp GREATER exp .)
    OR              reduce using rule 52 (binary_exp -> exp GREATER exp .)
    SEMICOLON       reduce using rule 52 (binary_exp -> exp GREATER exp .)
    LET             reduce using rule 52 (binary_exp -> exp GREATER exp .)
    $end            reduce using rule 52 (binary_exp -> exp GREATER exp .)
    RPAREN          reduce using rule 52 (binary_exp -> exp GREATER exp .)
    THEN            reduce using rule 52 (binary_exp -> exp GREATER exp .)
    DO              reduce using rule 52 (binary_exp -> exp GREATER exp .)
    COMMA           reduce using rule 52 (binary_exp -> exp GREATER exp .)
    RBRACKET        reduce using rule 52 (binary_exp -> exp GREATER exp .)
    ELSE            reduce using rule 52 (binary_exp -> exp GREATER exp .)
    BAR             reduce using rule 52 (binary_exp -> exp GREATER exp .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POWER           shift and go to state 71

  ! PLUS            [ reduce using rule 52 (binary_exp -> exp GREATER exp .) ]
  ! MINUS           [ reduce using rule 52 (binary_exp -> exp GREATER exp .) ]
  ! TIMES           [ reduce using rule 52 (binary_exp -> exp GREATER exp .) ]
  ! DIVIDE          [ reduce using rule 52 (binary_exp -> exp GREATER exp .) ]
  ! MOD             [ reduce using rule 52 (binary_exp -> exp GREATER exp .) ]
  ! POWER           [ reduce using rule 52 (binary_exp -> exp GREATER exp .) ]
  ! EQUALS          [ shift and go to state 65 ]
  ! NOT_EQUALS      [ shift and go to state 72 ]
  ! LESS            [ shift and go to state 73 ]
  ! LESS_EQUAL      [ shift and go to state 74 ]
  ! GREATER         [ shift and go to state 75 ]
  ! GREATER_EQUAL   [ shift and go to state 76 ]
  ! AND             [ shift and go to state 77 ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 108

    (53) binary_exp -> exp GREATER_EQUAL exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    EQUALS          reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    NOT_EQUALS      reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    LESS            reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    LESS_EQUAL      reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    GREATER         reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    GREATER_EQUAL   reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    AND             reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    OR              reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    SEMICOLON       reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    LET             reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    $end            reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    RPAREN          reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    THEN            reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    DO              reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    COMMA           reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    RBRACKET        reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    ELSE            reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    BAR             reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POWER           shift and go to state 71

  ! PLUS            [ reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .) ]
  ! MINUS           [ reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .) ]
  ! TIMES           [ reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .) ]
  ! DIVIDE          [ reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .) ]
  ! MOD             [ reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .) ]
  ! POWER           [ reduce using rule 53 (binary_exp -> exp GREATER_EQUAL exp .) ]
  ! EQUALS          [ shift and go to state 65 ]
  ! NOT_EQUALS      [ shift and go to state 72 ]
  ! LESS            [ shift and go to state 73 ]
  ! LESS_EQUAL      [ shift and go to state 74 ]
  ! GREATER         [ shift and go to state 75 ]
  ! GREATER_EQUAL   [ shift and go to state 76 ]
  ! AND             [ shift and go to state 77 ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 109

    (54) binary_exp -> exp AND exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    AND             reduce using rule 54 (binary_exp -> exp AND exp .)
    OR              reduce using rule 54 (binary_exp -> exp AND exp .)
    SEMICOLON       reduce using rule 54 (binary_exp -> exp AND exp .)
    LET             reduce using rule 54 (binary_exp -> exp AND exp .)
    $end            reduce using rule 54 (binary_exp -> exp AND exp .)
    RPAREN          reduce using rule 54 (binary_exp -> exp AND exp .)
    THEN            reduce using rule 54 (binary_exp -> exp AND exp .)
    DO              reduce using rule 54 (binary_exp -> exp AND exp .)
    COMMA           reduce using rule 54 (binary_exp -> exp AND exp .)
    RBRACKET        reduce using rule 54 (binary_exp -> exp AND exp .)
    ELSE            reduce using rule 54 (binary_exp -> exp AND exp .)
    BAR             reduce using rule 54 (binary_exp -> exp AND exp .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POWER           shift and go to state 71
    EQUALS          shift and go to state 65
    NOT_EQUALS      shift and go to state 72
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76

  ! PLUS            [ reduce using rule 54 (binary_exp -> exp AND exp .) ]
  ! MINUS           [ reduce using rule 54 (binary_exp -> exp AND exp .) ]
  ! TIMES           [ reduce using rule 54 (binary_exp -> exp AND exp .) ]
  ! DIVIDE          [ reduce using rule 54 (binary_exp -> exp AND exp .) ]
  ! MOD             [ reduce using rule 54 (binary_exp -> exp AND exp .) ]
  ! POWER           [ reduce using rule 54 (binary_exp -> exp AND exp .) ]
  ! EQUALS          [ reduce using rule 54 (binary_exp -> exp AND exp .) ]
  ! NOT_EQUALS      [ reduce using rule 54 (binary_exp -> exp AND exp .) ]
  ! LESS            [ reduce using rule 54 (binary_exp -> exp AND exp .) ]
  ! LESS_EQUAL      [ reduce using rule 54 (binary_exp -> exp AND exp .) ]
  ! GREATER         [ reduce using rule 54 (binary_exp -> exp AND exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 54 (binary_exp -> exp AND exp .) ]
  ! AND             [ shift and go to state 77 ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 110

    (55) binary_exp -> exp OR exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    OR              reduce using rule 55 (binary_exp -> exp OR exp .)
    SEMICOLON       reduce using rule 55 (binary_exp -> exp OR exp .)
    LET             reduce using rule 55 (binary_exp -> exp OR exp .)
    $end            reduce using rule 55 (binary_exp -> exp OR exp .)
    RPAREN          reduce using rule 55 (binary_exp -> exp OR exp .)
    THEN            reduce using rule 55 (binary_exp -> exp OR exp .)
    DO              reduce using rule 55 (binary_exp -> exp OR exp .)
    COMMA           reduce using rule 55 (binary_exp -> exp OR exp .)
    RBRACKET        reduce using rule 55 (binary_exp -> exp OR exp .)
    ELSE            reduce using rule 55 (binary_exp -> exp OR exp .)
    BAR             reduce using rule 55 (binary_exp -> exp OR exp .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POWER           shift and go to state 71
    EQUALS          shift and go to state 65
    NOT_EQUALS      shift and go to state 72
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76
    AND             shift and go to state 77

  ! PLUS            [ reduce using rule 55 (binary_exp -> exp OR exp .) ]
  ! MINUS           [ reduce using rule 55 (binary_exp -> exp OR exp .) ]
  ! TIMES           [ reduce using rule 55 (binary_exp -> exp OR exp .) ]
  ! DIVIDE          [ reduce using rule 55 (binary_exp -> exp OR exp .) ]
  ! MOD             [ reduce using rule 55 (binary_exp -> exp OR exp .) ]
  ! POWER           [ reduce using rule 55 (binary_exp -> exp OR exp .) ]
  ! EQUALS          [ reduce using rule 55 (binary_exp -> exp OR exp .) ]
  ! NOT_EQUALS      [ reduce using rule 55 (binary_exp -> exp OR exp .) ]
  ! LESS            [ reduce using rule 55 (binary_exp -> exp OR exp .) ]
  ! LESS_EQUAL      [ reduce using rule 55 (binary_exp -> exp OR exp .) ]
  ! GREATER         [ reduce using rule 55 (binary_exp -> exp OR exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 55 (binary_exp -> exp OR exp .) ]
  ! AND             [ reduce using rule 55 (binary_exp -> exp OR exp .) ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 111

    (56) binary_exp -> exp SEMICOLON exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    LET             reduce using rule 56 (binary_exp -> exp SEMICOLON exp .)
    $end            reduce using rule 56 (binary_exp -> exp SEMICOLON exp .)
    RPAREN          reduce using rule 56 (binary_exp -> exp SEMICOLON exp .)
    THEN            reduce using rule 56 (binary_exp -> exp SEMICOLON exp .)
    DO              reduce using rule 56 (binary_exp -> exp SEMICOLON exp .)
    COMMA           reduce using rule 56 (binary_exp -> exp SEMICOLON exp .)
    RBRACKET        reduce using rule 56 (binary_exp -> exp SEMICOLON exp .)
    ELSE            reduce using rule 56 (binary_exp -> exp SEMICOLON exp .)
    BAR             reduce using rule 56 (binary_exp -> exp SEMICOLON exp .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POWER           shift and go to state 71
    EQUALS          shift and go to state 65
    NOT_EQUALS      shift and go to state 72
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    SEMICOLON       shift and go to state 79

  ! PLUS            [ reduce using rule 56 (binary_exp -> exp SEMICOLON exp .) ]
  ! MINUS           [ reduce using rule 56 (binary_exp -> exp SEMICOLON exp .) ]
  ! TIMES           [ reduce using rule 56 (binary_exp -> exp SEMICOLON exp .) ]
  ! DIVIDE          [ reduce using rule 56 (binary_exp -> exp SEMICOLON exp .) ]
  ! MOD             [ reduce using rule 56 (binary_exp -> exp SEMICOLON exp .) ]
  ! POWER           [ reduce using rule 56 (binary_exp -> exp SEMICOLON exp .) ]
  ! EQUALS          [ reduce using rule 56 (binary_exp -> exp SEMICOLON exp .) ]
  ! NOT_EQUALS      [ reduce using rule 56 (binary_exp -> exp SEMICOLON exp .) ]
  ! LESS            [ reduce using rule 56 (binary_exp -> exp SEMICOLON exp .) ]
  ! LESS_EQUAL      [ reduce using rule 56 (binary_exp -> exp SEMICOLON exp .) ]
  ! GREATER         [ reduce using rule 56 (binary_exp -> exp SEMICOLON exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 56 (binary_exp -> exp SEMICOLON exp .) ]
  ! AND             [ reduce using rule 56 (binary_exp -> exp SEMICOLON exp .) ]
  ! OR              [ reduce using rule 56 (binary_exp -> exp SEMICOLON exp .) ]
  ! SEMICOLON       [ reduce using rule 56 (binary_exp -> exp SEMICOLON exp .) ]


state 112

    (73) group -> LPAREN exp RPAREN .

    PLUS            reduce using rule 73 (group -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 73 (group -> LPAREN exp RPAREN .)
    TIMES           reduce using rule 73 (group -> LPAREN exp RPAREN .)
    DIVIDE          reduce using rule 73 (group -> LPAREN exp RPAREN .)
    MOD             reduce using rule 73 (group -> LPAREN exp RPAREN .)
    POWER           reduce using rule 73 (group -> LPAREN exp RPAREN .)
    EQUALS          reduce using rule 73 (group -> LPAREN exp RPAREN .)
    NOT_EQUALS      reduce using rule 73 (group -> LPAREN exp RPAREN .)
    LESS            reduce using rule 73 (group -> LPAREN exp RPAREN .)
    LESS_EQUAL      reduce using rule 73 (group -> LPAREN exp RPAREN .)
    GREATER         reduce using rule 73 (group -> LPAREN exp RPAREN .)
    GREATER_EQUAL   reduce using rule 73 (group -> LPAREN exp RPAREN .)
    AND             reduce using rule 73 (group -> LPAREN exp RPAREN .)
    OR              reduce using rule 73 (group -> LPAREN exp RPAREN .)
    SEMICOLON       reduce using rule 73 (group -> LPAREN exp RPAREN .)
    LET             reduce using rule 73 (group -> LPAREN exp RPAREN .)
    $end            reduce using rule 73 (group -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 73 (group -> LPAREN exp RPAREN .)
    THEN            reduce using rule 73 (group -> LPAREN exp RPAREN .)
    DO              reduce using rule 73 (group -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 73 (group -> LPAREN exp RPAREN .)
    RBRACKET        reduce using rule 73 (group -> LPAREN exp RPAREN .)
    ELSE            reduce using rule 73 (group -> LPAREN exp RPAREN .)
    BAR             reduce using rule 73 (group -> LPAREN exp RPAREN .)


state 113

    (63) assignment -> SET lhs EQUALS . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . conditional
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs EQUALS exp
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (68) conditional -> . IF exp THEN exp conditional_else
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 33
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    lhs                            shift and go to state 57
    exp                            shift and go to state 125
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    conditional                    shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46

state 114

    (66) array_access -> lhs LBRACKET exp . RBRACKET
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    RBRACKET        shift and go to state 126
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POWER           shift and go to state 71
    EQUALS          shift and go to state 65
    NOT_EQUALS      shift and go to state 72
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    SEMICOLON       shift and go to state 79


state 115

    (68) conditional -> IF exp THEN . exp conditional_else
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . conditional
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs EQUALS exp
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (68) conditional -> . IF exp THEN exp conditional_else
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 33
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 127
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    conditional                    shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 116

    (71) while_loop -> WHILE exp DO . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . conditional
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs EQUALS exp
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (68) conditional -> . IF exp THEN exp conditional_else
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 33
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 128
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    conditional                    shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 117

    (72) array_creation -> NEW type LBRACKET . exp BAR exp RBRACKET
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . conditional
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs EQUALS exp
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (68) conditional -> . IF exp THEN exp conditional_else
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 33
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 129
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    conditional                    shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 118

    (19) function_type -> LPAREN type . function_type_tail RPAREN ARROW type
    (20) function_type_tail -> . COMMA type function_type_tail
    (21) function_type_tail -> . empty
    (74) empty -> .

    COMMA           shift and go to state 131
    RPAREN          reduce using rule 74 (empty -> .)

    function_type_tail             shift and go to state 130
    empty                          shift and go to state 132

state 119

    (7) function_declaration -> LET ID LPAREN parameters RPAREN COLON function_type EQUALS . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . conditional
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs EQUALS exp
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (68) conditional -> . IF exp THEN exp conditional_else
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 33
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 133
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    conditional                    shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 120

    (18) function_type -> type ARROW . type
    (11) type -> . base_type array_suffix
    (12) base_type -> . INT_TYPE
    (13) base_type -> . BOOL_TYPE
    (14) base_type -> . UNIT_TYPE
    (15) base_type -> . STRING_TYPE

    INT_TYPE        shift and go to state 18
    BOOL_TYPE       shift and go to state 19
    UNIT_TYPE       shift and go to state 20
    STRING_TYPE     shift and go to state 21

    type                           shift and go to state 134
    base_type                      shift and go to state 17

state 121

    (59) function_call -> variable LPAREN arguments RPAREN .

    PLUS            reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    MINUS           reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    TIMES           reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    DIVIDE          reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    MOD             reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    POWER           reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    EQUALS          reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    NOT_EQUALS      reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    LESS            reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    LESS_EQUAL      reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    GREATER         reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    GREATER_EQUAL   reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    AND             reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    OR              reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    SEMICOLON       reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    LET             reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    $end            reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    THEN            reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    DO              reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    COMMA           reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    RBRACKET        reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    ELSE            reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)
    BAR             reduce using rule 59 (function_call -> variable LPAREN arguments RPAREN .)


state 122

    (60) arguments -> exp arguments_tail .

    RPAREN          reduce using rule 60 (arguments -> exp arguments_tail .)


state 123

    (61) arguments_tail -> COMMA . exp arguments_tail
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . conditional
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs EQUALS exp
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (68) conditional -> . IF exp THEN exp conditional_else
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 33
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 135
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    conditional                    shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 124

    (62) arguments_tail -> empty .

    RPAREN          reduce using rule 62 (arguments_tail -> empty .)


state 125

    (63) assignment -> SET lhs EQUALS exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    EQUALS          reduce using rule 63 (assignment -> SET lhs EQUALS exp .)
    NOT_EQUALS      reduce using rule 63 (assignment -> SET lhs EQUALS exp .)
    AND             reduce using rule 63 (assignment -> SET lhs EQUALS exp .)
    OR              reduce using rule 63 (assignment -> SET lhs EQUALS exp .)
    SEMICOLON       reduce using rule 63 (assignment -> SET lhs EQUALS exp .)
    LET             reduce using rule 63 (assignment -> SET lhs EQUALS exp .)
    $end            reduce using rule 63 (assignment -> SET lhs EQUALS exp .)
    RPAREN          reduce using rule 63 (assignment -> SET lhs EQUALS exp .)
    THEN            reduce using rule 63 (assignment -> SET lhs EQUALS exp .)
    DO              reduce using rule 63 (assignment -> SET lhs EQUALS exp .)
    COMMA           reduce using rule 63 (assignment -> SET lhs EQUALS exp .)
    RBRACKET        reduce using rule 63 (assignment -> SET lhs EQUALS exp .)
    ELSE            reduce using rule 63 (assignment -> SET lhs EQUALS exp .)
    BAR             reduce using rule 63 (assignment -> SET lhs EQUALS exp .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POWER           shift and go to state 71
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76

  ! PLUS            [ reduce using rule 63 (assignment -> SET lhs EQUALS exp .) ]
  ! MINUS           [ reduce using rule 63 (assignment -> SET lhs EQUALS exp .) ]
  ! TIMES           [ reduce using rule 63 (assignment -> SET lhs EQUALS exp .) ]
  ! DIVIDE          [ reduce using rule 63 (assignment -> SET lhs EQUALS exp .) ]
  ! MOD             [ reduce using rule 63 (assignment -> SET lhs EQUALS exp .) ]
  ! POWER           [ reduce using rule 63 (assignment -> SET lhs EQUALS exp .) ]
  ! LESS            [ reduce using rule 63 (assignment -> SET lhs EQUALS exp .) ]
  ! LESS_EQUAL      [ reduce using rule 63 (assignment -> SET lhs EQUALS exp .) ]
  ! GREATER         [ reduce using rule 63 (assignment -> SET lhs EQUALS exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 63 (assignment -> SET lhs EQUALS exp .) ]
  ! EQUALS          [ shift and go to state 65 ]
  ! NOT_EQUALS      [ shift and go to state 72 ]
  ! AND             [ shift and go to state 77 ]
  ! OR              [ shift and go to state 78 ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 126

    (66) array_access -> lhs LBRACKET exp RBRACKET .

    PLUS            reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    MINUS           reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    TIMES           reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    DIVIDE          reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    MOD             reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    POWER           reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    EQUALS          reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    NOT_EQUALS      reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    LESS            reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    LESS_EQUAL      reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    GREATER         reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    GREATER_EQUAL   reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    AND             reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    OR              reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    SEMICOLON       reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    LET             reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    $end            reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    THEN            reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    DO              reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    COMMA           reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    RBRACKET        reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    ELSE            reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    BAR             reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)
    LBRACKET        reduce using rule 66 (array_access -> lhs LBRACKET exp RBRACKET .)


state 127

    (68) conditional -> IF exp THEN exp . conditional_else
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp
    (69) conditional_else -> . ELSE exp
    (70) conditional_else -> . empty
    (74) empty -> .

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for NOT_EQUALS resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POWER           shift and go to state 71
    EQUALS          shift and go to state 65
    NOT_EQUALS      shift and go to state 72
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    SEMICOLON       shift and go to state 79
    ELSE            shift and go to state 137
    LET             reduce using rule 74 (empty -> .)
    $end            reduce using rule 74 (empty -> .)
    RPAREN          reduce using rule 74 (empty -> .)
    THEN            reduce using rule 74 (empty -> .)
    DO              reduce using rule 74 (empty -> .)
    COMMA           reduce using rule 74 (empty -> .)
    RBRACKET        reduce using rule 74 (empty -> .)
    BAR             reduce using rule 74 (empty -> .)

  ! PLUS            [ reduce using rule 74 (empty -> .) ]
  ! MINUS           [ reduce using rule 74 (empty -> .) ]
  ! TIMES           [ reduce using rule 74 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 74 (empty -> .) ]
  ! MOD             [ reduce using rule 74 (empty -> .) ]
  ! POWER           [ reduce using rule 74 (empty -> .) ]
  ! EQUALS          [ reduce using rule 74 (empty -> .) ]
  ! NOT_EQUALS      [ reduce using rule 74 (empty -> .) ]
  ! LESS            [ reduce using rule 74 (empty -> .) ]
  ! LESS_EQUAL      [ reduce using rule 74 (empty -> .) ]
  ! GREATER         [ reduce using rule 74 (empty -> .) ]
  ! GREATER_EQUAL   [ reduce using rule 74 (empty -> .) ]
  ! AND             [ reduce using rule 74 (empty -> .) ]
  ! OR              [ reduce using rule 74 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 74 (empty -> .) ]
  ! ELSE            [ reduce using rule 74 (empty -> .) ]

    conditional_else               shift and go to state 136
    empty                          shift and go to state 138

state 128

    (71) while_loop -> WHILE exp DO exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    SEMICOLON       reduce using rule 71 (while_loop -> WHILE exp DO exp .)
    LET             reduce using rule 71 (while_loop -> WHILE exp DO exp .)
    $end            reduce using rule 71 (while_loop -> WHILE exp DO exp .)
    RPAREN          reduce using rule 71 (while_loop -> WHILE exp DO exp .)
    THEN            reduce using rule 71 (while_loop -> WHILE exp DO exp .)
    DO              reduce using rule 71 (while_loop -> WHILE exp DO exp .)
    COMMA           reduce using rule 71 (while_loop -> WHILE exp DO exp .)
    RBRACKET        reduce using rule 71 (while_loop -> WHILE exp DO exp .)
    ELSE            reduce using rule 71 (while_loop -> WHILE exp DO exp .)
    BAR             reduce using rule 71 (while_loop -> WHILE exp DO exp .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POWER           shift and go to state 71
    EQUALS          shift and go to state 65
    NOT_EQUALS      shift and go to state 72
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78

  ! PLUS            [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! MINUS           [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! TIMES           [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! DIVIDE          [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! MOD             [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! POWER           [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! EQUALS          [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! NOT_EQUALS      [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! LESS            [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! LESS_EQUAL      [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! GREATER         [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! AND             [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! OR              [ reduce using rule 71 (while_loop -> WHILE exp DO exp .) ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 129

    (72) array_creation -> NEW type LBRACKET exp . BAR exp RBRACKET
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    BAR             shift and go to state 139
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POWER           shift and go to state 71
    EQUALS          shift and go to state 65
    NOT_EQUALS      shift and go to state 72
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    SEMICOLON       shift and go to state 79


state 130

    (19) function_type -> LPAREN type function_type_tail . RPAREN ARROW type

    RPAREN          shift and go to state 140


state 131

    (20) function_type_tail -> COMMA . type function_type_tail
    (11) type -> . base_type array_suffix
    (12) base_type -> . INT_TYPE
    (13) base_type -> . BOOL_TYPE
    (14) base_type -> . UNIT_TYPE
    (15) base_type -> . STRING_TYPE

    INT_TYPE        shift and go to state 18
    BOOL_TYPE       shift and go to state 19
    UNIT_TYPE       shift and go to state 20
    STRING_TYPE     shift and go to state 21

    type                           shift and go to state 141
    base_type                      shift and go to state 17

state 132

    (21) function_type_tail -> empty .

    RPAREN          reduce using rule 21 (function_type_tail -> empty .)


state 133

    (7) function_declaration -> LET ID LPAREN parameters RPAREN COLON function_type EQUALS exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    LET             reduce using rule 7 (function_declaration -> LET ID LPAREN parameters RPAREN COLON function_type EQUALS exp .)
    $end            reduce using rule 7 (function_declaration -> LET ID LPAREN parameters RPAREN COLON function_type EQUALS exp .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POWER           shift and go to state 71
    EQUALS          shift and go to state 65
    NOT_EQUALS      shift and go to state 72
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    SEMICOLON       shift and go to state 79


state 134

    (18) function_type -> type ARROW type .

    EQUALS          reduce using rule 18 (function_type -> type ARROW type .)


state 135

    (61) arguments_tail -> COMMA exp . arguments_tail
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp
    (61) arguments_tail -> . COMMA exp arguments_tail
    (62) arguments_tail -> . empty
    (74) empty -> .

    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POWER           shift and go to state 71
    EQUALS          shift and go to state 65
    NOT_EQUALS      shift and go to state 72
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    SEMICOLON       shift and go to state 79
    COMMA           shift and go to state 123
    RPAREN          reduce using rule 74 (empty -> .)

    arguments_tail                 shift and go to state 142
    empty                          shift and go to state 124

state 136

    (68) conditional -> IF exp THEN exp conditional_else .

    PLUS            reduce using rule 68 (conditional -> IF exp THEN exp conditional_else .)
    MINUS           reduce using rule 68 (conditional -> IF exp THEN exp conditional_else .)
    TIMES           reduce using rule 68 (conditional -> IF exp THEN exp conditional_else .)
    DIVIDE          reduce using rule 68 (conditional -> IF exp THEN exp conditional_else .)
    MOD             reduce using rule 68 (conditional -> IF exp THEN exp conditional_else .)
    POWER           reduce using rule 68 (conditional -> IF exp THEN exp conditional_else .)
    EQUALS          reduce using rule 68 (conditional -> IF exp THEN exp conditional_else .)
    NOT_EQUALS      reduce using rule 68 (conditional -> IF exp THEN exp conditional_else .)
    LESS            reduce using rule 68 (conditional -> IF exp THEN exp conditional_else .)
    LESS_EQUAL      reduce using rule 68 (conditional -> IF exp THEN exp conditional_else .)
    GREATER         reduce using rule 68 (conditional -> IF exp THEN exp conditional_else .)
    GREATER_EQUAL   reduce using rule 68 (conditional -> IF exp THEN exp conditional_else .)
    AND             reduce using rule 68 (conditional -> IF exp THEN exp conditional_else .)
    OR              reduce using rule 68 (conditional -> IF exp THEN exp conditional_else .)
    SEMICOLON       reduce using rule 68 (conditional -> IF exp THEN exp conditional_else .)
    LET             reduce using rule 68 (conditional -> IF exp THEN exp conditional_else .)
    $end            reduce using rule 68 (conditional -> IF exp THEN exp conditional_else .)
    RPAREN          reduce using rule 68 (conditional -> IF exp THEN exp conditional_else .)
    THEN            reduce using rule 68 (conditional -> IF exp THEN exp conditional_else .)
    DO              reduce using rule 68 (conditional -> IF exp THEN exp conditional_else .)
    COMMA           reduce using rule 68 (conditional -> IF exp THEN exp conditional_else .)
    RBRACKET        reduce using rule 68 (conditional -> IF exp THEN exp conditional_else .)
    ELSE            reduce using rule 68 (conditional -> IF exp THEN exp conditional_else .)
    BAR             reduce using rule 68 (conditional -> IF exp THEN exp conditional_else .)


state 137

    (69) conditional_else -> ELSE . exp
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . conditional
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs EQUALS exp
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (68) conditional -> . IF exp THEN exp conditional_else
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 33
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 143
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    conditional                    shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 138

    (70) conditional_else -> empty .

    PLUS            reduce using rule 70 (conditional_else -> empty .)
    MINUS           reduce using rule 70 (conditional_else -> empty .)
    TIMES           reduce using rule 70 (conditional_else -> empty .)
    DIVIDE          reduce using rule 70 (conditional_else -> empty .)
    MOD             reduce using rule 70 (conditional_else -> empty .)
    POWER           reduce using rule 70 (conditional_else -> empty .)
    EQUALS          reduce using rule 70 (conditional_else -> empty .)
    NOT_EQUALS      reduce using rule 70 (conditional_else -> empty .)
    LESS            reduce using rule 70 (conditional_else -> empty .)
    LESS_EQUAL      reduce using rule 70 (conditional_else -> empty .)
    GREATER         reduce using rule 70 (conditional_else -> empty .)
    GREATER_EQUAL   reduce using rule 70 (conditional_else -> empty .)
    AND             reduce using rule 70 (conditional_else -> empty .)
    OR              reduce using rule 70 (conditional_else -> empty .)
    SEMICOLON       reduce using rule 70 (conditional_else -> empty .)
    LET             reduce using rule 70 (conditional_else -> empty .)
    $end            reduce using rule 70 (conditional_else -> empty .)
    RPAREN          reduce using rule 70 (conditional_else -> empty .)
    THEN            reduce using rule 70 (conditional_else -> empty .)
    DO              reduce using rule 70 (conditional_else -> empty .)
    COMMA           reduce using rule 70 (conditional_else -> empty .)
    RBRACKET        reduce using rule 70 (conditional_else -> empty .)
    ELSE            reduce using rule 70 (conditional_else -> empty .)
    BAR             reduce using rule 70 (conditional_else -> empty .)


state 139

    (72) array_creation -> NEW type LBRACKET exp BAR . exp RBRACKET
    (22) exp -> . variable
    (23) exp -> . literal
    (24) exp -> . binary_exp
    (25) exp -> . unary_exp
    (26) exp -> . function_call
    (27) exp -> . assignment
    (28) exp -> . variable_declaration
    (29) exp -> . conditional
    (30) exp -> . while_loop
    (31) exp -> . array_creation
    (32) exp -> . array_access
    (33) exp -> . group
    (34) variable -> . ID
    (35) variable -> . UNDERSCORE
    (36) literal -> . INT_LITERAL
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . NULL
    (40) literal -> . UNIT
    (41) literal -> . STRING_LITERAL
    (42) binary_exp -> . exp PLUS exp
    (43) binary_exp -> . exp MINUS exp
    (44) binary_exp -> . exp TIMES exp
    (45) binary_exp -> . exp DIVIDE exp
    (46) binary_exp -> . exp MOD exp
    (47) binary_exp -> . exp POWER exp
    (48) binary_exp -> . exp EQUALS exp
    (49) binary_exp -> . exp NOT_EQUALS exp
    (50) binary_exp -> . exp LESS exp
    (51) binary_exp -> . exp LESS_EQUAL exp
    (52) binary_exp -> . exp GREATER exp
    (53) binary_exp -> . exp GREATER_EQUAL exp
    (54) binary_exp -> . exp AND exp
    (55) binary_exp -> . exp OR exp
    (56) binary_exp -> . exp SEMICOLON exp
    (57) unary_exp -> . MINUS exp
    (58) unary_exp -> . NOT exp
    (59) function_call -> . variable LPAREN arguments RPAREN
    (63) assignment -> . SET lhs EQUALS exp
    (67) variable_declaration -> . LET variable COLON type EQUALS exp
    (68) conditional -> . IF exp THEN exp conditional_else
    (71) while_loop -> . WHILE exp DO exp
    (72) array_creation -> . NEW type LBRACKET exp BAR exp RBRACKET
    (66) array_access -> . lhs LBRACKET exp RBRACKET
    (73) group -> . LPAREN exp RPAREN
    (64) lhs -> . variable
    (65) lhs -> . array_access

    ID              shift and go to state 22
    UNDERSCORE      shift and go to state 12
    INT_LITERAL     shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    NULL            shift and go to state 50
    UNIT            shift and go to state 51
    STRING_LITERAL  shift and go to state 52
    MINUS           shift and go to state 53
    NOT             shift and go to state 54
    SET             shift and go to state 56
    LET             shift and go to state 33
    IF              shift and go to state 58
    WHILE           shift and go to state 59
    NEW             shift and go to state 60
    LPAREN          shift and go to state 55

    exp                            shift and go to state 144
    variable                       shift and go to state 34
    literal                        shift and go to state 36
    binary_exp                     shift and go to state 37
    unary_exp                      shift and go to state 38
    function_call                  shift and go to state 39
    assignment                     shift and go to state 40
    variable_declaration           shift and go to state 41
    conditional                    shift and go to state 42
    while_loop                     shift and go to state 43
    array_creation                 shift and go to state 44
    array_access                   shift and go to state 45
    group                          shift and go to state 46
    lhs                            shift and go to state 57

state 140

    (19) function_type -> LPAREN type function_type_tail RPAREN . ARROW type

    ARROW           shift and go to state 145


state 141

    (20) function_type_tail -> COMMA type . function_type_tail
    (20) function_type_tail -> . COMMA type function_type_tail
    (21) function_type_tail -> . empty
    (74) empty -> .

    COMMA           shift and go to state 131
    RPAREN          reduce using rule 74 (empty -> .)

    function_type_tail             shift and go to state 146
    empty                          shift and go to state 132

state 142

    (61) arguments_tail -> COMMA exp arguments_tail .

    RPAREN          reduce using rule 61 (arguments_tail -> COMMA exp arguments_tail .)


state 143

    (69) conditional_else -> ELSE exp .
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    SEMICOLON       reduce using rule 69 (conditional_else -> ELSE exp .)
    LET             reduce using rule 69 (conditional_else -> ELSE exp .)
    $end            reduce using rule 69 (conditional_else -> ELSE exp .)
    RPAREN          reduce using rule 69 (conditional_else -> ELSE exp .)
    THEN            reduce using rule 69 (conditional_else -> ELSE exp .)
    DO              reduce using rule 69 (conditional_else -> ELSE exp .)
    COMMA           reduce using rule 69 (conditional_else -> ELSE exp .)
    RBRACKET        reduce using rule 69 (conditional_else -> ELSE exp .)
    ELSE            reduce using rule 69 (conditional_else -> ELSE exp .)
    BAR             reduce using rule 69 (conditional_else -> ELSE exp .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POWER           shift and go to state 71
    EQUALS          shift and go to state 65
    NOT_EQUALS      shift and go to state 72
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78

  ! PLUS            [ reduce using rule 69 (conditional_else -> ELSE exp .) ]
  ! MINUS           [ reduce using rule 69 (conditional_else -> ELSE exp .) ]
  ! TIMES           [ reduce using rule 69 (conditional_else -> ELSE exp .) ]
  ! DIVIDE          [ reduce using rule 69 (conditional_else -> ELSE exp .) ]
  ! MOD             [ reduce using rule 69 (conditional_else -> ELSE exp .) ]
  ! POWER           [ reduce using rule 69 (conditional_else -> ELSE exp .) ]
  ! EQUALS          [ reduce using rule 69 (conditional_else -> ELSE exp .) ]
  ! NOT_EQUALS      [ reduce using rule 69 (conditional_else -> ELSE exp .) ]
  ! LESS            [ reduce using rule 69 (conditional_else -> ELSE exp .) ]
  ! LESS_EQUAL      [ reduce using rule 69 (conditional_else -> ELSE exp .) ]
  ! GREATER         [ reduce using rule 69 (conditional_else -> ELSE exp .) ]
  ! GREATER_EQUAL   [ reduce using rule 69 (conditional_else -> ELSE exp .) ]
  ! AND             [ reduce using rule 69 (conditional_else -> ELSE exp .) ]
  ! OR              [ reduce using rule 69 (conditional_else -> ELSE exp .) ]
  ! SEMICOLON       [ shift and go to state 79 ]


state 144

    (72) array_creation -> NEW type LBRACKET exp BAR exp . RBRACKET
    (42) binary_exp -> exp . PLUS exp
    (43) binary_exp -> exp . MINUS exp
    (44) binary_exp -> exp . TIMES exp
    (45) binary_exp -> exp . DIVIDE exp
    (46) binary_exp -> exp . MOD exp
    (47) binary_exp -> exp . POWER exp
    (48) binary_exp -> exp . EQUALS exp
    (49) binary_exp -> exp . NOT_EQUALS exp
    (50) binary_exp -> exp . LESS exp
    (51) binary_exp -> exp . LESS_EQUAL exp
    (52) binary_exp -> exp . GREATER exp
    (53) binary_exp -> exp . GREATER_EQUAL exp
    (54) binary_exp -> exp . AND exp
    (55) binary_exp -> exp . OR exp
    (56) binary_exp -> exp . SEMICOLON exp

    RBRACKET        shift and go to state 147
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    TIMES           shift and go to state 68
    DIVIDE          shift and go to state 69
    MOD             shift and go to state 70
    POWER           shift and go to state 71
    EQUALS          shift and go to state 65
    NOT_EQUALS      shift and go to state 72
    LESS            shift and go to state 73
    LESS_EQUAL      shift and go to state 74
    GREATER         shift and go to state 75
    GREATER_EQUAL   shift and go to state 76
    AND             shift and go to state 77
    OR              shift and go to state 78
    SEMICOLON       shift and go to state 79


state 145

    (19) function_type -> LPAREN type function_type_tail RPAREN ARROW . type
    (11) type -> . base_type array_suffix
    (12) base_type -> . INT_TYPE
    (13) base_type -> . BOOL_TYPE
    (14) base_type -> . UNIT_TYPE
    (15) base_type -> . STRING_TYPE

    INT_TYPE        shift and go to state 18
    BOOL_TYPE       shift and go to state 19
    UNIT_TYPE       shift and go to state 20
    STRING_TYPE     shift and go to state 21

    type                           shift and go to state 148
    base_type                      shift and go to state 17

state 146

    (20) function_type_tail -> COMMA type function_type_tail .

    RPAREN          reduce using rule 20 (function_type_tail -> COMMA type function_type_tail .)


state 147

    (72) array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .

    PLUS            reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    MINUS           reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    TIMES           reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    DIVIDE          reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    MOD             reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    POWER           reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    EQUALS          reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    NOT_EQUALS      reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    LESS            reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    LESS_EQUAL      reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    GREATER         reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    GREATER_EQUAL   reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    AND             reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    OR              reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    SEMICOLON       reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    LET             reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    $end            reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    RPAREN          reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    THEN            reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    DO              reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    COMMA           reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    RBRACKET        reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    ELSE            reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)
    BAR             reduce using rule 72 (array_creation -> NEW type LBRACKET exp BAR exp RBRACKET .)


state 148

    (19) function_type -> LPAREN type function_type_tail RPAREN ARROW type .

    EQUALS          reduce using rule 19 (function_type -> LPAREN type function_type_tail RPAREN ARROW type .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LBRACKET in state 17 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 61 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 127 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 127 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 127 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 127 resolved as shift
WARNING: shift/reduce conflict for MOD in state 127 resolved as shift
WARNING: shift/reduce conflict for POWER in state 127 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 127 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUALS in state 127 resolved as shift
WARNING: shift/reduce conflict for LESS in state 127 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 127 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 127 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 127 resolved as shift
WARNING: shift/reduce conflict for AND in state 127 resolved as shift
WARNING: shift/reduce conflict for OR in state 127 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 127 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 127 resolved as shift
